
// Generated from SQLiteParser.g4 by ANTLR 4.13.2


#include "SQLiteParserListener.h"
#include "SQLiteParserVisitor.h"

#include "SQLiteParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SQLiteParserStaticData final {
  SQLiteParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SQLiteParserStaticData(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData(SQLiteParserStaticData&&) = delete;
  SQLiteParserStaticData& operator=(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData& operator=(SQLiteParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sqliteparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<SQLiteParserStaticData> sqliteparserParserStaticData = nullptr;

void sqliteparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (sqliteparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(sqliteparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SQLiteParserStaticData>(
    std::vector<std::string>{
      "parse", "sql_stmt_list", "sql_stmt", "alter_table_stmt", "analyze_stmt", 
      "attach_stmt", "begin_stmt", "commit_stmt", "rollback_stmt", "savepoint_stmt", 
      "release_stmt", "create_index_stmt", "indexed_column", "create_table_stmt", 
      "column_def", "type_name", "column_constraint", "signed_number", "table_constraint", 
      "foreign_key_clause", "conflict_clause", "create_trigger_stmt", "create_view_stmt", 
      "create_virtual_table_stmt", "with_clause", "cte_table_name", "recursive_cte", 
      "common_table_expression", "delete_stmt", "delete_stmt_limited", "detach_stmt", 
      "drop_stmt", "expr", "raise_function", "literal_value", "value_row", 
      "values_clause", "insert_stmt", "returning_clause", "upsert_clause", 
      "pragma_stmt", "pragma_value", "reindex_stmt", "select_stmt", "join_clause", 
      "select_core", "factored_select_stmt", "simple_select_stmt", "compound_select_stmt", 
      "table_or_subquery", "result_column", "join_operator", "join_constraint", 
      "compound_operator", "update_stmt", "column_name_list", "update_stmt_limited", 
      "qualified_table_name", "vacuum_stmt", "filter_clause", "window_defn", 
      "over_clause", "frame_spec", "frame_clause", "simple_function_invocation", 
      "aggregate_function_invocation", "window_function_invocation", "common_table_stmt", 
      "order_by_stmt", "limit_stmt", "ordering_term", "asc_desc", "frame_left", 
      "frame_right", "frame_single", "window_function", "offset", "default_value", 
      "partition_by", "order_by_expr", "order_by_expr_asc_desc", "expr_asc_desc", 
      "initial_select", "recursive_select", "unary_operator", "error_message", 
      "module_argument", "column_alias", "keyword", "name", "function_name", 
      "schema_name", "table_name", "table_or_index_name", "column_name", 
      "collation_name", "foreign_table", "index_name", "trigger_name", "view_name", 
      "module_name", "pragma_name", "savepoint_name", "table_alias", "transaction_name", 
      "window_name", "alias", "filename", "base_window_name", "simple_func", 
      "aggregate_func", "table_function_name", "any_name"
    },
    std::vector<std::string>{
      "", "';'", "'.'", "'('", "')'", "','", "'='", "'*'", "'+'", "'-'", 
      "'~'", "'||'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'<'", 
      "'<='", "'>'", "'>='", "'=='", "'!='", "'<>'", "'ABORT'", "'ACTION'", 
      "'ADD'", "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'AS'", 
      "'ASC'", "'ATTACH'", "'AUTOINCREMENT'", "'BEFORE'", "'BEGIN'", "'BETWEEN'", 
      "'BY'", "'CASCADE'", "'CASE'", "'CAST'", "'CHECK'", "'COLLATE'", "'COLUMN'", 
      "'COMMIT'", "'CONFLICT'", "'CONSTRAINT'", "'CREATE'", "'CROSS'", "'CURRENT_DATE'", 
      "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'DATABASE'", "'DEFAULT'", 
      "'DEFERRABLE'", "'DEFERRED'", "'DELETE'", "'DESC'", "'DETACH'", "'DISTINCT'", 
      "'DROP'", "'EACH'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUSIVE'", 
      "'EXISTS'", "'EXPLAIN'", "'FAIL'", "'FOR'", "'FOREIGN'", "'FROM'", 
      "'FULL'", "'GLOB'", "'GROUP'", "'HAVING'", "'IF'", "'IGNORE'", "'IMMEDIATE'", 
      "'IN'", "'INDEX'", "'INDEXED'", "'INITIALLY'", "'INNER'", "'INSERT'", 
      "'INSTEAD'", "'INTERSECT'", "'INTO'", "'IS'", "'ISNULL'", "'JOIN'", 
      "'KEY'", "'LEFT'", "'LIKE'", "'LIMIT'", "'MATCH'", "'NATURAL'", "'NO'", 
      "'NOT'", "'NOTNULL'", "'NULL'", "'OF'", "'OFFSET'", "'ON'", "'OR'", 
      "'ORDER'", "'OUTER'", "'PLAN'", "'PRAGMA'", "'PRIMARY'", "'QUERY'", 
      "'RAISE'", "'RECURSIVE'", "'REFERENCES'", "'REGEXP'", "'REINDEX'", 
      "'RELEASE'", "'RENAME'", "'REPLACE'", "'RESTRICT'", "'RETURNING'", 
      "'RIGHT'", "'ROLLBACK'", "'ROW'", "'ROWS'", "'SAVEPOINT'", "'SELECT'", 
      "'SET'", "'TABLE'", "'TEMP'", "'TEMPORARY'", "'THEN'", "'TO'", "'TRANSACTION'", 
      "'TRIGGER'", "'UNION'", "'UNIQUE'", "'UPDATE'", "'USING'", "'VACUUM'", 
      "'VALUES'", "'VIEW'", "'VIRTUAL'", "'WHEN'", "'WHERE'", "'WITH'", 
      "'WITHOUT'", "'FIRST_VALUE'", "'OVER'", "'PARTITION'", "'RANGE'", 
      "'PRECEDING'", "'UNBOUNDED'", "'CURRENT'", "'FOLLOWING'", "'CUME_DIST'", 
      "'DENSE_RANK'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'NTH_VALUE'", 
      "'NTILE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'GENERATED'", 
      "'ALWAYS'", "'STORED'", "'TRUE'", "'FALSE'", "'WINDOW'", "'NULLS'", 
      "'FIRST'", "'LAST'", "'FILTER'", "'GROUPS'", "'EXCLUDE'", "'TIES'", 
      "'OTHERS'", "'DO'", "'NOTHING'"
    },
    std::vector<std::string>{
      "", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", "COMMA", "ASSIGN", "STAR", 
      "PLUS", "MINUS", "TILDE", "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", 
      "PIPE", "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
      "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", "ANALYZE_", 
      "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", "BEFORE_", "BEGIN_", 
      "BETWEEN_", "BY_", "CASCADE_", "CASE_", "CAST_", "CHECK_", "COLLATE_", 
      "COLUMN_", "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", "CROSS_", 
      "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", "DATABASE_", 
      "DEFAULT_", "DEFERRABLE_", "DEFERRED_", "DELETE_", "DESC_", "DETACH_", 
      "DISTINCT_", "DROP_", "EACH_", "ELSE_", "END_", "ESCAPE_", "EXCEPT_", 
      "EXCLUSIVE_", "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
      "FROM_", "FULL_", "GLOB_", "GROUP_", "HAVING_", "IF_", "IGNORE_", 
      "IMMEDIATE_", "IN_", "INDEX_", "INDEXED_", "INITIALLY_", "INNER_", 
      "INSERT_", "INSTEAD_", "INTERSECT_", "INTO_", "IS_", "ISNULL_", "JOIN_", 
      "KEY_", "LEFT_", "LIKE_", "LIMIT_", "MATCH_", "NATURAL_", "NO_", "NOT_", 
      "NOTNULL_", "NULL_", "OF_", "OFFSET_", "ON_", "OR_", "ORDER_", "OUTER_", 
      "PLAN_", "PRAGMA_", "PRIMARY_", "QUERY_", "RAISE_", "RECURSIVE_", 
      "REFERENCES_", "REGEXP_", "REINDEX_", "RELEASE_", "RENAME_", "REPLACE_", 
      "RESTRICT_", "RETURNING_", "RIGHT_", "ROLLBACK_", "ROW_", "ROWS_", 
      "SAVEPOINT_", "SELECT_", "SET_", "TABLE_", "TEMP_", "TEMPORARY_", 
      "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", "UNION_", "UNIQUE_", "UPDATE_", 
      "USING_", "VACUUM_", "VALUES_", "VIEW_", "VIRTUAL_", "WHEN_", "WHERE_", 
      "WITH_", "WITHOUT_", "FIRST_VALUE_", "OVER_", "PARTITION_", "RANGE_", 
      "PRECEDING_", "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "CUME_DIST_", 
      "DENSE_RANK_", "LAG_", "LAST_VALUE_", "LEAD_", "NTH_VALUE_", "NTILE_", 
      "PERCENT_RANK_", "RANK_", "ROW_NUMBER_", "GENERATED_", "ALWAYS_", 
      "STORED_", "TRUE_", "FALSE_", "WINDOW_", "NULLS_", "FIRST_", "LAST_", 
      "FILTER_", "GROUPS_", "EXCLUDE_", "TIES_", "OTHERS_", "DO_", "NOTHING_", 
      "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", "STRING_LITERAL", 
      "BLOB_LITERAL", "SINGLE_LINE_COMMENT", "MULTILINE_COMMENT", "SPACES", 
      "UNEXPECTED_CHAR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,193,2062,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,1,0,5,0,228,8,0,10,0,12,0,231,9,0,1,0,1,
  	0,1,1,5,1,236,8,1,10,1,12,1,239,9,1,1,1,1,1,4,1,243,8,1,11,1,12,1,244,
  	1,1,5,1,248,8,1,10,1,12,1,251,9,1,1,1,5,1,254,8,1,10,1,12,1,257,9,1,1,
  	2,1,2,1,2,3,2,262,8,2,3,2,264,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,290,8,
  	2,1,3,1,3,1,3,1,3,1,3,3,3,297,8,3,1,3,1,3,1,3,1,3,1,3,3,3,304,8,3,1,3,
  	1,3,1,3,1,3,3,3,310,8,3,1,3,1,3,3,3,314,8,3,1,3,1,3,1,3,3,3,319,8,3,1,
  	3,3,3,322,8,3,1,4,1,4,1,4,1,4,1,4,3,4,329,8,4,1,4,3,4,332,8,4,1,5,1,5,
  	3,5,336,8,5,1,5,1,5,1,5,1,5,1,6,1,6,3,6,344,8,6,1,6,1,6,3,6,348,8,6,3,
  	6,350,8,6,1,7,1,7,3,7,354,8,7,1,8,1,8,3,8,358,8,8,1,8,1,8,3,8,362,8,8,
  	1,8,3,8,365,8,8,1,9,1,9,1,9,1,10,1,10,3,10,372,8,10,1,10,1,10,1,11,1,
  	11,3,11,378,8,11,1,11,1,11,1,11,1,11,3,11,384,8,11,1,11,1,11,1,11,3,11,
  	389,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,5,11,398,8,11,10,11,12,11,
  	401,9,11,1,11,1,11,1,11,3,11,406,8,11,1,12,1,12,3,12,410,8,12,1,12,1,
  	12,3,12,414,8,12,1,12,3,12,417,8,12,1,13,1,13,3,13,421,8,13,1,13,1,13,
  	1,13,1,13,3,13,427,8,13,1,13,1,13,1,13,3,13,432,8,13,1,13,1,13,1,13,1,
  	13,1,13,5,13,439,8,13,10,13,12,13,442,9,13,1,13,1,13,5,13,446,8,13,10,
  	13,12,13,449,9,13,1,13,1,13,1,13,3,13,454,8,13,1,13,1,13,3,13,458,8,13,
  	1,14,1,14,3,14,462,8,14,1,14,5,14,465,8,14,10,14,12,14,468,9,14,1,15,
  	4,15,471,8,15,11,15,12,15,472,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	1,15,1,15,3,15,485,8,15,1,16,1,16,3,16,489,8,16,1,16,1,16,1,16,3,16,494,
  	8,16,1,16,3,16,497,8,16,1,16,3,16,500,8,16,1,16,3,16,503,8,16,1,16,1,
  	16,3,16,507,8,16,1,16,3,16,510,8,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,3,16,524,8,16,1,16,1,16,1,16,1,16,1,16,3,16,
  	531,8,16,1,16,1,16,1,16,1,16,1,16,3,16,538,8,16,3,16,540,8,16,1,17,3,
  	17,543,8,17,1,17,1,17,1,18,1,18,3,18,549,8,18,1,18,1,18,1,18,3,18,554,
  	8,18,1,18,1,18,1,18,1,18,5,18,560,8,18,10,18,12,18,563,9,18,1,18,1,18,
  	3,18,567,8,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
  	5,18,580,8,18,10,18,12,18,583,9,18,1,18,1,18,1,18,3,18,588,8,18,1,19,
  	1,19,1,19,1,19,1,19,1,19,5,19,596,8,19,10,19,12,19,599,9,19,1,19,1,19,
  	3,19,603,8,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,613,8,19,1,
  	19,1,19,5,19,617,8,19,10,19,12,19,620,9,19,1,19,3,19,623,8,19,1,19,1,
  	19,1,19,3,19,628,8,19,3,19,630,8,19,1,20,1,20,1,20,1,20,1,21,1,21,3,21,
  	638,8,21,1,21,1,21,1,21,1,21,3,21,644,8,21,1,21,1,21,1,21,3,21,649,8,
  	21,1,21,1,21,1,21,1,21,1,21,3,21,656,8,21,1,21,1,21,1,21,1,21,1,21,1,
  	21,1,21,5,21,665,8,21,10,21,12,21,668,9,21,3,21,670,8,21,3,21,672,8,21,
  	1,21,1,21,1,21,1,21,1,21,3,21,679,8,21,1,21,1,21,3,21,683,8,21,1,21,1,
  	21,1,21,1,21,1,21,3,21,690,8,21,1,21,1,21,4,21,694,8,21,11,21,12,21,695,
  	1,21,1,21,1,22,1,22,3,22,702,8,22,1,22,1,22,1,22,1,22,3,22,708,8,22,1,
  	22,1,22,1,22,3,22,713,8,22,1,22,1,22,1,22,1,22,1,22,5,22,720,8,22,10,
  	22,12,22,723,9,22,1,22,1,22,3,22,727,8,22,1,22,1,22,1,22,1,23,1,23,1,
  	23,1,23,1,23,1,23,3,23,738,8,23,1,23,1,23,1,23,3,23,743,8,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,1,23,5,23,752,8,23,10,23,12,23,755,9,23,1,23,1,23,
  	3,23,759,8,23,1,24,1,24,3,24,763,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,
  	24,1,24,1,24,1,24,1,24,1,24,5,24,777,8,24,10,24,12,24,780,9,24,1,25,1,
  	25,1,25,1,25,1,25,5,25,787,8,25,10,25,12,25,790,9,25,1,25,1,25,3,25,794,
  	8,25,1,26,1,26,1,26,1,26,1,26,1,26,3,26,802,8,26,1,26,1,26,1,26,1,27,
  	1,27,1,27,1,27,1,27,5,27,812,8,27,10,27,12,27,815,9,27,1,27,1,27,3,27,
  	819,8,27,1,27,1,27,1,27,1,27,1,27,1,28,3,28,827,8,28,1,28,1,28,1,28,1,
  	28,1,28,3,28,834,8,28,1,28,3,28,837,8,28,1,29,3,29,840,8,29,1,29,1,29,
  	1,29,1,29,1,29,3,29,847,8,29,1,29,3,29,850,8,29,1,29,3,29,853,8,29,1,
  	29,3,29,856,8,29,1,30,1,30,3,30,860,8,30,1,30,1,30,1,31,1,31,1,31,1,31,
  	3,31,868,8,31,1,31,1,31,1,31,3,31,873,8,31,1,31,1,31,1,32,1,32,1,32,1,
  	32,1,32,1,32,3,32,883,8,32,1,32,1,32,1,32,3,32,888,8,32,1,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,3,32,897,8,32,1,32,1,32,1,32,5,32,902,8,32,10,32,
  	12,32,905,9,32,1,32,3,32,908,8,32,1,32,1,32,3,32,912,8,32,1,32,3,32,915,
  	8,32,1,32,1,32,1,32,1,32,5,32,921,8,32,10,32,12,32,924,9,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,936,8,32,1,32,3,32,939,8,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,947,8,32,1,32,1,32,1,32,1,32,1,
  	32,4,32,954,8,32,11,32,12,32,955,1,32,1,32,3,32,960,8,32,1,32,1,32,1,
  	32,3,32,965,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,3,32,992,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,1001,8,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,1013,8,32,1,32,1,
  	32,1,32,3,32,1018,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,3,32,1030,8,32,1,32,1,32,1,32,1,32,3,32,1036,8,32,1,32,1,32,1,32,1,
  	32,1,32,3,32,1043,8,32,1,32,1,32,3,32,1047,8,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,5,32,1055,8,32,10,32,12,32,1058,9,32,3,32,1060,8,32,1,32,1,32,
  	1,32,1,32,3,32,1066,8,32,1,32,1,32,1,32,1,32,3,32,1072,8,32,1,32,1,32,
  	1,32,1,32,1,32,5,32,1079,8,32,10,32,12,32,1082,9,32,3,32,1084,8,32,1,
  	32,1,32,3,32,1088,8,32,5,32,1090,8,32,10,32,12,32,1093,9,32,1,33,1,33,
  	1,33,1,33,1,33,1,33,3,33,1101,8,33,1,33,1,33,1,34,1,34,1,35,1,35,1,35,
  	1,35,5,35,1111,8,35,10,35,12,35,1114,9,35,1,35,1,35,1,36,1,36,1,36,1,
  	36,5,36,1122,8,36,10,36,12,36,1125,9,36,1,37,3,37,1128,8,37,1,37,1,37,
  	1,37,1,37,1,37,3,37,1135,8,37,1,37,1,37,1,37,1,37,3,37,1141,8,37,1,37,
  	1,37,1,37,3,37,1146,8,37,1,37,1,37,1,37,1,37,5,37,1152,8,37,10,37,12,
  	37,1155,9,37,1,37,1,37,3,37,1159,8,37,1,37,1,37,3,37,1163,8,37,1,37,3,
  	37,1166,8,37,1,37,1,37,3,37,1170,8,37,1,37,3,37,1173,8,37,1,38,1,38,1,
  	38,1,38,5,38,1179,8,38,10,38,12,38,1182,9,38,1,39,1,39,1,39,1,39,1,39,
  	1,39,5,39,1190,8,39,10,39,12,39,1193,9,39,1,39,1,39,1,39,3,39,1198,8,
  	39,3,39,1200,8,39,1,39,1,39,1,39,1,39,1,39,1,39,3,39,1208,8,39,1,39,1,
  	39,1,39,1,39,1,39,3,39,1215,8,39,1,39,1,39,1,39,5,39,1220,8,39,10,39,
  	12,39,1223,9,39,1,39,1,39,3,39,1227,8,39,3,39,1229,8,39,1,40,1,40,1,40,
  	1,40,3,40,1235,8,40,1,40,1,40,1,40,1,40,1,40,1,40,1,40,3,40,1244,8,40,
  	1,41,1,41,1,41,3,41,1249,8,41,1,42,1,42,1,42,1,42,1,42,3,42,1256,8,42,
  	1,42,1,42,3,42,1260,8,42,3,42,1262,8,42,1,43,3,43,1265,8,43,1,43,1,43,
  	1,43,1,43,5,43,1271,8,43,10,43,12,43,1274,9,43,1,43,3,43,1277,8,43,1,
  	43,3,43,1280,8,43,1,44,1,44,1,44,1,44,3,44,1286,8,44,5,44,1288,8,44,10,
  	44,12,44,1291,9,44,1,45,1,45,3,45,1295,8,45,1,45,1,45,1,45,5,45,1300,
  	8,45,10,45,12,45,1303,9,45,1,45,1,45,1,45,1,45,5,45,1309,8,45,10,45,12,
  	45,1312,9,45,1,45,3,45,1315,8,45,3,45,1317,8,45,1,45,1,45,3,45,1321,8,
  	45,1,45,1,45,1,45,1,45,1,45,5,45,1328,8,45,10,45,12,45,1331,9,45,1,45,
  	1,45,3,45,1335,8,45,3,45,1337,8,45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,
  	1,45,1,45,5,45,1348,8,45,10,45,12,45,1351,9,45,3,45,1353,8,45,1,45,3,
  	45,1356,8,45,1,46,1,46,1,47,3,47,1361,8,47,1,47,1,47,3,47,1365,8,47,1,
  	47,3,47,1368,8,47,1,48,3,48,1371,8,48,1,48,1,48,1,48,3,48,1376,8,48,1,
  	48,1,48,3,48,1380,8,48,1,48,4,48,1383,8,48,11,48,12,48,1384,1,48,3,48,
  	1388,8,48,1,48,3,48,1391,8,48,1,49,1,49,1,49,3,49,1396,8,49,1,49,1,49,
  	3,49,1400,8,49,1,49,3,49,1403,8,49,1,49,1,49,1,49,1,49,1,49,3,49,1410,
  	8,49,1,49,1,49,1,49,3,49,1415,8,49,1,49,1,49,1,49,1,49,1,49,5,49,1422,
  	8,49,10,49,12,49,1425,9,49,1,49,1,49,3,49,1429,8,49,1,49,3,49,1432,8,
  	49,1,49,1,49,1,49,1,49,5,49,1438,8,49,10,49,12,49,1441,9,49,1,49,3,49,
  	1444,8,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,1452,8,49,1,49,3,49,1455,
  	8,49,3,49,1457,8,49,1,50,1,50,1,50,1,50,1,50,1,50,1,50,3,50,1466,8,50,
  	1,50,3,50,1469,8,50,3,50,1471,8,50,1,51,1,51,3,51,1475,8,51,1,51,1,51,
  	3,51,1479,8,51,1,51,1,51,3,51,1483,8,51,1,51,3,51,1486,8,51,1,52,1,52,
  	1,52,1,52,1,52,1,52,1,52,5,52,1495,8,52,10,52,12,52,1498,9,52,1,52,1,
  	52,3,52,1502,8,52,1,53,1,53,3,53,1506,8,53,1,53,1,53,3,53,1510,8,53,1,
  	54,3,54,1513,8,54,1,54,1,54,1,54,3,54,1518,8,54,1,54,1,54,1,54,1,54,3,
  	54,1524,8,54,1,54,1,54,1,54,1,54,1,54,3,54,1531,8,54,1,54,1,54,1,54,5,
  	54,1536,8,54,10,54,12,54,1539,9,54,1,54,1,54,1,54,1,54,5,54,1545,8,54,
  	10,54,12,54,1548,9,54,1,54,3,54,1551,8,54,3,54,1553,8,54,1,54,1,54,3,
  	54,1557,8,54,1,54,3,54,1560,8,54,1,55,1,55,1,55,1,55,5,55,1566,8,55,10,
  	55,12,55,1569,9,55,1,55,1,55,1,56,3,56,1574,8,56,1,56,1,56,1,56,3,56,
  	1579,8,56,1,56,1,56,1,56,1,56,3,56,1585,8,56,1,56,1,56,1,56,1,56,1,56,
  	3,56,1592,8,56,1,56,1,56,1,56,5,56,1597,8,56,10,56,12,56,1600,9,56,1,
  	56,1,56,3,56,1604,8,56,1,56,3,56,1607,8,56,1,56,3,56,1610,8,56,1,56,3,
  	56,1613,8,56,1,57,1,57,1,57,3,57,1618,8,57,1,57,1,57,1,57,3,57,1623,8,
  	57,1,57,1,57,1,57,1,57,1,57,3,57,1630,8,57,1,58,1,58,3,58,1634,8,58,1,
  	58,1,58,3,58,1638,8,58,1,59,1,59,1,59,1,59,1,59,1,59,1,60,1,60,3,60,1648,
  	8,60,1,60,1,60,1,60,1,60,1,60,5,60,1655,8,60,10,60,12,60,1658,9,60,3,
  	60,1660,8,60,1,60,1,60,1,60,1,60,1,60,5,60,1667,8,60,10,60,12,60,1670,
  	9,60,1,60,3,60,1673,8,60,1,60,1,60,1,61,1,61,1,61,1,61,3,61,1681,8,61,
  	1,61,1,61,1,61,1,61,1,61,5,61,1688,8,61,10,61,12,61,1691,9,61,3,61,1693,
  	8,61,1,61,1,61,1,61,1,61,1,61,5,61,1700,8,61,10,61,12,61,1703,9,61,3,
  	61,1705,8,61,1,61,3,61,1708,8,61,1,61,3,61,1711,8,61,1,62,1,62,1,62,1,
  	62,1,62,1,62,1,62,1,62,3,62,1721,8,62,3,62,1723,8,62,1,63,1,63,1,63,1,
  	63,1,63,1,63,1,63,3,63,1732,8,63,1,64,1,64,1,64,1,64,1,64,5,64,1739,8,
  	64,10,64,12,64,1742,9,64,1,64,3,64,1745,8,64,1,64,1,64,1,65,1,65,1,65,
  	3,65,1752,8,65,1,65,1,65,1,65,5,65,1757,8,65,10,65,12,65,1760,9,65,1,
  	65,3,65,1763,8,65,1,65,1,65,3,65,1767,8,65,1,66,1,66,1,66,1,66,1,66,5,
  	66,1774,8,66,10,66,12,66,1777,9,66,1,66,3,66,1780,8,66,1,66,1,66,3,66,
  	1784,8,66,1,66,1,66,1,66,3,66,1789,8,66,1,67,1,67,3,67,1793,8,67,1,67,
  	1,67,1,67,5,67,1798,8,67,10,67,12,67,1801,9,67,1,68,1,68,1,68,1,68,1,
  	68,5,68,1808,8,68,10,68,12,68,1811,9,68,1,69,1,69,1,69,1,69,3,69,1817,
  	8,69,1,70,1,70,1,70,3,70,1822,8,70,1,70,3,70,1825,8,70,1,70,1,70,3,70,
  	1829,8,70,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,1,72,
  	3,72,1843,8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,1,73,3,73,
  	1855,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,1864,8,74,1,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,3,75,1873,8,75,1,75,1,75,3,75,1877,8,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1887,8,75,1,75,3,75,1890,8,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1899,8,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,3,75,1908,8,75,1,75,3,75,1911,8,75,1,75,1,75,1,75,1,75,
  	3,75,1917,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,3,75,1931,8,75,1,75,1,75,3,75,1935,8,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,3,75,1946,8,75,1,75,1,75,1,75,3,75,1951,8,75,1,76,
  	1,76,1,76,1,77,1,77,1,77,1,78,1,78,1,78,4,78,1962,8,78,11,78,12,78,1963,
  	1,79,1,79,1,79,4,79,1969,8,79,11,79,12,79,1970,1,80,1,80,1,80,1,80,1,
  	81,1,81,3,81,1979,8,81,1,81,1,81,1,81,3,81,1984,8,81,5,81,1986,8,81,10,
  	81,12,81,1989,9,81,1,82,1,82,1,83,1,83,1,84,1,84,1,85,1,85,1,86,1,86,
  	3,86,2001,8,86,1,87,1,87,1,88,1,88,1,89,1,89,1,90,1,90,1,91,1,91,1,92,
  	1,92,1,93,1,93,1,94,1,94,1,95,1,95,1,96,1,96,1,97,1,97,1,98,1,98,1,99,
  	1,99,1,100,1,100,1,101,1,101,1,102,1,102,1,103,1,103,1,104,1,104,1,105,
  	1,105,1,106,1,106,1,107,1,107,1,108,1,108,1,109,1,109,1,110,1,110,1,111,
  	1,111,1,112,1,112,1,112,1,112,1,112,1,112,1,112,3,112,2060,8,112,1,112,
  	2,440,472,1,64,113,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
  	38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,
  	84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,
  	124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,
  	160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,
  	196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,0,29,3,0,
  	58,58,69,69,82,82,2,0,47,47,66,66,1,0,133,134,2,0,146,146,171,171,1,0,
  	8,9,2,0,59,59,141,141,2,0,56,56,104,104,2,0,58,58,82,82,5,0,25,25,72,
  	72,81,81,122,122,126,126,4,0,84,84,132,132,138,138,145,145,2,0,7,7,12,
  	13,1,0,14,17,1,0,18,21,4,0,77,77,97,97,99,99,118,118,3,0,25,25,72,72,
  	126,126,5,0,52,54,104,104,172,173,186,186,188,189,2,0,29,29,62,62,3,0,
  	76,76,96,96,125,125,3,0,128,128,154,154,179,179,2,0,5,5,106,106,1,0,176,
  	177,2,0,34,34,60,60,2,0,151,151,162,162,2,0,159,159,166,166,2,0,160,160,
  	167,168,2,0,161,161,163,163,2,0,8,10,102,102,2,0,185,185,188,188,2,0,
  	25,123,125,180,2346,0,229,1,0,0,0,2,237,1,0,0,0,4,263,1,0,0,0,6,291,1,
  	0,0,0,8,323,1,0,0,0,10,333,1,0,0,0,12,341,1,0,0,0,14,351,1,0,0,0,16,355,
  	1,0,0,0,18,366,1,0,0,0,20,369,1,0,0,0,22,375,1,0,0,0,24,409,1,0,0,0,26,
  	418,1,0,0,0,28,459,1,0,0,0,30,470,1,0,0,0,32,488,1,0,0,0,34,542,1,0,0,
  	0,36,548,1,0,0,0,38,589,1,0,0,0,40,631,1,0,0,0,42,635,1,0,0,0,44,699,
  	1,0,0,0,46,731,1,0,0,0,48,760,1,0,0,0,50,781,1,0,0,0,52,795,1,0,0,0,54,
  	806,1,0,0,0,56,826,1,0,0,0,58,839,1,0,0,0,60,857,1,0,0,0,62,863,1,0,0,
  	0,64,964,1,0,0,0,66,1094,1,0,0,0,68,1104,1,0,0,0,70,1106,1,0,0,0,72,1117,
  	1,0,0,0,74,1127,1,0,0,0,76,1174,1,0,0,0,78,1183,1,0,0,0,80,1230,1,0,0,
  	0,82,1248,1,0,0,0,84,1250,1,0,0,0,86,1264,1,0,0,0,88,1281,1,0,0,0,90,
  	1355,1,0,0,0,92,1357,1,0,0,0,94,1360,1,0,0,0,96,1370,1,0,0,0,98,1456,
  	1,0,0,0,100,1470,1,0,0,0,102,1485,1,0,0,0,104,1501,1,0,0,0,106,1509,1,
  	0,0,0,108,1512,1,0,0,0,110,1561,1,0,0,0,112,1573,1,0,0,0,114,1617,1,0,
  	0,0,116,1631,1,0,0,0,118,1639,1,0,0,0,120,1645,1,0,0,0,122,1676,1,0,0,
  	0,124,1712,1,0,0,0,126,1724,1,0,0,0,128,1733,1,0,0,0,130,1748,1,0,0,0,
  	132,1768,1,0,0,0,134,1790,1,0,0,0,136,1802,1,0,0,0,138,1812,1,0,0,0,140,
  	1818,1,0,0,0,142,1830,1,0,0,0,144,1842,1,0,0,0,146,1854,1,0,0,0,148,1863,
  	1,0,0,0,150,1950,1,0,0,0,152,1952,1,0,0,0,154,1955,1,0,0,0,156,1958,1,
  	0,0,0,158,1965,1,0,0,0,160,1972,1,0,0,0,162,1976,1,0,0,0,164,1990,1,0,
  	0,0,166,1992,1,0,0,0,168,1994,1,0,0,0,170,1996,1,0,0,0,172,2000,1,0,0,
  	0,174,2002,1,0,0,0,176,2004,1,0,0,0,178,2006,1,0,0,0,180,2008,1,0,0,0,
  	182,2010,1,0,0,0,184,2012,1,0,0,0,186,2014,1,0,0,0,188,2016,1,0,0,0,190,
  	2018,1,0,0,0,192,2020,1,0,0,0,194,2022,1,0,0,0,196,2024,1,0,0,0,198,2026,
  	1,0,0,0,200,2028,1,0,0,0,202,2030,1,0,0,0,204,2032,1,0,0,0,206,2034,1,
  	0,0,0,208,2036,1,0,0,0,210,2038,1,0,0,0,212,2040,1,0,0,0,214,2042,1,0,
  	0,0,216,2044,1,0,0,0,218,2046,1,0,0,0,220,2048,1,0,0,0,222,2050,1,0,0,
  	0,224,2059,1,0,0,0,226,228,3,2,1,0,227,226,1,0,0,0,228,231,1,0,0,0,229,
  	227,1,0,0,0,229,230,1,0,0,0,230,232,1,0,0,0,231,229,1,0,0,0,232,233,5,
  	0,0,1,233,1,1,0,0,0,234,236,5,1,0,0,235,234,1,0,0,0,236,239,1,0,0,0,237,
  	235,1,0,0,0,237,238,1,0,0,0,238,240,1,0,0,0,239,237,1,0,0,0,240,249,3,
  	4,2,0,241,243,5,1,0,0,242,241,1,0,0,0,243,244,1,0,0,0,244,242,1,0,0,0,
  	244,245,1,0,0,0,245,246,1,0,0,0,246,248,3,4,2,0,247,242,1,0,0,0,248,251,
  	1,0,0,0,249,247,1,0,0,0,249,250,1,0,0,0,250,255,1,0,0,0,251,249,1,0,0,
  	0,252,254,5,1,0,0,253,252,1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,255,
  	256,1,0,0,0,256,3,1,0,0,0,257,255,1,0,0,0,258,261,5,71,0,0,259,260,5,
  	114,0,0,260,262,5,111,0,0,261,259,1,0,0,0,261,262,1,0,0,0,262,264,1,0,
  	0,0,263,258,1,0,0,0,263,264,1,0,0,0,264,289,1,0,0,0,265,290,3,6,3,0,266,
  	290,3,8,4,0,267,290,3,10,5,0,268,290,3,12,6,0,269,290,3,14,7,0,270,290,
  	3,22,11,0,271,290,3,26,13,0,272,290,3,42,21,0,273,290,3,44,22,0,274,290,
  	3,46,23,0,275,290,3,56,28,0,276,290,3,58,29,0,277,290,3,60,30,0,278,290,
  	3,62,31,0,279,290,3,74,37,0,280,290,3,80,40,0,281,290,3,84,42,0,282,290,
  	3,20,10,0,283,290,3,16,8,0,284,290,3,18,9,0,285,290,3,86,43,0,286,290,
  	3,108,54,0,287,290,3,112,56,0,288,290,3,116,58,0,289,265,1,0,0,0,289,
  	266,1,0,0,0,289,267,1,0,0,0,289,268,1,0,0,0,289,269,1,0,0,0,289,270,1,
  	0,0,0,289,271,1,0,0,0,289,272,1,0,0,0,289,273,1,0,0,0,289,274,1,0,0,0,
  	289,275,1,0,0,0,289,276,1,0,0,0,289,277,1,0,0,0,289,278,1,0,0,0,289,279,
  	1,0,0,0,289,280,1,0,0,0,289,281,1,0,0,0,289,282,1,0,0,0,289,283,1,0,0,
  	0,289,284,1,0,0,0,289,285,1,0,0,0,289,286,1,0,0,0,289,287,1,0,0,0,289,
  	288,1,0,0,0,290,5,1,0,0,0,291,292,5,30,0,0,292,296,5,132,0,0,293,294,
  	3,182,91,0,294,295,5,2,0,0,295,297,1,0,0,0,296,293,1,0,0,0,296,297,1,
  	0,0,0,297,298,1,0,0,0,298,321,3,184,92,0,299,309,5,121,0,0,300,301,5,
  	136,0,0,301,310,3,184,92,0,302,304,5,46,0,0,303,302,1,0,0,0,303,304,1,
  	0,0,0,304,305,1,0,0,0,305,306,3,188,94,0,306,307,5,136,0,0,307,308,3,
  	188,94,0,308,310,1,0,0,0,309,300,1,0,0,0,309,303,1,0,0,0,310,322,1,0,
  	0,0,311,313,5,27,0,0,312,314,5,46,0,0,313,312,1,0,0,0,313,314,1,0,0,0,
  	314,315,1,0,0,0,315,322,3,28,14,0,316,318,5,63,0,0,317,319,5,46,0,0,318,
  	317,1,0,0,0,318,319,1,0,0,0,319,320,1,0,0,0,320,322,3,188,94,0,321,299,
  	1,0,0,0,321,311,1,0,0,0,321,316,1,0,0,0,322,7,1,0,0,0,323,331,5,31,0,
  	0,324,332,3,182,91,0,325,326,3,182,91,0,326,327,5,2,0,0,327,329,1,0,0,
  	0,328,325,1,0,0,0,328,329,1,0,0,0,329,330,1,0,0,0,330,332,3,186,93,0,
  	331,324,1,0,0,0,331,328,1,0,0,0,331,332,1,0,0,0,332,9,1,0,0,0,333,335,
  	5,35,0,0,334,336,5,55,0,0,335,334,1,0,0,0,335,336,1,0,0,0,336,337,1,0,
  	0,0,337,338,3,64,32,0,338,339,5,33,0,0,339,340,3,182,91,0,340,11,1,0,
  	0,0,341,343,5,38,0,0,342,344,7,0,0,0,343,342,1,0,0,0,343,344,1,0,0,0,
  	344,349,1,0,0,0,345,347,5,137,0,0,346,348,3,208,104,0,347,346,1,0,0,0,
  	347,348,1,0,0,0,348,350,1,0,0,0,349,345,1,0,0,0,349,350,1,0,0,0,350,13,
  	1,0,0,0,351,353,7,1,0,0,352,354,5,137,0,0,353,352,1,0,0,0,353,354,1,0,
  	0,0,354,15,1,0,0,0,355,357,5,126,0,0,356,358,5,137,0,0,357,356,1,0,0,
  	0,357,358,1,0,0,0,358,364,1,0,0,0,359,361,5,136,0,0,360,362,5,129,0,0,
  	361,360,1,0,0,0,361,362,1,0,0,0,362,363,1,0,0,0,363,365,3,204,102,0,364,
  	359,1,0,0,0,364,365,1,0,0,0,365,17,1,0,0,0,366,367,5,129,0,0,367,368,
  	3,204,102,0,368,19,1,0,0,0,369,371,5,120,0,0,370,372,5,129,0,0,371,370,
  	1,0,0,0,371,372,1,0,0,0,372,373,1,0,0,0,373,374,3,204,102,0,374,21,1,
  	0,0,0,375,377,5,50,0,0,376,378,5,140,0,0,377,376,1,0,0,0,377,378,1,0,
  	0,0,378,379,1,0,0,0,379,383,5,84,0,0,380,381,5,80,0,0,381,382,5,102,0,
  	0,382,384,5,70,0,0,383,380,1,0,0,0,383,384,1,0,0,0,384,388,1,0,0,0,385,
  	386,3,182,91,0,386,387,5,2,0,0,387,389,1,0,0,0,388,385,1,0,0,0,388,389,
  	1,0,0,0,389,390,1,0,0,0,390,391,3,194,97,0,391,392,5,107,0,0,392,393,
  	3,184,92,0,393,394,5,3,0,0,394,399,3,24,12,0,395,396,5,5,0,0,396,398,
  	3,24,12,0,397,395,1,0,0,0,398,401,1,0,0,0,399,397,1,0,0,0,399,400,1,0,
  	0,0,400,402,1,0,0,0,401,399,1,0,0,0,402,405,5,4,0,0,403,404,5,148,0,0,
  	404,406,3,64,32,0,405,403,1,0,0,0,405,406,1,0,0,0,406,23,1,0,0,0,407,
  	410,3,188,94,0,408,410,3,64,32,0,409,407,1,0,0,0,409,408,1,0,0,0,410,
  	413,1,0,0,0,411,412,5,45,0,0,412,414,3,190,95,0,413,411,1,0,0,0,413,414,
  	1,0,0,0,414,416,1,0,0,0,415,417,3,142,71,0,416,415,1,0,0,0,416,417,1,
  	0,0,0,417,25,1,0,0,0,418,420,5,50,0,0,419,421,7,2,0,0,420,419,1,0,0,0,
  	420,421,1,0,0,0,421,422,1,0,0,0,422,426,5,132,0,0,423,424,5,80,0,0,424,
  	425,5,102,0,0,425,427,5,70,0,0,426,423,1,0,0,0,426,427,1,0,0,0,427,431,
  	1,0,0,0,428,429,3,182,91,0,429,430,5,2,0,0,430,432,1,0,0,0,431,428,1,
  	0,0,0,431,432,1,0,0,0,432,433,1,0,0,0,433,457,3,184,92,0,434,435,5,3,
  	0,0,435,440,3,28,14,0,436,437,5,5,0,0,437,439,3,28,14,0,438,436,1,0,0,
  	0,439,442,1,0,0,0,440,441,1,0,0,0,440,438,1,0,0,0,441,447,1,0,0,0,442,
  	440,1,0,0,0,443,444,5,5,0,0,444,446,3,36,18,0,445,443,1,0,0,0,446,449,
  	1,0,0,0,447,445,1,0,0,0,447,448,1,0,0,0,448,450,1,0,0,0,449,447,1,0,0,
  	0,450,453,5,4,0,0,451,452,5,150,0,0,452,454,5,185,0,0,453,451,1,0,0,0,
  	453,454,1,0,0,0,454,458,1,0,0,0,455,456,5,33,0,0,456,458,3,86,43,0,457,
  	434,1,0,0,0,457,455,1,0,0,0,458,27,1,0,0,0,459,461,3,188,94,0,460,462,
  	3,30,15,0,461,460,1,0,0,0,461,462,1,0,0,0,462,466,1,0,0,0,463,465,3,32,
  	16,0,464,463,1,0,0,0,465,468,1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,
  	467,29,1,0,0,0,468,466,1,0,0,0,469,471,3,178,89,0,470,469,1,0,0,0,471,
  	472,1,0,0,0,472,473,1,0,0,0,472,470,1,0,0,0,473,484,1,0,0,0,474,475,5,
  	3,0,0,475,476,3,34,17,0,476,477,5,4,0,0,477,485,1,0,0,0,478,479,5,3,0,
  	0,479,480,3,34,17,0,480,481,5,5,0,0,481,482,3,34,17,0,482,483,5,4,0,0,
  	483,485,1,0,0,0,484,474,1,0,0,0,484,478,1,0,0,0,484,485,1,0,0,0,485,31,
  	1,0,0,0,486,487,5,49,0,0,487,489,3,178,89,0,488,486,1,0,0,0,488,489,1,
  	0,0,0,489,539,1,0,0,0,490,491,5,113,0,0,491,493,5,95,0,0,492,494,3,142,
  	71,0,493,492,1,0,0,0,493,494,1,0,0,0,494,496,1,0,0,0,495,497,3,40,20,
  	0,496,495,1,0,0,0,496,497,1,0,0,0,497,499,1,0,0,0,498,500,5,36,0,0,499,
  	498,1,0,0,0,499,500,1,0,0,0,500,540,1,0,0,0,501,503,5,102,0,0,502,501,
  	1,0,0,0,502,503,1,0,0,0,503,504,1,0,0,0,504,507,5,104,0,0,505,507,5,140,
  	0,0,506,502,1,0,0,0,506,505,1,0,0,0,507,509,1,0,0,0,508,510,3,40,20,0,
  	509,508,1,0,0,0,509,510,1,0,0,0,510,540,1,0,0,0,511,512,5,44,0,0,512,
  	513,5,3,0,0,513,514,3,64,32,0,514,515,5,4,0,0,515,540,1,0,0,0,516,523,
  	5,56,0,0,517,524,3,34,17,0,518,524,3,68,34,0,519,520,5,3,0,0,520,521,
  	3,64,32,0,521,522,5,4,0,0,522,524,1,0,0,0,523,517,1,0,0,0,523,518,1,0,
  	0,0,523,519,1,0,0,0,524,540,1,0,0,0,525,526,5,45,0,0,526,540,3,190,95,
  	0,527,540,3,38,19,0,528,529,5,169,0,0,529,531,5,170,0,0,530,528,1,0,0,
  	0,530,531,1,0,0,0,531,532,1,0,0,0,532,533,5,33,0,0,533,534,5,3,0,0,534,
  	535,3,64,32,0,535,537,5,4,0,0,536,538,7,3,0,0,537,536,1,0,0,0,537,538,
  	1,0,0,0,538,540,1,0,0,0,539,490,1,0,0,0,539,506,1,0,0,0,539,511,1,0,0,
  	0,539,516,1,0,0,0,539,525,1,0,0,0,539,527,1,0,0,0,539,530,1,0,0,0,540,
  	33,1,0,0,0,541,543,7,4,0,0,542,541,1,0,0,0,542,543,1,0,0,0,543,544,1,
  	0,0,0,544,545,5,186,0,0,545,35,1,0,0,0,546,547,5,49,0,0,547,549,3,178,
  	89,0,548,546,1,0,0,0,548,549,1,0,0,0,549,587,1,0,0,0,550,551,5,113,0,
  	0,551,554,5,95,0,0,552,554,5,140,0,0,553,550,1,0,0,0,553,552,1,0,0,0,
  	554,555,1,0,0,0,555,556,5,3,0,0,556,561,3,24,12,0,557,558,5,5,0,0,558,
  	560,3,24,12,0,559,557,1,0,0,0,560,563,1,0,0,0,561,559,1,0,0,0,561,562,
  	1,0,0,0,562,564,1,0,0,0,563,561,1,0,0,0,564,566,5,4,0,0,565,567,3,40,
  	20,0,566,565,1,0,0,0,566,567,1,0,0,0,567,588,1,0,0,0,568,569,5,44,0,0,
  	569,570,5,3,0,0,570,571,3,64,32,0,571,572,5,4,0,0,572,588,1,0,0,0,573,
  	574,5,74,0,0,574,575,5,95,0,0,575,576,5,3,0,0,576,581,3,188,94,0,577,
  	578,5,5,0,0,578,580,3,188,94,0,579,577,1,0,0,0,580,583,1,0,0,0,581,579,
  	1,0,0,0,581,582,1,0,0,0,582,584,1,0,0,0,583,581,1,0,0,0,584,585,5,4,0,
  	0,585,586,3,38,19,0,586,588,1,0,0,0,587,553,1,0,0,0,587,568,1,0,0,0,587,
  	573,1,0,0,0,588,37,1,0,0,0,589,590,5,117,0,0,590,602,3,192,96,0,591,592,
  	5,3,0,0,592,597,3,188,94,0,593,594,5,5,0,0,594,596,3,188,94,0,595,593,
  	1,0,0,0,596,599,1,0,0,0,597,595,1,0,0,0,597,598,1,0,0,0,598,600,1,0,0,
  	0,599,597,1,0,0,0,600,601,5,4,0,0,601,603,1,0,0,0,602,591,1,0,0,0,602,
  	603,1,0,0,0,603,618,1,0,0,0,604,605,5,107,0,0,605,612,7,5,0,0,606,607,
  	5,131,0,0,607,613,7,6,0,0,608,613,5,41,0,0,609,613,5,123,0,0,610,611,
  	5,101,0,0,611,613,5,26,0,0,612,606,1,0,0,0,612,608,1,0,0,0,612,609,1,
  	0,0,0,612,610,1,0,0,0,613,617,1,0,0,0,614,615,5,99,0,0,615,617,3,178,
  	89,0,616,604,1,0,0,0,616,614,1,0,0,0,617,620,1,0,0,0,618,616,1,0,0,0,
  	618,619,1,0,0,0,619,629,1,0,0,0,620,618,1,0,0,0,621,623,5,102,0,0,622,
  	621,1,0,0,0,622,623,1,0,0,0,623,624,1,0,0,0,624,627,5,57,0,0,625,626,
  	5,86,0,0,626,628,7,7,0,0,627,625,1,0,0,0,627,628,1,0,0,0,628,630,1,0,
  	0,0,629,622,1,0,0,0,629,630,1,0,0,0,630,39,1,0,0,0,631,632,5,107,0,0,
  	632,633,5,48,0,0,633,634,7,8,0,0,634,41,1,0,0,0,635,637,5,50,0,0,636,
  	638,7,2,0,0,637,636,1,0,0,0,637,638,1,0,0,0,638,639,1,0,0,0,639,643,5,
  	138,0,0,640,641,5,80,0,0,641,642,5,102,0,0,642,644,5,70,0,0,643,640,1,
  	0,0,0,643,644,1,0,0,0,644,648,1,0,0,0,645,646,3,182,91,0,646,647,5,2,
  	0,0,647,649,1,0,0,0,648,645,1,0,0,0,648,649,1,0,0,0,649,650,1,0,0,0,650,
  	655,3,196,98,0,651,656,5,37,0,0,652,656,5,28,0,0,653,654,5,89,0,0,654,
  	656,5,105,0,0,655,651,1,0,0,0,655,652,1,0,0,0,655,653,1,0,0,0,655,656,
  	1,0,0,0,656,671,1,0,0,0,657,672,5,59,0,0,658,672,5,88,0,0,659,669,5,141,
  	0,0,660,661,5,105,0,0,661,666,3,188,94,0,662,663,5,5,0,0,663,665,3,188,
  	94,0,664,662,1,0,0,0,665,668,1,0,0,0,666,664,1,0,0,0,666,667,1,0,0,0,
  	667,670,1,0,0,0,668,666,1,0,0,0,669,660,1,0,0,0,669,670,1,0,0,0,670,672,
  	1,0,0,0,671,657,1,0,0,0,671,658,1,0,0,0,671,659,1,0,0,0,672,673,1,0,0,
  	0,673,674,5,107,0,0,674,678,3,184,92,0,675,676,5,73,0,0,676,677,5,64,
  	0,0,677,679,5,127,0,0,678,675,1,0,0,0,678,679,1,0,0,0,679,682,1,0,0,0,
  	680,681,5,147,0,0,681,683,3,64,32,0,682,680,1,0,0,0,682,683,1,0,0,0,683,
  	684,1,0,0,0,684,693,5,38,0,0,685,690,3,108,54,0,686,690,3,74,37,0,687,
  	690,3,56,28,0,688,690,3,86,43,0,689,685,1,0,0,0,689,686,1,0,0,0,689,687,
  	1,0,0,0,689,688,1,0,0,0,690,691,1,0,0,0,691,692,5,1,0,0,692,694,1,0,0,
  	0,693,689,1,0,0,0,694,695,1,0,0,0,695,693,1,0,0,0,695,696,1,0,0,0,696,
  	697,1,0,0,0,697,698,5,66,0,0,698,43,1,0,0,0,699,701,5,50,0,0,700,702,
  	7,2,0,0,701,700,1,0,0,0,701,702,1,0,0,0,702,703,1,0,0,0,703,707,5,145,
  	0,0,704,705,5,80,0,0,705,706,5,102,0,0,706,708,5,70,0,0,707,704,1,0,0,
  	0,707,708,1,0,0,0,708,712,1,0,0,0,709,710,3,182,91,0,710,711,5,2,0,0,
  	711,713,1,0,0,0,712,709,1,0,0,0,712,713,1,0,0,0,713,714,1,0,0,0,714,726,
  	3,198,99,0,715,716,5,3,0,0,716,721,3,188,94,0,717,718,5,5,0,0,718,720,
  	3,188,94,0,719,717,1,0,0,0,720,723,1,0,0,0,721,719,1,0,0,0,721,722,1,
  	0,0,0,722,724,1,0,0,0,723,721,1,0,0,0,724,725,5,4,0,0,725,727,1,0,0,0,
  	726,715,1,0,0,0,726,727,1,0,0,0,727,728,1,0,0,0,728,729,5,33,0,0,729,
  	730,3,86,43,0,730,45,1,0,0,0,731,732,5,50,0,0,732,733,5,146,0,0,733,737,
  	5,132,0,0,734,735,5,80,0,0,735,736,5,102,0,0,736,738,5,70,0,0,737,734,
  	1,0,0,0,737,738,1,0,0,0,738,742,1,0,0,0,739,740,3,182,91,0,740,741,5,
  	2,0,0,741,743,1,0,0,0,742,739,1,0,0,0,742,743,1,0,0,0,743,744,1,0,0,0,
  	744,745,3,184,92,0,745,746,5,142,0,0,746,758,3,200,100,0,747,748,5,3,
  	0,0,748,753,3,172,86,0,749,750,5,5,0,0,750,752,3,172,86,0,751,749,1,0,
  	0,0,752,755,1,0,0,0,753,751,1,0,0,0,753,754,1,0,0,0,754,756,1,0,0,0,755,
  	753,1,0,0,0,756,757,5,4,0,0,757,759,1,0,0,0,758,747,1,0,0,0,758,759,1,
  	0,0,0,759,47,1,0,0,0,760,762,5,149,0,0,761,763,5,116,0,0,762,761,1,0,
  	0,0,762,763,1,0,0,0,763,764,1,0,0,0,764,765,3,50,25,0,765,766,5,33,0,
  	0,766,767,5,3,0,0,767,768,3,86,43,0,768,778,5,4,0,0,769,770,5,5,0,0,770,
  	771,3,50,25,0,771,772,5,33,0,0,772,773,5,3,0,0,773,774,3,86,43,0,774,
  	775,5,4,0,0,775,777,1,0,0,0,776,769,1,0,0,0,777,780,1,0,0,0,778,776,1,
  	0,0,0,778,779,1,0,0,0,779,49,1,0,0,0,780,778,1,0,0,0,781,793,3,184,92,
  	0,782,783,5,3,0,0,783,788,3,188,94,0,784,785,5,5,0,0,785,787,3,188,94,
  	0,786,784,1,0,0,0,787,790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,
  	791,1,0,0,0,790,788,1,0,0,0,791,792,5,4,0,0,792,794,1,0,0,0,793,782,1,
  	0,0,0,793,794,1,0,0,0,794,51,1,0,0,0,795,796,3,50,25,0,796,797,5,33,0,
  	0,797,798,5,3,0,0,798,799,3,164,82,0,799,801,5,139,0,0,800,802,5,29,0,
  	0,801,800,1,0,0,0,801,802,1,0,0,0,802,803,1,0,0,0,803,804,3,166,83,0,
  	804,805,5,4,0,0,805,53,1,0,0,0,806,818,3,184,92,0,807,808,5,3,0,0,808,
  	813,3,188,94,0,809,810,5,5,0,0,810,812,3,188,94,0,811,809,1,0,0,0,812,
  	815,1,0,0,0,813,811,1,0,0,0,813,814,1,0,0,0,814,816,1,0,0,0,815,813,1,
  	0,0,0,816,817,5,4,0,0,817,819,1,0,0,0,818,807,1,0,0,0,818,819,1,0,0,0,
  	819,820,1,0,0,0,820,821,5,33,0,0,821,822,5,3,0,0,822,823,3,86,43,0,823,
  	824,5,4,0,0,824,55,1,0,0,0,825,827,3,48,24,0,826,825,1,0,0,0,826,827,
  	1,0,0,0,827,828,1,0,0,0,828,829,5,59,0,0,829,830,5,75,0,0,830,833,3,114,
  	57,0,831,832,5,148,0,0,832,834,3,64,32,0,833,831,1,0,0,0,833,834,1,0,
  	0,0,834,836,1,0,0,0,835,837,3,76,38,0,836,835,1,0,0,0,836,837,1,0,0,0,
  	837,57,1,0,0,0,838,840,3,48,24,0,839,838,1,0,0,0,839,840,1,0,0,0,840,
  	841,1,0,0,0,841,842,5,59,0,0,842,843,5,75,0,0,843,846,3,114,57,0,844,
  	845,5,148,0,0,845,847,3,64,32,0,846,844,1,0,0,0,846,847,1,0,0,0,847,849,
  	1,0,0,0,848,850,3,76,38,0,849,848,1,0,0,0,849,850,1,0,0,0,850,855,1,0,
  	0,0,851,853,3,136,68,0,852,851,1,0,0,0,852,853,1,0,0,0,853,854,1,0,0,
  	0,854,856,3,138,69,0,855,852,1,0,0,0,855,856,1,0,0,0,856,59,1,0,0,0,857,
  	859,5,61,0,0,858,860,5,55,0,0,859,858,1,0,0,0,859,860,1,0,0,0,860,861,
  	1,0,0,0,861,862,3,182,91,0,862,61,1,0,0,0,863,864,5,63,0,0,864,867,7,
  	9,0,0,865,866,5,80,0,0,866,868,5,70,0,0,867,865,1,0,0,0,867,868,1,0,0,
  	0,868,872,1,0,0,0,869,870,3,182,91,0,870,871,5,2,0,0,871,873,1,0,0,0,
  	872,869,1,0,0,0,872,873,1,0,0,0,873,874,1,0,0,0,874,875,3,224,112,0,875,
  	63,1,0,0,0,876,877,6,32,-1,0,877,965,3,68,34,0,878,965,5,187,0,0,879,
  	880,3,182,91,0,880,881,5,2,0,0,881,883,1,0,0,0,882,879,1,0,0,0,882,883,
  	1,0,0,0,883,884,1,0,0,0,884,885,3,184,92,0,885,886,5,2,0,0,886,888,1,
  	0,0,0,887,882,1,0,0,0,887,888,1,0,0,0,888,889,1,0,0,0,889,965,3,188,94,
  	0,890,891,3,168,84,0,891,892,3,64,32,21,892,965,1,0,0,0,893,894,3,180,
  	90,0,894,907,5,3,0,0,895,897,5,62,0,0,896,895,1,0,0,0,896,897,1,0,0,0,
  	897,898,1,0,0,0,898,903,3,64,32,0,899,900,5,5,0,0,900,902,3,64,32,0,901,
  	899,1,0,0,0,902,905,1,0,0,0,903,901,1,0,0,0,903,904,1,0,0,0,904,908,1,
  	0,0,0,905,903,1,0,0,0,906,908,5,7,0,0,907,896,1,0,0,0,907,906,1,0,0,0,
  	907,908,1,0,0,0,908,909,1,0,0,0,909,911,5,4,0,0,910,912,3,118,59,0,911,
  	910,1,0,0,0,911,912,1,0,0,0,912,914,1,0,0,0,913,915,3,122,61,0,914,913,
  	1,0,0,0,914,915,1,0,0,0,915,965,1,0,0,0,916,917,5,3,0,0,917,922,3,64,
  	32,0,918,919,5,5,0,0,919,921,3,64,32,0,920,918,1,0,0,0,921,924,1,0,0,
  	0,922,920,1,0,0,0,922,923,1,0,0,0,923,925,1,0,0,0,924,922,1,0,0,0,925,
  	926,5,4,0,0,926,965,1,0,0,0,927,928,5,43,0,0,928,929,5,3,0,0,929,930,
  	3,64,32,0,930,931,5,33,0,0,931,932,3,30,15,0,932,933,5,4,0,0,933,965,
  	1,0,0,0,934,936,5,102,0,0,935,934,1,0,0,0,935,936,1,0,0,0,936,937,1,0,
  	0,0,937,939,5,70,0,0,938,935,1,0,0,0,938,939,1,0,0,0,939,940,1,0,0,0,
  	940,941,5,3,0,0,941,942,3,86,43,0,942,943,5,4,0,0,943,965,1,0,0,0,944,
  	946,5,42,0,0,945,947,3,64,32,0,946,945,1,0,0,0,946,947,1,0,0,0,947,953,
  	1,0,0,0,948,949,5,147,0,0,949,950,3,64,32,0,950,951,5,135,0,0,951,952,
  	3,64,32,0,952,954,1,0,0,0,953,948,1,0,0,0,954,955,1,0,0,0,955,953,1,0,
  	0,0,955,956,1,0,0,0,956,959,1,0,0,0,957,958,5,65,0,0,958,960,3,64,32,
  	0,959,957,1,0,0,0,959,960,1,0,0,0,960,961,1,0,0,0,961,962,5,66,0,0,962,
  	965,1,0,0,0,963,965,3,66,33,0,964,876,1,0,0,0,964,878,1,0,0,0,964,887,
  	1,0,0,0,964,890,1,0,0,0,964,893,1,0,0,0,964,916,1,0,0,0,964,927,1,0,0,
  	0,964,938,1,0,0,0,964,944,1,0,0,0,964,963,1,0,0,0,965,1091,1,0,0,0,966,
  	967,10,20,0,0,967,968,5,11,0,0,968,1090,3,64,32,21,969,970,10,19,0,0,
  	970,971,7,10,0,0,971,1090,3,64,32,20,972,973,10,18,0,0,973,974,7,4,0,
  	0,974,1090,3,64,32,19,975,976,10,17,0,0,976,977,7,11,0,0,977,1090,3,64,
  	32,18,978,979,10,16,0,0,979,980,7,12,0,0,980,1090,3,64,32,17,981,1000,
  	10,15,0,0,982,1001,5,6,0,0,983,1001,5,22,0,0,984,1001,5,23,0,0,985,1001,
  	5,24,0,0,986,1001,5,92,0,0,987,988,5,92,0,0,988,1001,5,102,0,0,989,991,
  	5,92,0,0,990,992,5,102,0,0,991,990,1,0,0,0,991,992,1,0,0,0,992,993,1,
  	0,0,0,993,994,5,62,0,0,994,1001,5,75,0,0,995,1001,5,83,0,0,996,1001,5,
  	97,0,0,997,1001,5,77,0,0,998,1001,5,99,0,0,999,1001,5,118,0,0,1000,982,
  	1,0,0,0,1000,983,1,0,0,0,1000,984,1,0,0,0,1000,985,1,0,0,0,1000,986,1,
  	0,0,0,1000,987,1,0,0,0,1000,989,1,0,0,0,1000,995,1,0,0,0,1000,996,1,0,
  	0,0,1000,997,1,0,0,0,1000,998,1,0,0,0,1000,999,1,0,0,0,1001,1002,1,0,
  	0,0,1002,1090,3,64,32,16,1003,1004,10,14,0,0,1004,1005,5,32,0,0,1005,
  	1090,3,64,32,15,1006,1007,10,13,0,0,1007,1008,5,108,0,0,1008,1090,3,64,
  	32,14,1009,1010,10,6,0,0,1010,1012,5,92,0,0,1011,1013,5,102,0,0,1012,
  	1011,1,0,0,0,1012,1013,1,0,0,0,1013,1014,1,0,0,0,1014,1090,3,64,32,7,
  	1015,1017,10,5,0,0,1016,1018,5,102,0,0,1017,1016,1,0,0,0,1017,1018,1,
  	0,0,0,1018,1019,1,0,0,0,1019,1020,5,39,0,0,1020,1021,3,64,32,0,1021,1022,
  	5,32,0,0,1022,1023,3,64,32,6,1023,1090,1,0,0,0,1024,1025,10,9,0,0,1025,
  	1026,5,45,0,0,1026,1090,3,190,95,0,1027,1029,10,8,0,0,1028,1030,5,102,
  	0,0,1029,1028,1,0,0,0,1029,1030,1,0,0,0,1030,1031,1,0,0,0,1031,1032,7,
  	13,0,0,1032,1035,3,64,32,0,1033,1034,5,67,0,0,1034,1036,3,64,32,0,1035,
  	1033,1,0,0,0,1035,1036,1,0,0,0,1036,1090,1,0,0,0,1037,1042,10,7,0,0,1038,
  	1043,5,93,0,0,1039,1043,5,103,0,0,1040,1041,5,102,0,0,1041,1043,5,104,
  	0,0,1042,1038,1,0,0,0,1042,1039,1,0,0,0,1042,1040,1,0,0,0,1043,1090,1,
  	0,0,0,1044,1046,10,4,0,0,1045,1047,5,102,0,0,1046,1045,1,0,0,0,1046,1047,
  	1,0,0,0,1047,1048,1,0,0,0,1048,1087,5,83,0,0,1049,1059,5,3,0,0,1050,1060,
  	3,86,43,0,1051,1056,3,64,32,0,1052,1053,5,5,0,0,1053,1055,3,64,32,0,1054,
  	1052,1,0,0,0,1055,1058,1,0,0,0,1056,1054,1,0,0,0,1056,1057,1,0,0,0,1057,
  	1060,1,0,0,0,1058,1056,1,0,0,0,1059,1050,1,0,0,0,1059,1051,1,0,0,0,1059,
  	1060,1,0,0,0,1060,1061,1,0,0,0,1061,1088,5,4,0,0,1062,1063,3,182,91,0,
  	1063,1064,5,2,0,0,1064,1066,1,0,0,0,1065,1062,1,0,0,0,1065,1066,1,0,0,
  	0,1066,1067,1,0,0,0,1067,1088,3,184,92,0,1068,1069,3,182,91,0,1069,1070,
  	5,2,0,0,1070,1072,1,0,0,0,1071,1068,1,0,0,0,1071,1072,1,0,0,0,1072,1073,
  	1,0,0,0,1073,1074,3,222,111,0,1074,1083,5,3,0,0,1075,1080,3,64,32,0,1076,
  	1077,5,5,0,0,1077,1079,3,64,32,0,1078,1076,1,0,0,0,1079,1082,1,0,0,0,
  	1080,1078,1,0,0,0,1080,1081,1,0,0,0,1081,1084,1,0,0,0,1082,1080,1,0,0,
  	0,1083,1075,1,0,0,0,1083,1084,1,0,0,0,1084,1085,1,0,0,0,1085,1086,5,4,
  	0,0,1086,1088,1,0,0,0,1087,1049,1,0,0,0,1087,1065,1,0,0,0,1087,1071,1,
  	0,0,0,1088,1090,1,0,0,0,1089,966,1,0,0,0,1089,969,1,0,0,0,1089,972,1,
  	0,0,0,1089,975,1,0,0,0,1089,978,1,0,0,0,1089,981,1,0,0,0,1089,1003,1,
  	0,0,0,1089,1006,1,0,0,0,1089,1009,1,0,0,0,1089,1015,1,0,0,0,1089,1024,
  	1,0,0,0,1089,1027,1,0,0,0,1089,1037,1,0,0,0,1089,1044,1,0,0,0,1090,1093,
  	1,0,0,0,1091,1089,1,0,0,0,1091,1092,1,0,0,0,1092,65,1,0,0,0,1093,1091,
  	1,0,0,0,1094,1095,5,115,0,0,1095,1100,5,3,0,0,1096,1101,5,81,0,0,1097,
  	1098,7,14,0,0,1098,1099,5,5,0,0,1099,1101,3,170,85,0,1100,1096,1,0,0,
  	0,1100,1097,1,0,0,0,1101,1102,1,0,0,0,1102,1103,5,4,0,0,1103,67,1,0,0,
  	0,1104,1105,7,15,0,0,1105,69,1,0,0,0,1106,1107,5,3,0,0,1107,1112,3,64,
  	32,0,1108,1109,5,5,0,0,1109,1111,3,64,32,0,1110,1108,1,0,0,0,1111,1114,
  	1,0,0,0,1112,1110,1,0,0,0,1112,1113,1,0,0,0,1113,1115,1,0,0,0,1114,1112,
  	1,0,0,0,1115,1116,5,4,0,0,1116,71,1,0,0,0,1117,1118,5,144,0,0,1118,1123,
  	3,70,35,0,1119,1120,5,5,0,0,1120,1122,3,70,35,0,1121,1119,1,0,0,0,1122,
  	1125,1,0,0,0,1123,1121,1,0,0,0,1123,1124,1,0,0,0,1124,73,1,0,0,0,1125,
  	1123,1,0,0,0,1126,1128,3,48,24,0,1127,1126,1,0,0,0,1127,1128,1,0,0,0,
  	1128,1134,1,0,0,0,1129,1135,5,88,0,0,1130,1135,5,122,0,0,1131,1132,5,
  	88,0,0,1132,1133,5,108,0,0,1133,1135,7,8,0,0,1134,1129,1,0,0,0,1134,1130,
  	1,0,0,0,1134,1131,1,0,0,0,1135,1136,1,0,0,0,1136,1140,5,91,0,0,1137,1138,
  	3,182,91,0,1138,1139,5,2,0,0,1139,1141,1,0,0,0,1140,1137,1,0,0,0,1140,
  	1141,1,0,0,0,1141,1142,1,0,0,0,1142,1145,3,184,92,0,1143,1144,5,33,0,
  	0,1144,1146,3,206,103,0,1145,1143,1,0,0,0,1145,1146,1,0,0,0,1146,1158,
  	1,0,0,0,1147,1148,5,3,0,0,1148,1153,3,188,94,0,1149,1150,5,5,0,0,1150,
  	1152,3,188,94,0,1151,1149,1,0,0,0,1152,1155,1,0,0,0,1153,1151,1,0,0,0,
  	1153,1154,1,0,0,0,1154,1156,1,0,0,0,1155,1153,1,0,0,0,1156,1157,5,4,0,
  	0,1157,1159,1,0,0,0,1158,1147,1,0,0,0,1158,1159,1,0,0,0,1159,1169,1,0,
  	0,0,1160,1163,3,72,36,0,1161,1163,3,86,43,0,1162,1160,1,0,0,0,1162,1161,
  	1,0,0,0,1163,1165,1,0,0,0,1164,1166,3,78,39,0,1165,1164,1,0,0,0,1165,
  	1166,1,0,0,0,1166,1170,1,0,0,0,1167,1168,5,56,0,0,1168,1170,5,144,0,0,
  	1169,1162,1,0,0,0,1169,1167,1,0,0,0,1170,1172,1,0,0,0,1171,1173,3,76,
  	38,0,1172,1171,1,0,0,0,1172,1173,1,0,0,0,1173,75,1,0,0,0,1174,1175,5,
  	124,0,0,1175,1180,3,100,50,0,1176,1177,5,5,0,0,1177,1179,3,100,50,0,1178,
  	1176,1,0,0,0,1179,1182,1,0,0,0,1180,1178,1,0,0,0,1180,1181,1,0,0,0,1181,
  	77,1,0,0,0,1182,1180,1,0,0,0,1183,1184,5,107,0,0,1184,1199,5,48,0,0,1185,
  	1186,5,3,0,0,1186,1191,3,24,12,0,1187,1188,5,5,0,0,1188,1190,3,24,12,
  	0,1189,1187,1,0,0,0,1190,1193,1,0,0,0,1191,1189,1,0,0,0,1191,1192,1,0,
  	0,0,1192,1194,1,0,0,0,1193,1191,1,0,0,0,1194,1197,5,4,0,0,1195,1196,5,
  	148,0,0,1196,1198,3,64,32,0,1197,1195,1,0,0,0,1197,1198,1,0,0,0,1198,
  	1200,1,0,0,0,1199,1185,1,0,0,0,1199,1200,1,0,0,0,1200,1201,1,0,0,0,1201,
  	1228,5,183,0,0,1202,1229,5,184,0,0,1203,1204,5,141,0,0,1204,1207,5,131,
  	0,0,1205,1208,3,188,94,0,1206,1208,3,110,55,0,1207,1205,1,0,0,0,1207,
  	1206,1,0,0,0,1208,1209,1,0,0,0,1209,1210,5,6,0,0,1210,1221,3,64,32,0,
  	1211,1214,5,5,0,0,1212,1215,3,188,94,0,1213,1215,3,110,55,0,1214,1212,
  	1,0,0,0,1214,1213,1,0,0,0,1215,1216,1,0,0,0,1216,1217,5,6,0,0,1217,1218,
  	3,64,32,0,1218,1220,1,0,0,0,1219,1211,1,0,0,0,1220,1223,1,0,0,0,1221,
  	1219,1,0,0,0,1221,1222,1,0,0,0,1222,1226,1,0,0,0,1223,1221,1,0,0,0,1224,
  	1225,5,148,0,0,1225,1227,3,64,32,0,1226,1224,1,0,0,0,1226,1227,1,0,0,
  	0,1227,1229,1,0,0,0,1228,1202,1,0,0,0,1228,1203,1,0,0,0,1229,79,1,0,0,
  	0,1230,1234,5,112,0,0,1231,1232,3,182,91,0,1232,1233,5,2,0,0,1233,1235,
  	1,0,0,0,1234,1231,1,0,0,0,1234,1235,1,0,0,0,1235,1236,1,0,0,0,1236,1243,
  	3,202,101,0,1237,1238,5,6,0,0,1238,1244,3,82,41,0,1239,1240,5,3,0,0,1240,
  	1241,3,82,41,0,1241,1242,5,4,0,0,1242,1244,1,0,0,0,1243,1237,1,0,0,0,
  	1243,1239,1,0,0,0,1243,1244,1,0,0,0,1244,81,1,0,0,0,1245,1249,3,34,17,
  	0,1246,1249,3,178,89,0,1247,1249,5,188,0,0,1248,1245,1,0,0,0,1248,1246,
  	1,0,0,0,1248,1247,1,0,0,0,1249,83,1,0,0,0,1250,1261,5,119,0,0,1251,1262,
  	3,190,95,0,1252,1253,3,182,91,0,1253,1254,5,2,0,0,1254,1256,1,0,0,0,1255,
  	1252,1,0,0,0,1255,1256,1,0,0,0,1256,1259,1,0,0,0,1257,1260,3,184,92,0,
  	1258,1260,3,194,97,0,1259,1257,1,0,0,0,1259,1258,1,0,0,0,1260,1262,1,
  	0,0,0,1261,1251,1,0,0,0,1261,1255,1,0,0,0,1261,1262,1,0,0,0,1262,85,1,
  	0,0,0,1263,1265,3,134,67,0,1264,1263,1,0,0,0,1264,1265,1,0,0,0,1265,1266,
  	1,0,0,0,1266,1272,3,90,45,0,1267,1268,3,106,53,0,1268,1269,3,90,45,0,
  	1269,1271,1,0,0,0,1270,1267,1,0,0,0,1271,1274,1,0,0,0,1272,1270,1,0,0,
  	0,1272,1273,1,0,0,0,1273,1276,1,0,0,0,1274,1272,1,0,0,0,1275,1277,3,136,
  	68,0,1276,1275,1,0,0,0,1276,1277,1,0,0,0,1277,1279,1,0,0,0,1278,1280,
  	3,138,69,0,1279,1278,1,0,0,0,1279,1280,1,0,0,0,1280,87,1,0,0,0,1281,1289,
  	3,98,49,0,1282,1283,3,102,51,0,1283,1285,3,98,49,0,1284,1286,3,104,52,
  	0,1285,1284,1,0,0,0,1285,1286,1,0,0,0,1286,1288,1,0,0,0,1287,1282,1,0,
  	0,0,1288,1291,1,0,0,0,1289,1287,1,0,0,0,1289,1290,1,0,0,0,1290,89,1,0,
  	0,0,1291,1289,1,0,0,0,1292,1294,5,130,0,0,1293,1295,7,16,0,0,1294,1293,
  	1,0,0,0,1294,1295,1,0,0,0,1295,1296,1,0,0,0,1296,1301,3,100,50,0,1297,
  	1298,5,5,0,0,1298,1300,3,100,50,0,1299,1297,1,0,0,0,1300,1303,1,0,0,0,
  	1301,1299,1,0,0,0,1301,1302,1,0,0,0,1302,1316,1,0,0,0,1303,1301,1,0,0,
  	0,1304,1314,5,75,0,0,1305,1310,3,98,49,0,1306,1307,5,5,0,0,1307,1309,
  	3,98,49,0,1308,1306,1,0,0,0,1309,1312,1,0,0,0,1310,1308,1,0,0,0,1310,
  	1311,1,0,0,0,1311,1315,1,0,0,0,1312,1310,1,0,0,0,1313,1315,3,88,44,0,
  	1314,1305,1,0,0,0,1314,1313,1,0,0,0,1315,1317,1,0,0,0,1316,1304,1,0,0,
  	0,1316,1317,1,0,0,0,1317,1320,1,0,0,0,1318,1319,5,148,0,0,1319,1321,3,
  	64,32,0,1320,1318,1,0,0,0,1320,1321,1,0,0,0,1321,1336,1,0,0,0,1322,1323,
  	5,78,0,0,1323,1324,5,40,0,0,1324,1329,3,64,32,0,1325,1326,5,5,0,0,1326,
  	1328,3,64,32,0,1327,1325,1,0,0,0,1328,1331,1,0,0,0,1329,1327,1,0,0,0,
  	1329,1330,1,0,0,0,1330,1334,1,0,0,0,1331,1329,1,0,0,0,1332,1333,5,79,
  	0,0,1333,1335,3,64,32,0,1334,1332,1,0,0,0,1334,1335,1,0,0,0,1335,1337,
  	1,0,0,0,1336,1322,1,0,0,0,1336,1337,1,0,0,0,1337,1352,1,0,0,0,1338,1339,
  	5,174,0,0,1339,1340,3,210,105,0,1340,1341,5,33,0,0,1341,1349,3,120,60,
  	0,1342,1343,5,5,0,0,1343,1344,3,210,105,0,1344,1345,5,33,0,0,1345,1346,
  	3,120,60,0,1346,1348,1,0,0,0,1347,1342,1,0,0,0,1348,1351,1,0,0,0,1349,
  	1347,1,0,0,0,1349,1350,1,0,0,0,1350,1353,1,0,0,0,1351,1349,1,0,0,0,1352,
  	1338,1,0,0,0,1352,1353,1,0,0,0,1353,1356,1,0,0,0,1354,1356,3,72,36,0,
  	1355,1292,1,0,0,0,1355,1354,1,0,0,0,1356,91,1,0,0,0,1357,1358,3,86,43,
  	0,1358,93,1,0,0,0,1359,1361,3,134,67,0,1360,1359,1,0,0,0,1360,1361,1,
  	0,0,0,1361,1362,1,0,0,0,1362,1364,3,90,45,0,1363,1365,3,136,68,0,1364,
  	1363,1,0,0,0,1364,1365,1,0,0,0,1365,1367,1,0,0,0,1366,1368,3,138,69,0,
  	1367,1366,1,0,0,0,1367,1368,1,0,0,0,1368,95,1,0,0,0,1369,1371,3,134,67,
  	0,1370,1369,1,0,0,0,1370,1371,1,0,0,0,1371,1372,1,0,0,0,1372,1382,3,90,
  	45,0,1373,1375,5,139,0,0,1374,1376,5,29,0,0,1375,1374,1,0,0,0,1375,1376,
  	1,0,0,0,1376,1380,1,0,0,0,1377,1380,5,90,0,0,1378,1380,5,68,0,0,1379,
  	1373,1,0,0,0,1379,1377,1,0,0,0,1379,1378,1,0,0,0,1380,1381,1,0,0,0,1381,
  	1383,3,90,45,0,1382,1379,1,0,0,0,1383,1384,1,0,0,0,1384,1382,1,0,0,0,
  	1384,1385,1,0,0,0,1385,1387,1,0,0,0,1386,1388,3,136,68,0,1387,1386,1,
  	0,0,0,1387,1388,1,0,0,0,1388,1390,1,0,0,0,1389,1391,3,138,69,0,1390,1389,
  	1,0,0,0,1390,1391,1,0,0,0,1391,97,1,0,0,0,1392,1393,3,182,91,0,1393,1394,
  	5,2,0,0,1394,1396,1,0,0,0,1395,1392,1,0,0,0,1395,1396,1,0,0,0,1396,1397,
  	1,0,0,0,1397,1402,3,184,92,0,1398,1400,5,33,0,0,1399,1398,1,0,0,0,1399,
  	1400,1,0,0,0,1400,1401,1,0,0,0,1401,1403,3,206,103,0,1402,1399,1,0,0,
  	0,1402,1403,1,0,0,0,1403,1409,1,0,0,0,1404,1405,5,85,0,0,1405,1406,5,
  	40,0,0,1406,1410,3,194,97,0,1407,1408,5,102,0,0,1408,1410,5,85,0,0,1409,
  	1404,1,0,0,0,1409,1407,1,0,0,0,1409,1410,1,0,0,0,1410,1457,1,0,0,0,1411,
  	1412,3,182,91,0,1412,1413,5,2,0,0,1413,1415,1,0,0,0,1414,1411,1,0,0,0,
  	1414,1415,1,0,0,0,1415,1416,1,0,0,0,1416,1417,3,222,111,0,1417,1418,5,
  	3,0,0,1418,1423,3,64,32,0,1419,1420,5,5,0,0,1420,1422,3,64,32,0,1421,
  	1419,1,0,0,0,1422,1425,1,0,0,0,1423,1421,1,0,0,0,1423,1424,1,0,0,0,1424,
  	1426,1,0,0,0,1425,1423,1,0,0,0,1426,1431,5,4,0,0,1427,1429,5,33,0,0,1428,
  	1427,1,0,0,0,1428,1429,1,0,0,0,1429,1430,1,0,0,0,1430,1432,3,206,103,
  	0,1431,1428,1,0,0,0,1431,1432,1,0,0,0,1432,1457,1,0,0,0,1433,1443,5,3,
  	0,0,1434,1439,3,98,49,0,1435,1436,5,5,0,0,1436,1438,3,98,49,0,1437,1435,
  	1,0,0,0,1438,1441,1,0,0,0,1439,1437,1,0,0,0,1439,1440,1,0,0,0,1440,1444,
  	1,0,0,0,1441,1439,1,0,0,0,1442,1444,3,88,44,0,1443,1434,1,0,0,0,1443,
  	1442,1,0,0,0,1444,1445,1,0,0,0,1445,1446,5,4,0,0,1446,1457,1,0,0,0,1447,
  	1448,5,3,0,0,1448,1449,3,86,43,0,1449,1454,5,4,0,0,1450,1452,5,33,0,0,
  	1451,1450,1,0,0,0,1451,1452,1,0,0,0,1452,1453,1,0,0,0,1453,1455,3,206,
  	103,0,1454,1451,1,0,0,0,1454,1455,1,0,0,0,1455,1457,1,0,0,0,1456,1395,
  	1,0,0,0,1456,1414,1,0,0,0,1456,1433,1,0,0,0,1456,1447,1,0,0,0,1457,99,
  	1,0,0,0,1458,1471,5,7,0,0,1459,1460,3,184,92,0,1460,1461,5,2,0,0,1461,
  	1462,5,7,0,0,1462,1471,1,0,0,0,1463,1468,3,64,32,0,1464,1466,5,33,0,0,
  	1465,1464,1,0,0,0,1465,1466,1,0,0,0,1466,1467,1,0,0,0,1467,1469,3,174,
  	87,0,1468,1465,1,0,0,0,1468,1469,1,0,0,0,1469,1471,1,0,0,0,1470,1458,
  	1,0,0,0,1470,1459,1,0,0,0,1470,1463,1,0,0,0,1471,101,1,0,0,0,1472,1486,
  	5,5,0,0,1473,1475,5,100,0,0,1474,1473,1,0,0,0,1474,1475,1,0,0,0,1475,
  	1482,1,0,0,0,1476,1478,7,17,0,0,1477,1479,5,110,0,0,1478,1477,1,0,0,0,
  	1478,1479,1,0,0,0,1479,1483,1,0,0,0,1480,1483,5,87,0,0,1481,1483,5,51,
  	0,0,1482,1476,1,0,0,0,1482,1480,1,0,0,0,1482,1481,1,0,0,0,1482,1483,1,
  	0,0,0,1483,1484,1,0,0,0,1484,1486,5,94,0,0,1485,1472,1,0,0,0,1485,1474,
  	1,0,0,0,1486,103,1,0,0,0,1487,1488,5,107,0,0,1488,1502,3,64,32,0,1489,
  	1490,5,142,0,0,1490,1491,5,3,0,0,1491,1496,3,188,94,0,1492,1493,5,5,0,
  	0,1493,1495,3,188,94,0,1494,1492,1,0,0,0,1495,1498,1,0,0,0,1496,1494,
  	1,0,0,0,1496,1497,1,0,0,0,1497,1499,1,0,0,0,1498,1496,1,0,0,0,1499,1500,
  	5,4,0,0,1500,1502,1,0,0,0,1501,1487,1,0,0,0,1501,1489,1,0,0,0,1502,105,
  	1,0,0,0,1503,1505,5,139,0,0,1504,1506,5,29,0,0,1505,1504,1,0,0,0,1505,
  	1506,1,0,0,0,1506,1510,1,0,0,0,1507,1510,5,90,0,0,1508,1510,5,68,0,0,
  	1509,1503,1,0,0,0,1509,1507,1,0,0,0,1509,1508,1,0,0,0,1510,107,1,0,0,
  	0,1511,1513,3,48,24,0,1512,1511,1,0,0,0,1512,1513,1,0,0,0,1513,1514,1,
  	0,0,0,1514,1517,5,141,0,0,1515,1516,5,108,0,0,1516,1518,7,8,0,0,1517,
  	1515,1,0,0,0,1517,1518,1,0,0,0,1518,1519,1,0,0,0,1519,1520,3,114,57,0,
  	1520,1523,5,131,0,0,1521,1524,3,188,94,0,1522,1524,3,110,55,0,1523,1521,
  	1,0,0,0,1523,1522,1,0,0,0,1524,1525,1,0,0,0,1525,1526,5,6,0,0,1526,1537,
  	3,64,32,0,1527,1530,5,5,0,0,1528,1531,3,188,94,0,1529,1531,3,110,55,0,
  	1530,1528,1,0,0,0,1530,1529,1,0,0,0,1531,1532,1,0,0,0,1532,1533,5,6,0,
  	0,1533,1534,3,64,32,0,1534,1536,1,0,0,0,1535,1527,1,0,0,0,1536,1539,1,
  	0,0,0,1537,1535,1,0,0,0,1537,1538,1,0,0,0,1538,1552,1,0,0,0,1539,1537,
  	1,0,0,0,1540,1550,5,75,0,0,1541,1546,3,98,49,0,1542,1543,5,5,0,0,1543,
  	1545,3,98,49,0,1544,1542,1,0,0,0,1545,1548,1,0,0,0,1546,1544,1,0,0,0,
  	1546,1547,1,0,0,0,1547,1551,1,0,0,0,1548,1546,1,0,0,0,1549,1551,3,88,
  	44,0,1550,1541,1,0,0,0,1550,1549,1,0,0,0,1551,1553,1,0,0,0,1552,1540,
  	1,0,0,0,1552,1553,1,0,0,0,1553,1556,1,0,0,0,1554,1555,5,148,0,0,1555,
  	1557,3,64,32,0,1556,1554,1,0,0,0,1556,1557,1,0,0,0,1557,1559,1,0,0,0,
  	1558,1560,3,76,38,0,1559,1558,1,0,0,0,1559,1560,1,0,0,0,1560,109,1,0,
  	0,0,1561,1562,5,3,0,0,1562,1567,3,188,94,0,1563,1564,5,5,0,0,1564,1566,
  	3,188,94,0,1565,1563,1,0,0,0,1566,1569,1,0,0,0,1567,1565,1,0,0,0,1567,
  	1568,1,0,0,0,1568,1570,1,0,0,0,1569,1567,1,0,0,0,1570,1571,5,4,0,0,1571,
  	111,1,0,0,0,1572,1574,3,48,24,0,1573,1572,1,0,0,0,1573,1574,1,0,0,0,1574,
  	1575,1,0,0,0,1575,1578,5,141,0,0,1576,1577,5,108,0,0,1577,1579,7,8,0,
  	0,1578,1576,1,0,0,0,1578,1579,1,0,0,0,1579,1580,1,0,0,0,1580,1581,3,114,
  	57,0,1581,1584,5,131,0,0,1582,1585,3,188,94,0,1583,1585,3,110,55,0,1584,
  	1582,1,0,0,0,1584,1583,1,0,0,0,1585,1586,1,0,0,0,1586,1587,5,6,0,0,1587,
  	1598,3,64,32,0,1588,1591,5,5,0,0,1589,1592,3,188,94,0,1590,1592,3,110,
  	55,0,1591,1589,1,0,0,0,1591,1590,1,0,0,0,1592,1593,1,0,0,0,1593,1594,
  	5,6,0,0,1594,1595,3,64,32,0,1595,1597,1,0,0,0,1596,1588,1,0,0,0,1597,
  	1600,1,0,0,0,1598,1596,1,0,0,0,1598,1599,1,0,0,0,1599,1603,1,0,0,0,1600,
  	1598,1,0,0,0,1601,1602,5,148,0,0,1602,1604,3,64,32,0,1603,1601,1,0,0,
  	0,1603,1604,1,0,0,0,1604,1606,1,0,0,0,1605,1607,3,76,38,0,1606,1605,1,
  	0,0,0,1606,1607,1,0,0,0,1607,1612,1,0,0,0,1608,1610,3,136,68,0,1609,1608,
  	1,0,0,0,1609,1610,1,0,0,0,1610,1611,1,0,0,0,1611,1613,3,138,69,0,1612,
  	1609,1,0,0,0,1612,1613,1,0,0,0,1613,113,1,0,0,0,1614,1615,3,182,91,0,
  	1615,1616,5,2,0,0,1616,1618,1,0,0,0,1617,1614,1,0,0,0,1617,1618,1,0,0,
  	0,1618,1619,1,0,0,0,1619,1622,3,184,92,0,1620,1621,5,33,0,0,1621,1623,
  	3,212,106,0,1622,1620,1,0,0,0,1622,1623,1,0,0,0,1623,1629,1,0,0,0,1624,
  	1625,5,85,0,0,1625,1626,5,40,0,0,1626,1630,3,194,97,0,1627,1628,5,102,
  	0,0,1628,1630,5,85,0,0,1629,1624,1,0,0,0,1629,1627,1,0,0,0,1629,1630,
  	1,0,0,0,1630,115,1,0,0,0,1631,1633,5,143,0,0,1632,1634,3,182,91,0,1633,
  	1632,1,0,0,0,1633,1634,1,0,0,0,1634,1637,1,0,0,0,1635,1636,5,91,0,0,1636,
  	1638,3,214,107,0,1637,1635,1,0,0,0,1637,1638,1,0,0,0,1638,117,1,0,0,0,
  	1639,1640,5,178,0,0,1640,1641,5,3,0,0,1641,1642,5,148,0,0,1642,1643,3,
  	64,32,0,1643,1644,5,4,0,0,1644,119,1,0,0,0,1645,1647,5,3,0,0,1646,1648,
  	3,216,108,0,1647,1646,1,0,0,0,1647,1648,1,0,0,0,1648,1659,1,0,0,0,1649,
  	1650,5,153,0,0,1650,1651,5,40,0,0,1651,1656,3,64,32,0,1652,1653,5,5,0,
  	0,1653,1655,3,64,32,0,1654,1652,1,0,0,0,1655,1658,1,0,0,0,1656,1654,1,
  	0,0,0,1656,1657,1,0,0,0,1657,1660,1,0,0,0,1658,1656,1,0,0,0,1659,1649,
  	1,0,0,0,1659,1660,1,0,0,0,1660,1661,1,0,0,0,1661,1662,5,109,0,0,1662,
  	1663,5,40,0,0,1663,1668,3,140,70,0,1664,1665,5,5,0,0,1665,1667,3,140,
  	70,0,1666,1664,1,0,0,0,1667,1670,1,0,0,0,1668,1666,1,0,0,0,1668,1669,
  	1,0,0,0,1669,1672,1,0,0,0,1670,1668,1,0,0,0,1671,1673,3,124,62,0,1672,
  	1671,1,0,0,0,1672,1673,1,0,0,0,1673,1674,1,0,0,0,1674,1675,5,4,0,0,1675,
  	121,1,0,0,0,1676,1710,5,152,0,0,1677,1711,3,210,105,0,1678,1680,5,3,0,
  	0,1679,1681,3,216,108,0,1680,1679,1,0,0,0,1680,1681,1,0,0,0,1681,1692,
  	1,0,0,0,1682,1683,5,153,0,0,1683,1684,5,40,0,0,1684,1689,3,64,32,0,1685,
  	1686,5,5,0,0,1686,1688,3,64,32,0,1687,1685,1,0,0,0,1688,1691,1,0,0,0,
  	1689,1687,1,0,0,0,1689,1690,1,0,0,0,1690,1693,1,0,0,0,1691,1689,1,0,0,
  	0,1692,1682,1,0,0,0,1692,1693,1,0,0,0,1693,1704,1,0,0,0,1694,1695,5,109,
  	0,0,1695,1696,5,40,0,0,1696,1701,3,140,70,0,1697,1698,5,5,0,0,1698,1700,
  	3,140,70,0,1699,1697,1,0,0,0,1700,1703,1,0,0,0,1701,1699,1,0,0,0,1701,
  	1702,1,0,0,0,1702,1705,1,0,0,0,1703,1701,1,0,0,0,1704,1694,1,0,0,0,1704,
  	1705,1,0,0,0,1705,1707,1,0,0,0,1706,1708,3,124,62,0,1707,1706,1,0,0,0,
  	1707,1708,1,0,0,0,1708,1709,1,0,0,0,1709,1711,5,4,0,0,1710,1677,1,0,0,
  	0,1710,1678,1,0,0,0,1711,123,1,0,0,0,1712,1722,3,126,63,0,1713,1720,5,
  	180,0,0,1714,1715,5,101,0,0,1715,1721,5,182,0,0,1716,1717,5,157,0,0,1717,
  	1721,5,127,0,0,1718,1721,5,78,0,0,1719,1721,5,181,0,0,1720,1714,1,0,0,
  	0,1720,1716,1,0,0,0,1720,1718,1,0,0,0,1720,1719,1,0,0,0,1721,1723,1,0,
  	0,0,1722,1713,1,0,0,0,1722,1723,1,0,0,0,1723,125,1,0,0,0,1724,1731,7,
  	18,0,0,1725,1732,3,148,74,0,1726,1727,5,39,0,0,1727,1728,3,144,72,0,1728,
  	1729,5,32,0,0,1729,1730,3,146,73,0,1730,1732,1,0,0,0,1731,1725,1,0,0,
  	0,1731,1726,1,0,0,0,1732,127,1,0,0,0,1733,1734,3,218,109,0,1734,1744,
  	5,3,0,0,1735,1740,3,64,32,0,1736,1737,5,5,0,0,1737,1739,3,64,32,0,1738,
  	1736,1,0,0,0,1739,1742,1,0,0,0,1740,1738,1,0,0,0,1740,1741,1,0,0,0,1741,
  	1745,1,0,0,0,1742,1740,1,0,0,0,1743,1745,5,7,0,0,1744,1735,1,0,0,0,1744,
  	1743,1,0,0,0,1745,1746,1,0,0,0,1746,1747,5,4,0,0,1747,129,1,0,0,0,1748,
  	1749,3,220,110,0,1749,1762,5,3,0,0,1750,1752,5,62,0,0,1751,1750,1,0,0,
  	0,1751,1752,1,0,0,0,1752,1753,1,0,0,0,1753,1758,3,64,32,0,1754,1755,5,
  	5,0,0,1755,1757,3,64,32,0,1756,1754,1,0,0,0,1757,1760,1,0,0,0,1758,1756,
  	1,0,0,0,1758,1759,1,0,0,0,1759,1763,1,0,0,0,1760,1758,1,0,0,0,1761,1763,
  	5,7,0,0,1762,1751,1,0,0,0,1762,1761,1,0,0,0,1762,1763,1,0,0,0,1763,1764,
  	1,0,0,0,1764,1766,5,4,0,0,1765,1767,3,118,59,0,1766,1765,1,0,0,0,1766,
  	1767,1,0,0,0,1767,131,1,0,0,0,1768,1769,3,150,75,0,1769,1779,5,3,0,0,
  	1770,1775,3,64,32,0,1771,1772,5,5,0,0,1772,1774,3,64,32,0,1773,1771,1,
  	0,0,0,1774,1777,1,0,0,0,1775,1773,1,0,0,0,1775,1776,1,0,0,0,1776,1780,
  	1,0,0,0,1777,1775,1,0,0,0,1778,1780,5,7,0,0,1779,1770,1,0,0,0,1779,1778,
  	1,0,0,0,1779,1780,1,0,0,0,1780,1781,1,0,0,0,1781,1783,5,4,0,0,1782,1784,
  	3,118,59,0,1783,1782,1,0,0,0,1783,1784,1,0,0,0,1784,1785,1,0,0,0,1785,
  	1788,5,152,0,0,1786,1789,3,120,60,0,1787,1789,3,210,105,0,1788,1786,1,
  	0,0,0,1788,1787,1,0,0,0,1789,133,1,0,0,0,1790,1792,5,149,0,0,1791,1793,
  	5,116,0,0,1792,1791,1,0,0,0,1792,1793,1,0,0,0,1793,1794,1,0,0,0,1794,
  	1799,3,54,27,0,1795,1796,5,5,0,0,1796,1798,3,54,27,0,1797,1795,1,0,0,
  	0,1798,1801,1,0,0,0,1799,1797,1,0,0,0,1799,1800,1,0,0,0,1800,135,1,0,
  	0,0,1801,1799,1,0,0,0,1802,1803,5,109,0,0,1803,1804,5,40,0,0,1804,1809,
  	3,140,70,0,1805,1806,5,5,0,0,1806,1808,3,140,70,0,1807,1805,1,0,0,0,1808,
  	1811,1,0,0,0,1809,1807,1,0,0,0,1809,1810,1,0,0,0,1810,137,1,0,0,0,1811,
  	1809,1,0,0,0,1812,1813,5,98,0,0,1813,1816,3,64,32,0,1814,1815,7,19,0,
  	0,1815,1817,3,64,32,0,1816,1814,1,0,0,0,1816,1817,1,0,0,0,1817,139,1,
  	0,0,0,1818,1821,3,64,32,0,1819,1820,5,45,0,0,1820,1822,3,190,95,0,1821,
  	1819,1,0,0,0,1821,1822,1,0,0,0,1822,1824,1,0,0,0,1823,1825,3,142,71,0,
  	1824,1823,1,0,0,0,1824,1825,1,0,0,0,1825,1828,1,0,0,0,1826,1827,5,175,
  	0,0,1827,1829,7,20,0,0,1828,1826,1,0,0,0,1828,1829,1,0,0,0,1829,141,1,
  	0,0,0,1830,1831,7,21,0,0,1831,143,1,0,0,0,1832,1833,3,64,32,0,1833,1834,
  	5,155,0,0,1834,1843,1,0,0,0,1835,1836,3,64,32,0,1836,1837,5,158,0,0,1837,
  	1843,1,0,0,0,1838,1839,5,157,0,0,1839,1843,5,127,0,0,1840,1841,5,156,
  	0,0,1841,1843,5,155,0,0,1842,1832,1,0,0,0,1842,1835,1,0,0,0,1842,1838,
  	1,0,0,0,1842,1840,1,0,0,0,1843,145,1,0,0,0,1844,1845,3,64,32,0,1845,1846,
  	5,155,0,0,1846,1855,1,0,0,0,1847,1848,3,64,32,0,1848,1849,5,158,0,0,1849,
  	1855,1,0,0,0,1850,1851,5,157,0,0,1851,1855,5,127,0,0,1852,1853,5,156,
  	0,0,1853,1855,5,158,0,0,1854,1844,1,0,0,0,1854,1847,1,0,0,0,1854,1850,
  	1,0,0,0,1854,1852,1,0,0,0,1855,147,1,0,0,0,1856,1857,3,64,32,0,1857,1858,
  	5,155,0,0,1858,1864,1,0,0,0,1859,1860,5,156,0,0,1860,1864,5,155,0,0,1861,
  	1862,5,157,0,0,1862,1864,5,127,0,0,1863,1856,1,0,0,0,1863,1859,1,0,0,
  	0,1863,1861,1,0,0,0,1864,149,1,0,0,0,1865,1866,7,22,0,0,1866,1867,5,3,
  	0,0,1867,1868,3,64,32,0,1868,1869,5,4,0,0,1869,1870,5,152,0,0,1870,1872,
  	5,3,0,0,1871,1873,3,156,78,0,1872,1871,1,0,0,0,1872,1873,1,0,0,0,1873,
  	1874,1,0,0,0,1874,1876,3,160,80,0,1875,1877,3,126,63,0,1876,1875,1,0,
  	0,0,1876,1877,1,0,0,0,1877,1878,1,0,0,0,1878,1879,5,4,0,0,1879,1951,1,
  	0,0,0,1880,1881,7,23,0,0,1881,1882,5,3,0,0,1882,1883,5,4,0,0,1883,1884,
  	5,152,0,0,1884,1886,5,3,0,0,1885,1887,3,156,78,0,1886,1885,1,0,0,0,1886,
  	1887,1,0,0,0,1887,1889,1,0,0,0,1888,1890,3,158,79,0,1889,1888,1,0,0,0,
  	1889,1890,1,0,0,0,1890,1891,1,0,0,0,1891,1951,5,4,0,0,1892,1893,7,24,
  	0,0,1893,1894,5,3,0,0,1894,1895,5,4,0,0,1895,1896,5,152,0,0,1896,1898,
  	5,3,0,0,1897,1899,3,156,78,0,1898,1897,1,0,0,0,1898,1899,1,0,0,0,1899,
  	1900,1,0,0,0,1900,1901,3,160,80,0,1901,1902,5,4,0,0,1902,1951,1,0,0,0,
  	1903,1904,7,25,0,0,1904,1905,5,3,0,0,1905,1907,3,64,32,0,1906,1908,3,
  	152,76,0,1907,1906,1,0,0,0,1907,1908,1,0,0,0,1908,1910,1,0,0,0,1909,1911,
  	3,154,77,0,1910,1909,1,0,0,0,1910,1911,1,0,0,0,1911,1912,1,0,0,0,1912,
  	1913,5,4,0,0,1913,1914,5,152,0,0,1914,1916,5,3,0,0,1915,1917,3,156,78,
  	0,1916,1915,1,0,0,0,1916,1917,1,0,0,0,1917,1918,1,0,0,0,1918,1919,3,160,
  	80,0,1919,1920,5,4,0,0,1920,1951,1,0,0,0,1921,1922,5,164,0,0,1922,1923,
  	5,3,0,0,1923,1924,3,64,32,0,1924,1925,5,5,0,0,1925,1926,3,34,17,0,1926,
  	1927,5,4,0,0,1927,1928,5,152,0,0,1928,1930,5,3,0,0,1929,1931,3,156,78,
  	0,1930,1929,1,0,0,0,1930,1931,1,0,0,0,1931,1932,1,0,0,0,1932,1934,3,160,
  	80,0,1933,1935,3,126,63,0,1934,1933,1,0,0,0,1934,1935,1,0,0,0,1935,1936,
  	1,0,0,0,1936,1937,5,4,0,0,1937,1951,1,0,0,0,1938,1939,5,165,0,0,1939,
  	1940,5,3,0,0,1940,1941,3,64,32,0,1941,1942,5,4,0,0,1942,1943,5,152,0,
  	0,1943,1945,5,3,0,0,1944,1946,3,156,78,0,1945,1944,1,0,0,0,1945,1946,
  	1,0,0,0,1946,1947,1,0,0,0,1947,1948,3,160,80,0,1948,1949,5,4,0,0,1949,
  	1951,1,0,0,0,1950,1865,1,0,0,0,1950,1880,1,0,0,0,1950,1892,1,0,0,0,1950,
  	1903,1,0,0,0,1950,1921,1,0,0,0,1950,1938,1,0,0,0,1951,151,1,0,0,0,1952,
  	1953,5,5,0,0,1953,1954,3,34,17,0,1954,153,1,0,0,0,1955,1956,5,5,0,0,1956,
  	1957,3,34,17,0,1957,155,1,0,0,0,1958,1959,5,153,0,0,1959,1961,5,40,0,
  	0,1960,1962,3,64,32,0,1961,1960,1,0,0,0,1962,1963,1,0,0,0,1963,1961,1,
  	0,0,0,1963,1964,1,0,0,0,1964,157,1,0,0,0,1965,1966,5,109,0,0,1966,1968,
  	5,40,0,0,1967,1969,3,64,32,0,1968,1967,1,0,0,0,1969,1970,1,0,0,0,1970,
  	1968,1,0,0,0,1970,1971,1,0,0,0,1971,159,1,0,0,0,1972,1973,5,109,0,0,1973,
  	1974,5,40,0,0,1974,1975,3,162,81,0,1975,161,1,0,0,0,1976,1978,3,64,32,
  	0,1977,1979,3,142,71,0,1978,1977,1,0,0,0,1978,1979,1,0,0,0,1979,1987,
  	1,0,0,0,1980,1981,5,5,0,0,1981,1983,3,64,32,0,1982,1984,3,142,71,0,1983,
  	1982,1,0,0,0,1983,1984,1,0,0,0,1984,1986,1,0,0,0,1985,1980,1,0,0,0,1986,
  	1989,1,0,0,0,1987,1985,1,0,0,0,1987,1988,1,0,0,0,1988,163,1,0,0,0,1989,
  	1987,1,0,0,0,1990,1991,3,86,43,0,1991,165,1,0,0,0,1992,1993,3,86,43,0,
  	1993,167,1,0,0,0,1994,1995,7,26,0,0,1995,169,1,0,0,0,1996,1997,5,188,
  	0,0,1997,171,1,0,0,0,1998,2001,3,64,32,0,1999,2001,3,28,14,0,2000,1998,
  	1,0,0,0,2000,1999,1,0,0,0,2001,173,1,0,0,0,2002,2003,7,27,0,0,2003,175,
  	1,0,0,0,2004,2005,7,28,0,0,2005,177,1,0,0,0,2006,2007,3,224,112,0,2007,
  	179,1,0,0,0,2008,2009,3,224,112,0,2009,181,1,0,0,0,2010,2011,3,224,112,
  	0,2011,183,1,0,0,0,2012,2013,3,224,112,0,2013,185,1,0,0,0,2014,2015,3,
  	224,112,0,2015,187,1,0,0,0,2016,2017,3,224,112,0,2017,189,1,0,0,0,2018,
  	2019,3,224,112,0,2019,191,1,0,0,0,2020,2021,3,224,112,0,2021,193,1,0,
  	0,0,2022,2023,3,224,112,0,2023,195,1,0,0,0,2024,2025,3,224,112,0,2025,
  	197,1,0,0,0,2026,2027,3,224,112,0,2027,199,1,0,0,0,2028,2029,3,224,112,
  	0,2029,201,1,0,0,0,2030,2031,3,224,112,0,2031,203,1,0,0,0,2032,2033,3,
  	224,112,0,2033,205,1,0,0,0,2034,2035,3,224,112,0,2035,207,1,0,0,0,2036,
  	2037,3,224,112,0,2037,209,1,0,0,0,2038,2039,3,224,112,0,2039,211,1,0,
  	0,0,2040,2041,3,224,112,0,2041,213,1,0,0,0,2042,2043,3,224,112,0,2043,
  	215,1,0,0,0,2044,2045,3,224,112,0,2045,217,1,0,0,0,2046,2047,3,224,112,
  	0,2047,219,1,0,0,0,2048,2049,3,224,112,0,2049,221,1,0,0,0,2050,2051,3,
  	224,112,0,2051,223,1,0,0,0,2052,2060,5,185,0,0,2053,2060,3,176,88,0,2054,
  	2060,5,188,0,0,2055,2056,5,3,0,0,2056,2057,3,224,112,0,2057,2058,5,4,
  	0,0,2058,2060,1,0,0,0,2059,2052,1,0,0,0,2059,2053,1,0,0,0,2059,2054,1,
  	0,0,0,2059,2055,1,0,0,0,2060,225,1,0,0,0,297,229,237,244,249,255,261,
  	263,289,296,303,309,313,318,321,328,331,335,343,347,349,353,357,361,364,
  	371,377,383,388,399,405,409,413,416,420,426,431,440,447,453,457,461,466,
  	472,484,488,493,496,499,502,506,509,523,530,537,539,542,548,553,561,566,
  	581,587,597,602,612,616,618,622,627,629,637,643,648,655,666,669,671,678,
  	682,689,695,701,707,712,721,726,737,742,753,758,762,778,788,793,801,813,
  	818,826,833,836,839,846,849,852,855,859,867,872,882,887,896,903,907,911,
  	914,922,935,938,946,955,959,964,991,1000,1012,1017,1029,1035,1042,1046,
  	1056,1059,1065,1071,1080,1083,1087,1089,1091,1100,1112,1123,1127,1134,
  	1140,1145,1153,1158,1162,1165,1169,1172,1180,1191,1197,1199,1207,1214,
  	1221,1226,1228,1234,1243,1248,1255,1259,1261,1264,1272,1276,1279,1285,
  	1289,1294,1301,1310,1314,1316,1320,1329,1334,1336,1349,1352,1355,1360,
  	1364,1367,1370,1375,1379,1384,1387,1390,1395,1399,1402,1409,1414,1423,
  	1428,1431,1439,1443,1451,1454,1456,1465,1468,1470,1474,1478,1482,1485,
  	1496,1501,1505,1509,1512,1517,1523,1530,1537,1546,1550,1552,1556,1559,
  	1567,1573,1578,1584,1591,1598,1603,1606,1609,1612,1617,1622,1629,1633,
  	1637,1647,1656,1659,1668,1672,1680,1689,1692,1701,1704,1707,1710,1720,
  	1722,1731,1740,1744,1751,1758,1762,1766,1775,1779,1783,1788,1792,1799,
  	1809,1816,1821,1824,1828,1842,1854,1863,1872,1876,1886,1889,1898,1907,
  	1910,1916,1930,1934,1945,1950,1963,1970,1978,1983,1987,2000,2059
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  sqliteparserParserStaticData = std::move(staticData);
}

}

SQLiteParser::SQLiteParser(TokenStream *input) : SQLiteParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SQLiteParser::SQLiteParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SQLiteParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *sqliteparserParserStaticData->atn, sqliteparserParserStaticData->decisionToDFA, sqliteparserParserStaticData->sharedContextCache, options);
}

SQLiteParser::~SQLiteParser() {
  delete _interpreter;
}

const atn::ATN& SQLiteParser::getATN() const {
  return *sqliteparserParserStaticData->atn;
}

std::string SQLiteParser::getGrammarFileName() const {
  return "SQLiteParser.g4";
}

const std::vector<std::string>& SQLiteParser::getRuleNames() const {
  return sqliteparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& SQLiteParser::getVocabulary() const {
  return sqliteparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SQLiteParser::getSerializedATN() const {
  return sqliteparserParserStaticData->serializedATN;
}


//----------------- ParseContext ------------------------------------------------------------------

SQLiteParser::ParseContext::ParseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::ParseContext::EOF() {
  return getToken(SQLiteParser::EOF, 0);
}

std::vector<SQLiteParser::Sql_stmt_listContext *> SQLiteParser::ParseContext::sql_stmt_list() {
  return getRuleContexts<SQLiteParser::Sql_stmt_listContext>();
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::ParseContext::sql_stmt_list(size_t i) {
  return getRuleContext<SQLiteParser::Sql_stmt_listContext>(i);
}


size_t SQLiteParser::ParseContext::getRuleIndex() const {
  return SQLiteParser::RuleParse;
}

void SQLiteParser::ParseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParse(this);
}

void SQLiteParser::ParseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParse(this);
}


std::any SQLiteParser::ParseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitParse(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::ParseContext* SQLiteParser::parse() {
  ParseContext *_localctx = _tracker.createInstance<ParseContext>(_ctx, getState());
  enterRule(_localctx, 0, SQLiteParser::RuleParse);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(229);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -6339801325483589630) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7971300971697405919) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 550913) != 0)) {
      setState(226);
      sql_stmt_list();
      setState(231);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(232);
    match(SQLiteParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmt_listContext ------------------------------------------------------------------

SQLiteParser::Sql_stmt_listContext::Sql_stmt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Sql_stmtContext *> SQLiteParser::Sql_stmt_listContext::sql_stmt() {
  return getRuleContexts<SQLiteParser::Sql_stmtContext>();
}

SQLiteParser::Sql_stmtContext* SQLiteParser::Sql_stmt_listContext::sql_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Sql_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Sql_stmt_listContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Sql_stmt_listContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}


size_t SQLiteParser::Sql_stmt_listContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt_list;
}

void SQLiteParser::Sql_stmt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt_list(this);
}

void SQLiteParser::Sql_stmt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt_list(this);
}


std::any SQLiteParser::Sql_stmt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::sql_stmt_list() {
  Sql_stmt_listContext *_localctx = _tracker.createInstance<Sql_stmt_listContext>(_ctx, getState());
  enterRule(_localctx, 2, SQLiteParser::RuleSql_stmt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(237);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::SCOL) {
      setState(234);
      match(SQLiteParser::SCOL);
      setState(239);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(240);
    sql_stmt();
    setState(249);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(242); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(241);
          match(SQLiteParser::SCOL);
          setState(244); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SQLiteParser::SCOL);
        setState(246);
        sql_stmt(); 
      }
      setState(251);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
    setState(255);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(252);
        match(SQLiteParser::SCOL); 
      }
      setState(257);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmtContext ------------------------------------------------------------------

SQLiteParser::Sql_stmtContext::Sql_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::Sql_stmtContext::alter_table_stmt() {
  return getRuleContext<SQLiteParser::Alter_table_stmtContext>(0);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::Sql_stmtContext::analyze_stmt() {
  return getRuleContext<SQLiteParser::Analyze_stmtContext>(0);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::Sql_stmtContext::attach_stmt() {
  return getRuleContext<SQLiteParser::Attach_stmtContext>(0);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::Sql_stmtContext::begin_stmt() {
  return getRuleContext<SQLiteParser::Begin_stmtContext>(0);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::Sql_stmtContext::commit_stmt() {
  return getRuleContext<SQLiteParser::Commit_stmtContext>(0);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::Sql_stmtContext::create_index_stmt() {
  return getRuleContext<SQLiteParser::Create_index_stmtContext>(0);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::Sql_stmtContext::create_table_stmt() {
  return getRuleContext<SQLiteParser::Create_table_stmtContext>(0);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::Sql_stmtContext::create_trigger_stmt() {
  return getRuleContext<SQLiteParser::Create_trigger_stmtContext>(0);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::Sql_stmtContext::create_view_stmt() {
  return getRuleContext<SQLiteParser::Create_view_stmtContext>(0);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::Sql_stmtContext::create_virtual_table_stmt() {
  return getRuleContext<SQLiteParser::Create_virtual_table_stmtContext>(0);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Sql_stmtContext::delete_stmt() {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(0);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::Sql_stmtContext::delete_stmt_limited() {
  return getRuleContext<SQLiteParser::Delete_stmt_limitedContext>(0);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::Sql_stmtContext::detach_stmt() {
  return getRuleContext<SQLiteParser::Detach_stmtContext>(0);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::Sql_stmtContext::drop_stmt() {
  return getRuleContext<SQLiteParser::Drop_stmtContext>(0);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Sql_stmtContext::insert_stmt() {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(0);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::Sql_stmtContext::pragma_stmt() {
  return getRuleContext<SQLiteParser::Pragma_stmtContext>(0);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::Sql_stmtContext::reindex_stmt() {
  return getRuleContext<SQLiteParser::Reindex_stmtContext>(0);
}

SQLiteParser::Release_stmtContext* SQLiteParser::Sql_stmtContext::release_stmt() {
  return getRuleContext<SQLiteParser::Release_stmtContext>(0);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::Sql_stmtContext::rollback_stmt() {
  return getRuleContext<SQLiteParser::Rollback_stmtContext>(0);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::Sql_stmtContext::savepoint_stmt() {
  return getRuleContext<SQLiteParser::Savepoint_stmtContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Sql_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Update_stmtContext* SQLiteParser::Sql_stmtContext::update_stmt() {
  return getRuleContext<SQLiteParser::Update_stmtContext>(0);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::Sql_stmtContext::update_stmt_limited() {
  return getRuleContext<SQLiteParser::Update_stmt_limitedContext>(0);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::Sql_stmtContext::vacuum_stmt() {
  return getRuleContext<SQLiteParser::Vacuum_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}


size_t SQLiteParser::Sql_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt;
}

void SQLiteParser::Sql_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt(this);
}

void SQLiteParser::Sql_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt(this);
}


std::any SQLiteParser::Sql_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmtContext* SQLiteParser::sql_stmt() {
  Sql_stmtContext *_localctx = _tracker.createInstance<Sql_stmtContext>(_ctx, getState());
  enterRule(_localctx, 4, SQLiteParser::RuleSql_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXPLAIN_) {
      setState(258);
      match(SQLiteParser::EXPLAIN_);
      setState(261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::QUERY_) {
        setState(259);
        match(SQLiteParser::QUERY_);
        setState(260);
        match(SQLiteParser::PLAN_);
      }
    }
    setState(289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      setState(265);
      alter_table_stmt();
      break;
    }

    case 2: {
      setState(266);
      analyze_stmt();
      break;
    }

    case 3: {
      setState(267);
      attach_stmt();
      break;
    }

    case 4: {
      setState(268);
      begin_stmt();
      break;
    }

    case 5: {
      setState(269);
      commit_stmt();
      break;
    }

    case 6: {
      setState(270);
      create_index_stmt();
      break;
    }

    case 7: {
      setState(271);
      create_table_stmt();
      break;
    }

    case 8: {
      setState(272);
      create_trigger_stmt();
      break;
    }

    case 9: {
      setState(273);
      create_view_stmt();
      break;
    }

    case 10: {
      setState(274);
      create_virtual_table_stmt();
      break;
    }

    case 11: {
      setState(275);
      delete_stmt();
      break;
    }

    case 12: {
      setState(276);
      delete_stmt_limited();
      break;
    }

    case 13: {
      setState(277);
      detach_stmt();
      break;
    }

    case 14: {
      setState(278);
      drop_stmt();
      break;
    }

    case 15: {
      setState(279);
      insert_stmt();
      break;
    }

    case 16: {
      setState(280);
      pragma_stmt();
      break;
    }

    case 17: {
      setState(281);
      reindex_stmt();
      break;
    }

    case 18: {
      setState(282);
      release_stmt();
      break;
    }

    case 19: {
      setState(283);
      rollback_stmt();
      break;
    }

    case 20: {
      setState(284);
      savepoint_stmt();
      break;
    }

    case 21: {
      setState(285);
      select_stmt();
      break;
    }

    case 22: {
      setState(286);
      update_stmt();
      break;
    }

    case 23: {
      setState(287);
      update_stmt_limited();
      break;
    }

    case 24: {
      setState(288);
      vacuum_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Alter_table_stmtContext::Alter_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

std::vector<SQLiteParser::Table_nameContext *> SQLiteParser::Alter_table_stmtContext::table_name() {
  return getRuleContexts<SQLiteParser::Table_nameContext>();
}

SQLiteParser::Table_nameContext* SQLiteParser::Alter_table_stmtContext::table_name(size_t i) {
  return getRuleContext<SQLiteParser::Table_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

SQLiteParser::Column_defContext* SQLiteParser::Alter_table_stmtContext::column_def() {
  return getRuleContext<SQLiteParser::Column_defContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Alter_table_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Alter_table_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Alter_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}


size_t SQLiteParser::Alter_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAlter_table_stmt;
}

void SQLiteParser::Alter_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_stmt(this);
}

void SQLiteParser::Alter_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_stmt(this);
}


std::any SQLiteParser::Alter_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::alter_table_stmt() {
  Alter_table_stmtContext *_localctx = _tracker.createInstance<Alter_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, SQLiteParser::RuleAlter_table_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(291);
    match(SQLiteParser::ALTER_);
    setState(292);
    match(SQLiteParser::TABLE_);
    setState(296);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(293);
      schema_name();
      setState(294);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(298);
    table_name();
    setState(321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::RENAME_: {
        setState(299);
        match(SQLiteParser::RENAME_);
        setState(309);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
        case 1: {
          setState(300);
          match(SQLiteParser::TO_);
          setState(301);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_table_name = table_name();
          break;
        }

        case 2: {
          setState(303);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
          case 1: {
            setState(302);
            match(SQLiteParser::COLUMN_);
            break;
          }

          default:
            break;
          }
          setState(305);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->old_column_name = column_name();
          setState(306);
          match(SQLiteParser::TO_);
          setState(307);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_column_name = column_name();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::ADD_: {
        setState(311);
        match(SQLiteParser::ADD_);
        setState(313);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
        case 1: {
          setState(312);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(315);
        column_def();
        break;
      }

      case SQLiteParser::DROP_: {
        setState(316);
        match(SQLiteParser::DROP_);
        setState(318);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
        case 1: {
          setState(317);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(320);
        column_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_stmtContext ------------------------------------------------------------------

SQLiteParser::Analyze_stmtContext::Analyze_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Analyze_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::Analyze_stmtContext::table_or_index_name() {
  return getRuleContext<SQLiteParser::Table_or_index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Analyze_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAnalyze_stmt;
}

void SQLiteParser::Analyze_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyze_stmt(this);
}

void SQLiteParser::Analyze_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyze_stmt(this);
}


std::any SQLiteParser::Analyze_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::analyze_stmt() {
  Analyze_stmtContext *_localctx = _tracker.createInstance<Analyze_stmtContext>(_ctx, getState());
  enterRule(_localctx, 8, SQLiteParser::RuleAnalyze_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(323);
    match(SQLiteParser::ANALYZE_);
    setState(331);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      setState(324);
      schema_name();
      break;
    }

    case 2: {
      setState(328);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(325);
        schema_name();
        setState(326);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(330);
      table_or_index_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attach_stmtContext ------------------------------------------------------------------

SQLiteParser::Attach_stmtContext::Attach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Attach_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Attach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Attach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAttach_stmt;
}

void SQLiteParser::Attach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttach_stmt(this);
}

void SQLiteParser::Attach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttach_stmt(this);
}


std::any SQLiteParser::Attach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAttach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::attach_stmt() {
  Attach_stmtContext *_localctx = _tracker.createInstance<Attach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, SQLiteParser::RuleAttach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    match(SQLiteParser::ATTACH_);
    setState(335);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      setState(334);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(337);
    expr(0);
    setState(338);
    match(SQLiteParser::AS_);
    setState(339);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_stmtContext ------------------------------------------------------------------

SQLiteParser::Begin_stmtContext::Begin_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}

SQLiteParser::Transaction_nameContext* SQLiteParser::Begin_stmtContext::transaction_name() {
  return getRuleContext<SQLiteParser::Transaction_nameContext>(0);
}


size_t SQLiteParser::Begin_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleBegin_stmt;
}

void SQLiteParser::Begin_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_stmt(this);
}

void SQLiteParser::Begin_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_stmt(this);
}


std::any SQLiteParser::Begin_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBegin_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::begin_stmt() {
  Begin_stmtContext *_localctx = _tracker.createInstance<Begin_stmtContext>(_ctx, getState());
  enterRule(_localctx, 12, SQLiteParser::RuleBegin_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(341);
    match(SQLiteParser::BEGIN_);
    setState(343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & 16779265) != 0)) {
      setState(342);
      _la = _input->LA(1);
      if (!(((((_la - 58) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 58)) & 16779265) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(345);
      match(SQLiteParser::TRANSACTION_);
      setState(347);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
      case 1: {
        setState(346);
        transaction_name();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Commit_stmtContext ------------------------------------------------------------------

SQLiteParser::Commit_stmtContext::Commit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}


size_t SQLiteParser::Commit_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCommit_stmt;
}

void SQLiteParser::Commit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommit_stmt(this);
}

void SQLiteParser::Commit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommit_stmt(this);
}


std::any SQLiteParser::Commit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommit_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::commit_stmt() {
  Commit_stmtContext *_localctx = _tracker.createInstance<Commit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 14, SQLiteParser::RuleCommit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(351);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::COMMIT_

    || _la == SQLiteParser::END_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(353);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(352);
      match(SQLiteParser::TRANSACTION_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rollback_stmtContext ------------------------------------------------------------------

SQLiteParser::Rollback_stmtContext::Rollback_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Rollback_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Rollback_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRollback_stmt;
}

void SQLiteParser::Rollback_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollback_stmt(this);
}

void SQLiteParser::Rollback_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollback_stmt(this);
}


std::any SQLiteParser::Rollback_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRollback_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::rollback_stmt() {
  Rollback_stmtContext *_localctx = _tracker.createInstance<Rollback_stmtContext>(_ctx, getState());
  enterRule(_localctx, 16, SQLiteParser::RuleRollback_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    match(SQLiteParser::ROLLBACK_);
    setState(357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(356);
      match(SQLiteParser::TRANSACTION_);
    }
    setState(364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TO_) {
      setState(359);
      match(SQLiteParser::TO_);
      setState(361);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
      case 1: {
        setState(360);
        match(SQLiteParser::SAVEPOINT_);
        break;
      }

      default:
        break;
      }
      setState(363);
      savepoint_name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_stmtContext ------------------------------------------------------------------

SQLiteParser::Savepoint_stmtContext::Savepoint_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Savepoint_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Savepoint_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}


size_t SQLiteParser::Savepoint_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_stmt;
}

void SQLiteParser::Savepoint_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_stmt(this);
}

void SQLiteParser::Savepoint_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_stmt(this);
}


std::any SQLiteParser::Savepoint_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::savepoint_stmt() {
  Savepoint_stmtContext *_localctx = _tracker.createInstance<Savepoint_stmtContext>(_ctx, getState());
  enterRule(_localctx, 18, SQLiteParser::RuleSavepoint_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(SQLiteParser::SAVEPOINT_);
    setState(367);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Release_stmtContext ------------------------------------------------------------------

SQLiteParser::Release_stmtContext::Release_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Release_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Release_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRelease_stmt;
}

void SQLiteParser::Release_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelease_stmt(this);
}

void SQLiteParser::Release_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelease_stmt(this);
}


std::any SQLiteParser::Release_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRelease_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Release_stmtContext* SQLiteParser::release_stmt() {
  Release_stmtContext *_localctx = _tracker.createInstance<Release_stmtContext>(_ctx, getState());
  enterRule(_localctx, 20, SQLiteParser::RuleRelease_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(369);
    match(SQLiteParser::RELEASE_);
    setState(371);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(370);
      match(SQLiteParser::SAVEPOINT_);
      break;
    }

    default:
      break;
    }
    setState(373);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_index_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_index_stmtContext::Create_index_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Create_index_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_index_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Create_index_stmtContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Create_index_stmtContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_index_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_index_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_index_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}


size_t SQLiteParser::Create_index_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_index_stmt;
}

void SQLiteParser::Create_index_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index_stmt(this);
}

void SQLiteParser::Create_index_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index_stmt(this);
}


std::any SQLiteParser::Create_index_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_index_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::create_index_stmt() {
  Create_index_stmtContext *_localctx = _tracker.createInstance<Create_index_stmtContext>(_ctx, getState());
  enterRule(_localctx, 22, SQLiteParser::RuleCreate_index_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(375);
    match(SQLiteParser::CREATE_);
    setState(377);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::UNIQUE_) {
      setState(376);
      match(SQLiteParser::UNIQUE_);
    }
    setState(379);
    match(SQLiteParser::INDEX_);
    setState(383);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(380);
      match(SQLiteParser::IF_);
      setState(381);
      match(SQLiteParser::NOT_);
      setState(382);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(388);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(385);
      schema_name();
      setState(386);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(390);
    index_name();
    setState(391);
    match(SQLiteParser::ON_);
    setState(392);
    table_name();
    setState(393);
    match(SQLiteParser::OPEN_PAR);
    setState(394);
    indexed_column();
    setState(399);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(395);
      match(SQLiteParser::COMMA);
      setState(396);
      indexed_column();
      setState(401);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(402);
    match(SQLiteParser::CLOSE_PAR);
    setState(405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(403);
      match(SQLiteParser::WHERE_);
      setState(404);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indexed_columnContext ------------------------------------------------------------------

SQLiteParser::Indexed_columnContext::Indexed_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Indexed_columnContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::ExprContext* SQLiteParser::Indexed_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Indexed_columnContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Indexed_columnContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Indexed_columnContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}


size_t SQLiteParser::Indexed_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleIndexed_column;
}

void SQLiteParser::Indexed_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexed_column(this);
}

void SQLiteParser::Indexed_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexed_column(this);
}


std::any SQLiteParser::Indexed_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndexed_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Indexed_columnContext* SQLiteParser::indexed_column() {
  Indexed_columnContext *_localctx = _tracker.createInstance<Indexed_columnContext>(_ctx, getState());
  enterRule(_localctx, 24, SQLiteParser::RuleIndexed_column);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(409);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(407);
      column_name();
      break;
    }

    case 2: {
      setState(408);
      expr(0);
      break;
    }

    default:
      break;
    }
    setState(413);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(411);
      match(SQLiteParser::COLLATE_);
      setState(412);
      collation_name();
    }
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(415);
      asc_desc();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_table_stmtContext::Create_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_defContext *> SQLiteParser::Create_table_stmtContext::column_def() {
  return getRuleContexts<SQLiteParser::Column_defContext>();
}

SQLiteParser::Column_defContext* SQLiteParser::Create_table_stmtContext::column_def(size_t i) {
  return getRuleContext<SQLiteParser::Column_defContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_table_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Table_constraintContext *> SQLiteParser::Create_table_stmtContext::table_constraint() {
  return getRuleContexts<SQLiteParser::Table_constraintContext>();
}

SQLiteParser::Table_constraintContext* SQLiteParser::Create_table_stmtContext::table_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Table_constraintContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::WITHOUT_() {
  return getToken(SQLiteParser::WITHOUT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}


size_t SQLiteParser::Create_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_table_stmt;
}

void SQLiteParser::Create_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_stmt(this);
}

void SQLiteParser::Create_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_stmt(this);
}


std::any SQLiteParser::Create_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::create_table_stmt() {
  Create_table_stmtContext *_localctx = _tracker.createInstance<Create_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 26, SQLiteParser::RuleCreate_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(418);
    match(SQLiteParser::CREATE_);
    setState(420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(419);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(422);
    match(SQLiteParser::TABLE_);
    setState(426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(423);
      match(SQLiteParser::IF_);
      setState(424);
      match(SQLiteParser::NOT_);
      setState(425);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(431);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(428);
      schema_name();
      setState(429);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(433);
    table_name();
    setState(457);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR: {
        setState(434);
        match(SQLiteParser::OPEN_PAR);
        setState(435);
        column_def();
        setState(440);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(436);
            match(SQLiteParser::COMMA);
            setState(437);
            column_def(); 
          }
          setState(442);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
        }
        setState(447);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(443);
          match(SQLiteParser::COMMA);
          setState(444);
          table_constraint();
          setState(449);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(450);
        match(SQLiteParser::CLOSE_PAR);
        setState(453);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WITHOUT_) {
          setState(451);
          match(SQLiteParser::WITHOUT_);
          setState(452);
          antlrcpp::downCast<Create_table_stmtContext *>(_localctx)->row_ROW_ID = match(SQLiteParser::IDENTIFIER);
        }
        break;
      }

      case SQLiteParser::AS_: {
        setState(455);
        match(SQLiteParser::AS_);
        setState(456);
        select_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_defContext ------------------------------------------------------------------

SQLiteParser::Column_defContext::Column_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_defContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Type_nameContext* SQLiteParser::Column_defContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

std::vector<SQLiteParser::Column_constraintContext *> SQLiteParser::Column_defContext::column_constraint() {
  return getRuleContexts<SQLiteParser::Column_constraintContext>();
}

SQLiteParser::Column_constraintContext* SQLiteParser::Column_defContext::column_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Column_constraintContext>(i);
}


size_t SQLiteParser::Column_defContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_def;
}

void SQLiteParser::Column_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def(this);
}

void SQLiteParser::Column_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def(this);
}


std::any SQLiteParser::Column_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_def(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_defContext* SQLiteParser::column_def() {
  Column_defContext *_localctx = _tracker.createInstance<Column_defContext>(_ctx, getState());
  enterRule(_localctx, 28, SQLiteParser::RuleColumn_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(459);
    column_name();
    setState(461);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(460);
      type_name();
      break;
    }

    default:
      break;
    }
    setState(466);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 72673329139417088) != 0) || ((((_la - 102) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 102)) & 274877941765) != 0) || _la == SQLiteParser::GENERATED_) {
      setState(463);
      column_constraint();
      setState(468);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_nameContext ------------------------------------------------------------------

SQLiteParser::Type_nameContext::Type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Type_nameContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Type_nameContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Signed_numberContext *> SQLiteParser::Type_nameContext::signed_number() {
  return getRuleContexts<SQLiteParser::Signed_numberContext>();
}

SQLiteParser::Signed_numberContext* SQLiteParser::Type_nameContext::signed_number(size_t i) {
  return getRuleContext<SQLiteParser::Signed_numberContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Type_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleType_name;
}

void SQLiteParser::Type_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name(this);
}

void SQLiteParser::Type_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name(this);
}


std::any SQLiteParser::Type_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitType_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Type_nameContext* SQLiteParser::type_name() {
  Type_nameContext *_localctx = _tracker.createInstance<Type_nameContext>(_ctx, getState());
  enterRule(_localctx, 30, SQLiteParser::RuleType_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(470); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(469);
              name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(472); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(484);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(474);
      match(SQLiteParser::OPEN_PAR);
      setState(475);
      signed_number();
      setState(476);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 2: {
      setState(478);
      match(SQLiteParser::OPEN_PAR);
      setState(479);
      signed_number();
      setState(480);
      match(SQLiteParser::COMMA);
      setState(481);
      signed_number();
      setState(482);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

SQLiteParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Column_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Column_constraintContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Column_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Column_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Column_constraintContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::Literal_valueContext* SQLiteParser::Column_constraintContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Column_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Column_constraintContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Column_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_constraint;
}

void SQLiteParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void SQLiteParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}


std::any SQLiteParser::Column_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_constraintContext* SQLiteParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 32, SQLiteParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(486);
      match(SQLiteParser::CONSTRAINT_);
      setState(487);
      name();
    }
    setState(539);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_: {
        setState(490);
        match(SQLiteParser::PRIMARY_);
        setState(491);
        match(SQLiteParser::KEY_);
        setState(493);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ASC_

        || _la == SQLiteParser::DESC_) {
          setState(492);
          asc_desc();
        }
        setState(496);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(495);
          conflict_clause();
        }
        setState(499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::AUTOINCREMENT_) {
          setState(498);
          match(SQLiteParser::AUTOINCREMENT_);
        }
        break;
      }

      case SQLiteParser::NOT_:
      case SQLiteParser::NULL_:
      case SQLiteParser::UNIQUE_: {
        setState(506);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::NOT_:
          case SQLiteParser::NULL_: {
            setState(502);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::NOT_) {
              setState(501);
              match(SQLiteParser::NOT_);
            }
            setState(504);
            match(SQLiteParser::NULL_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(505);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(508);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(511);
        match(SQLiteParser::CHECK_);
        setState(512);
        match(SQLiteParser::OPEN_PAR);
        setState(513);
        expr(0);
        setState(514);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(516);
        match(SQLiteParser::DEFAULT_);
        setState(523);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
        case 1: {
          setState(517);
          signed_number();
          break;
        }

        case 2: {
          setState(518);
          literal_value();
          break;
        }

        case 3: {
          setState(519);
          match(SQLiteParser::OPEN_PAR);
          setState(520);
          expr(0);
          setState(521);
          match(SQLiteParser::CLOSE_PAR);
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::COLLATE_: {
        setState(525);
        match(SQLiteParser::COLLATE_);
        setState(526);
        collation_name();
        break;
      }

      case SQLiteParser::REFERENCES_: {
        setState(527);
        foreign_key_clause();
        break;
      }

      case SQLiteParser::AS_:
      case SQLiteParser::GENERATED_: {
        setState(530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GENERATED_) {
          setState(528);
          match(SQLiteParser::GENERATED_);
          setState(529);
          match(SQLiteParser::ALWAYS_);
        }
        setState(532);
        match(SQLiteParser::AS_);
        setState(533);
        match(SQLiteParser::OPEN_PAR);
        setState(534);
        expr(0);
        setState(535);
        match(SQLiteParser::CLOSE_PAR);
        setState(537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::VIRTUAL_

        || _la == SQLiteParser::STORED_) {
          setState(536);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::VIRTUAL_

          || _la == SQLiteParser::STORED_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_numberContext ------------------------------------------------------------------

SQLiteParser::Signed_numberContext::Signed_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}


size_t SQLiteParser::Signed_numberContext::getRuleIndex() const {
  return SQLiteParser::RuleSigned_number;
}

void SQLiteParser::Signed_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_number(this);
}

void SQLiteParser::Signed_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_number(this);
}


std::any SQLiteParser::Signed_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSigned_number(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Signed_numberContext* SQLiteParser::signed_number() {
  Signed_numberContext *_localctx = _tracker.createInstance<Signed_numberContext>(_ctx, getState());
  enterRule(_localctx, 34, SQLiteParser::RuleSigned_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PLUS

    || _la == SQLiteParser::MINUS) {
      setState(541);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::PLUS

      || _la == SQLiteParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(544);
    match(SQLiteParser::NUMERIC_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

SQLiteParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Table_constraintContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Table_constraintContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Table_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Table_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Table_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Table_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Table_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Table_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}


size_t SQLiteParser::Table_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_constraint;
}

void SQLiteParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void SQLiteParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}


std::any SQLiteParser::Table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_constraintContext* SQLiteParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 36, SQLiteParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(546);
      match(SQLiteParser::CONSTRAINT_);
      setState(547);
      name();
    }
    setState(587);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::UNIQUE_: {
        setState(553);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::PRIMARY_: {
            setState(550);
            match(SQLiteParser::PRIMARY_);
            setState(551);
            match(SQLiteParser::KEY_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(552);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(555);
        match(SQLiteParser::OPEN_PAR);
        setState(556);
        indexed_column();
        setState(561);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(557);
          match(SQLiteParser::COMMA);
          setState(558);
          indexed_column();
          setState(563);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(564);
        match(SQLiteParser::CLOSE_PAR);
        setState(566);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(565);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(568);
        match(SQLiteParser::CHECK_);
        setState(569);
        match(SQLiteParser::OPEN_PAR);
        setState(570);
        expr(0);
        setState(571);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::FOREIGN_: {
        setState(573);
        match(SQLiteParser::FOREIGN_);
        setState(574);
        match(SQLiteParser::KEY_);
        setState(575);
        match(SQLiteParser::OPEN_PAR);
        setState(576);
        column_name();
        setState(581);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(577);
          match(SQLiteParser::COMMA);
          setState(578);
          column_name();
          setState(583);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(584);
        match(SQLiteParser::CLOSE_PAR);
        setState(585);
        foreign_key_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_key_clauseContext ------------------------------------------------------------------

SQLiteParser::Foreign_key_clauseContext::Foreign_key_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::Foreign_key_clauseContext::foreign_table() {
  return getRuleContext<SQLiteParser::Foreign_tableContext>(0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Foreign_key_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Foreign_key_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ON_() {
  return getTokens(SQLiteParser::ON_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ON_(size_t i) {
  return getToken(SQLiteParser::ON_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::MATCH_() {
  return getTokens(SQLiteParser::MATCH_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::MATCH_(size_t i) {
  return getToken(SQLiteParser::MATCH_, i);
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Foreign_key_clauseContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Foreign_key_clauseContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DELETE_() {
  return getTokens(SQLiteParser::DELETE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DELETE_(size_t i) {
  return getToken(SQLiteParser::DELETE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::UPDATE_() {
  return getTokens(SQLiteParser::UPDATE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::UPDATE_(size_t i) {
  return getToken(SQLiteParser::UPDATE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::SET_() {
  return getTokens(SQLiteParser::SET_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::SET_(size_t i) {
  return getToken(SQLiteParser::SET_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::CASCADE_() {
  return getTokens(SQLiteParser::CASCADE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CASCADE_(size_t i) {
  return getToken(SQLiteParser::CASCADE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::RESTRICT_() {
  return getTokens(SQLiteParser::RESTRICT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::RESTRICT_(size_t i) {
  return getToken(SQLiteParser::RESTRICT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NO_() {
  return getTokens(SQLiteParser::NO_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NO_(size_t i) {
  return getToken(SQLiteParser::NO_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ACTION_() {
  return getTokens(SQLiteParser::ACTION_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ACTION_(size_t i) {
  return getToken(SQLiteParser::ACTION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NULL_() {
  return getTokens(SQLiteParser::NULL_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NULL_(size_t i) {
  return getToken(SQLiteParser::NULL_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DEFAULT_() {
  return getTokens(SQLiteParser::DEFAULT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFAULT_(size_t i) {
  return getToken(SQLiteParser::DEFAULT_, i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}


size_t SQLiteParser::Foreign_key_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_key_clause;
}

void SQLiteParser::Foreign_key_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_key_clause(this);
}

void SQLiteParser::Foreign_key_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_key_clause(this);
}


std::any SQLiteParser::Foreign_key_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_key_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::foreign_key_clause() {
  Foreign_key_clauseContext *_localctx = _tracker.createInstance<Foreign_key_clauseContext>(_ctx, getState());
  enterRule(_localctx, 38, SQLiteParser::RuleForeign_key_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(SQLiteParser::REFERENCES_);
    setState(590);
    foreign_table();
    setState(602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(591);
      match(SQLiteParser::OPEN_PAR);
      setState(592);
      column_name();
      setState(597);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(593);
        match(SQLiteParser::COMMA);
        setState(594);
        column_name();
        setState(599);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(600);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(618);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::MATCH_

    || _la == SQLiteParser::ON_) {
      setState(616);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::ON_: {
          setState(604);
          match(SQLiteParser::ON_);
          setState(605);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::DELETE_ || _la == SQLiteParser::UPDATE_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(612);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::SET_: {
              setState(606);
              match(SQLiteParser::SET_);
              setState(607);
              _la = _input->LA(1);
              if (!(_la == SQLiteParser::DEFAULT_

              || _la == SQLiteParser::NULL_)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

            case SQLiteParser::CASCADE_: {
              setState(608);
              match(SQLiteParser::CASCADE_);
              break;
            }

            case SQLiteParser::RESTRICT_: {
              setState(609);
              match(SQLiteParser::RESTRICT_);
              break;
            }

            case SQLiteParser::NO_: {
              setState(610);
              match(SQLiteParser::NO_);
              setState(611);
              match(SQLiteParser::ACTION_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case SQLiteParser::MATCH_: {
          setState(614);
          match(SQLiteParser::MATCH_);
          setState(615);
          name();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(620);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::NOT_) {
        setState(621);
        match(SQLiteParser::NOT_);
      }
      setState(624);
      match(SQLiteParser::DEFERRABLE_);
      setState(627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::INITIALLY_) {
        setState(625);
        match(SQLiteParser::INITIALLY_);
        setState(626);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::DEFERRED_

        || _la == SQLiteParser::IMMEDIATE_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conflict_clauseContext ------------------------------------------------------------------

SQLiteParser::Conflict_clauseContext::Conflict_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}


size_t SQLiteParser::Conflict_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleConflict_clause;
}

void SQLiteParser::Conflict_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConflict_clause(this);
}

void SQLiteParser::Conflict_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConflict_clause(this);
}


std::any SQLiteParser::Conflict_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitConflict_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::conflict_clause() {
  Conflict_clauseContext *_localctx = _tracker.createInstance<Conflict_clauseContext>(_ctx, getState());
  enterRule(_localctx, 40, SQLiteParser::RuleConflict_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(SQLiteParser::ON_);
    setState(632);
    match(SQLiteParser::CONFLICT_);
    setState(633);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_trigger_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_trigger_stmtContext::Create_trigger_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::Create_trigger_stmtContext::trigger_name() {
  return getRuleContext<SQLiteParser::Trigger_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_trigger_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_trigger_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::OF_() {
  return getTokens(SQLiteParser::OF_);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::OF_(size_t i) {
  return getToken(SQLiteParser::OF_, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_trigger_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_trigger_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_trigger_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Update_stmtContext *> SQLiteParser::Create_trigger_stmtContext::update_stmt() {
  return getRuleContexts<SQLiteParser::Update_stmtContext>();
}

SQLiteParser::Update_stmtContext* SQLiteParser::Create_trigger_stmtContext::update_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Update_stmtContext>(i);
}

std::vector<SQLiteParser::Insert_stmtContext *> SQLiteParser::Create_trigger_stmtContext::insert_stmt() {
  return getRuleContexts<SQLiteParser::Insert_stmtContext>();
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Create_trigger_stmtContext::insert_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(i);
}

std::vector<SQLiteParser::Delete_stmtContext *> SQLiteParser::Create_trigger_stmtContext::delete_stmt() {
  return getRuleContexts<SQLiteParser::Delete_stmtContext>();
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Create_trigger_stmtContext::delete_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(i);
}

std::vector<SQLiteParser::Select_stmtContext *> SQLiteParser::Create_trigger_stmtContext::select_stmt() {
  return getRuleContexts<SQLiteParser::Select_stmtContext>();
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_trigger_stmtContext::select_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Select_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_trigger_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_trigger_stmt;
}

void SQLiteParser::Create_trigger_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_trigger_stmt(this);
}

void SQLiteParser::Create_trigger_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_trigger_stmt(this);
}


std::any SQLiteParser::Create_trigger_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_trigger_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::create_trigger_stmt() {
  Create_trigger_stmtContext *_localctx = _tracker.createInstance<Create_trigger_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, SQLiteParser::RuleCreate_trigger_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(635);
    match(SQLiteParser::CREATE_);
    setState(637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(636);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(639);
    match(SQLiteParser::TRIGGER_);
    setState(643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(640);
      match(SQLiteParser::IF_);
      setState(641);
      match(SQLiteParser::NOT_);
      setState(642);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(645);
      schema_name();
      setState(646);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(650);
    trigger_name();
    setState(655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::BEFORE_: {
        setState(651);
        match(SQLiteParser::BEFORE_);
        break;
      }

      case SQLiteParser::AFTER_: {
        setState(652);
        match(SQLiteParser::AFTER_);
        break;
      }

      case SQLiteParser::INSTEAD_: {
        setState(653);
        match(SQLiteParser::INSTEAD_);
        setState(654);
        match(SQLiteParser::OF_);
        break;
      }

      case SQLiteParser::DELETE_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::UPDATE_: {
        break;
      }

    default:
      break;
    }
    setState(671);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::DELETE_: {
        setState(657);
        match(SQLiteParser::DELETE_);
        break;
      }

      case SQLiteParser::INSERT_: {
        setState(658);
        match(SQLiteParser::INSERT_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(659);
        match(SQLiteParser::UPDATE_);
        setState(669);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::OF_) {
          setState(660);
          match(SQLiteParser::OF_);
          setState(661);
          column_name();
          setState(666);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(662);
            match(SQLiteParser::COMMA);
            setState(663);
            column_name();
            setState(668);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(673);
    match(SQLiteParser::ON_);
    setState(674);
    table_name();
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FOR_) {
      setState(675);
      match(SQLiteParser::FOR_);
      setState(676);
      match(SQLiteParser::EACH_);
      setState(677);
      match(SQLiteParser::ROW_);
    }
    setState(682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHEN_) {
      setState(680);
      match(SQLiteParser::WHEN_);
      setState(681);
      expr(0);
    }
    setState(684);
    match(SQLiteParser::BEGIN_);
    setState(693); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(689);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
      case 1: {
        setState(685);
        update_stmt();
        break;
      }

      case 2: {
        setState(686);
        insert_stmt();
        break;
      }

      case 3: {
        setState(687);
        delete_stmt();
        break;
      }

      case 4: {
        setState(688);
        select_stmt();
        break;
      }

      default:
        break;
      }
      setState(691);
      match(SQLiteParser::SCOL);
      setState(695); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::DELETE_ || ((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 2386912217732743169) != 0));
    setState(697);
    match(SQLiteParser::END_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_view_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_view_stmtContext::Create_view_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

SQLiteParser::View_nameContext* SQLiteParser::Create_view_stmtContext::view_name() {
  return getRuleContext<SQLiteParser::View_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_view_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_view_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_view_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_view_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_view_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_view_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_view_stmt;
}

void SQLiteParser::Create_view_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_view_stmt(this);
}

void SQLiteParser::Create_view_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_view_stmt(this);
}


std::any SQLiteParser::Create_view_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_view_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::create_view_stmt() {
  Create_view_stmtContext *_localctx = _tracker.createInstance<Create_view_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, SQLiteParser::RuleCreate_view_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    match(SQLiteParser::CREATE_);
    setState(701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(700);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(703);
    match(SQLiteParser::VIEW_);
    setState(707);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(704);
      match(SQLiteParser::IF_);
      setState(705);
      match(SQLiteParser::NOT_);
      setState(706);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(712);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(709);
      schema_name();
      setState(710);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(714);
    view_name();
    setState(726);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(715);
      match(SQLiteParser::OPEN_PAR);
      setState(716);
      column_name();
      setState(721);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(717);
        match(SQLiteParser::COMMA);
        setState(718);
        column_name();
        setState(723);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(724);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(728);
    match(SQLiteParser::AS_);
    setState(729);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_virtual_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_virtual_table_stmtContext::Create_virtual_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_virtual_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

SQLiteParser::Module_nameContext* SQLiteParser::Create_virtual_table_stmtContext::module_name() {
  return getRuleContext<SQLiteParser::Module_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_virtual_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Module_argumentContext *> SQLiteParser::Create_virtual_table_stmtContext::module_argument() {
  return getRuleContexts<SQLiteParser::Module_argumentContext>();
}

SQLiteParser::Module_argumentContext* SQLiteParser::Create_virtual_table_stmtContext::module_argument(size_t i) {
  return getRuleContext<SQLiteParser::Module_argumentContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_virtual_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_virtual_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_virtual_table_stmt;
}

void SQLiteParser::Create_virtual_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_virtual_table_stmt(this);
}

void SQLiteParser::Create_virtual_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_virtual_table_stmt(this);
}


std::any SQLiteParser::Create_virtual_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_virtual_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::create_virtual_table_stmt() {
  Create_virtual_table_stmtContext *_localctx = _tracker.createInstance<Create_virtual_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, SQLiteParser::RuleCreate_virtual_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    match(SQLiteParser::CREATE_);
    setState(732);
    match(SQLiteParser::VIRTUAL_);
    setState(733);
    match(SQLiteParser::TABLE_);
    setState(737);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(734);
      match(SQLiteParser::IF_);
      setState(735);
      match(SQLiteParser::NOT_);
      setState(736);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(742);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(739);
      schema_name();
      setState(740);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(744);
    table_name();
    setState(745);
    match(SQLiteParser::USING_);
    setState(746);
    module_name();
    setState(758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(747);
      match(SQLiteParser::OPEN_PAR);
      setState(748);
      module_argument();
      setState(753);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(749);
        match(SQLiteParser::COMMA);
        setState(750);
        module_argument();
        setState(755);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(756);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clauseContext ------------------------------------------------------------------

SQLiteParser::With_clauseContext::With_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::With_clauseContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

std::vector<SQLiteParser::Cte_table_nameContext *> SQLiteParser::With_clauseContext::cte_table_name() {
  return getRuleContexts<SQLiteParser::Cte_table_nameContext>();
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::With_clauseContext::cte_table_name(size_t i) {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

std::vector<SQLiteParser::Select_stmtContext *> SQLiteParser::With_clauseContext::select_stmt() {
  return getRuleContexts<SQLiteParser::Select_stmtContext>();
}

SQLiteParser::Select_stmtContext* SQLiteParser::With_clauseContext::select_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Select_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::With_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleWith_clause;
}

void SQLiteParser::With_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_clause(this);
}

void SQLiteParser::With_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_clause(this);
}


std::any SQLiteParser::With_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::With_clauseContext* SQLiteParser::with_clause() {
  With_clauseContext *_localctx = _tracker.createInstance<With_clauseContext>(_ctx, getState());
  enterRule(_localctx, 48, SQLiteParser::RuleWith_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(760);
    match(SQLiteParser::WITH_);
    setState(762);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(761);
      match(SQLiteParser::RECURSIVE_);
      break;
    }

    default:
      break;
    }
    setState(764);
    cte_table_name();
    setState(765);
    match(SQLiteParser::AS_);
    setState(766);
    match(SQLiteParser::OPEN_PAR);
    setState(767);
    select_stmt();
    setState(768);
    match(SQLiteParser::CLOSE_PAR);
    setState(778);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(769);
      match(SQLiteParser::COMMA);
      setState(770);
      cte_table_name();
      setState(771);
      match(SQLiteParser::AS_);
      setState(772);
      match(SQLiteParser::OPEN_PAR);
      setState(773);
      select_stmt();
      setState(774);
      match(SQLiteParser::CLOSE_PAR);
      setState(780);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_table_nameContext ------------------------------------------------------------------

SQLiteParser::Cte_table_nameContext::Cte_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Cte_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Cte_table_nameContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Cte_table_nameContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Cte_table_nameContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Cte_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCte_table_name;
}

void SQLiteParser::Cte_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_table_name(this);
}

void SQLiteParser::Cte_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_table_name(this);
}


std::any SQLiteParser::Cte_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCte_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::cte_table_name() {
  Cte_table_nameContext *_localctx = _tracker.createInstance<Cte_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 50, SQLiteParser::RuleCte_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(781);
    table_name();
    setState(793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(782);
      match(SQLiteParser::OPEN_PAR);
      setState(783);
      column_name();
      setState(788);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(784);
        match(SQLiteParser::COMMA);
        setState(785);
        column_name();
        setState(790);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(791);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_cteContext ------------------------------------------------------------------

SQLiteParser::Recursive_cteContext::Recursive_cteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::Recursive_cteContext::cte_table_name() {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Initial_selectContext* SQLiteParser::Recursive_cteContext::initial_select() {
  return getRuleContext<SQLiteParser::Initial_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::Recursive_cteContext::recursive_select() {
  return getRuleContext<SQLiteParser::Recursive_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}


size_t SQLiteParser::Recursive_cteContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_cte;
}

void SQLiteParser::Recursive_cteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_cte(this);
}

void SQLiteParser::Recursive_cteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_cte(this);
}


std::any SQLiteParser::Recursive_cteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_cte(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_cteContext* SQLiteParser::recursive_cte() {
  Recursive_cteContext *_localctx = _tracker.createInstance<Recursive_cteContext>(_ctx, getState());
  enterRule(_localctx, 52, SQLiteParser::RuleRecursive_cte);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    cte_table_name();
    setState(796);
    match(SQLiteParser::AS_);
    setState(797);
    match(SQLiteParser::OPEN_PAR);
    setState(798);
    initial_select();
    setState(799);
    match(SQLiteParser::UNION_);
    setState(801);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ALL_) {
      setState(800);
      match(SQLiteParser::ALL_);
    }
    setState(803);
    recursive_select();
    setState(804);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

SQLiteParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Common_table_expressionContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Common_table_expressionContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Common_table_expressionContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Common_table_expressionContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Common_table_expressionContext::getRuleIndex() const {
  return SQLiteParser::RuleCommon_table_expression;
}

void SQLiteParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void SQLiteParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}


std::any SQLiteParser::Common_table_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expression(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 54, SQLiteParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    table_name();
    setState(818);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(807);
      match(SQLiteParser::OPEN_PAR);
      setState(808);
      column_name();
      setState(813);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(809);
        match(SQLiteParser::COMMA);
        setState(810);
        column_name();
        setState(815);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(816);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(820);
    match(SQLiteParser::AS_);
    setState(821);
    match(SQLiteParser::OPEN_PAR);
    setState(822);
    select_stmt();
    setState(823);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

SQLiteParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}


size_t SQLiteParser::Delete_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt;
}

void SQLiteParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void SQLiteParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


std::any SQLiteParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, SQLiteParser::RuleDelete_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(825);
      with_clause();
    }
    setState(828);
    match(SQLiteParser::DELETE_);
    setState(829);
    match(SQLiteParser::FROM_);
    setState(830);
    qualified_table_name();
    setState(833);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(831);
      match(SQLiteParser::WHERE_);
      setState(832);
      expr(0);
    }
    setState(836);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(835);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Delete_stmt_limitedContext::Delete_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmt_limitedContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Delete_stmt_limitedContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Delete_stmt_limitedContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}


size_t SQLiteParser::Delete_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt_limited;
}

void SQLiteParser::Delete_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt_limited(this);
}

void SQLiteParser::Delete_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt_limited(this);
}


std::any SQLiteParser::Delete_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::delete_stmt_limited() {
  Delete_stmt_limitedContext *_localctx = _tracker.createInstance<Delete_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 58, SQLiteParser::RuleDelete_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(838);
      with_clause();
    }
    setState(841);
    match(SQLiteParser::DELETE_);
    setState(842);
    match(SQLiteParser::FROM_);
    setState(843);
    qualified_table_name();
    setState(846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(844);
      match(SQLiteParser::WHERE_);
      setState(845);
      expr(0);
    }
    setState(849);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(848);
      returning_clause();
    }
    setState(855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_

    || _la == SQLiteParser::ORDER_) {
      setState(852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(851);
        order_by_stmt();
      }
      setState(854);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Detach_stmtContext ------------------------------------------------------------------

SQLiteParser::Detach_stmtContext::Detach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Detach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Detach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDetach_stmt;
}

void SQLiteParser::Detach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDetach_stmt(this);
}

void SQLiteParser::Detach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDetach_stmt(this);
}


std::any SQLiteParser::Detach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDetach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::detach_stmt() {
  Detach_stmtContext *_localctx = _tracker.createInstance<Detach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 60, SQLiteParser::RuleDetach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(857);
    match(SQLiteParser::DETACH_);
    setState(859);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(858);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(861);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

SQLiteParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

SQLiteParser::Any_nameContext* SQLiteParser::Drop_stmtContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Drop_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Drop_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDrop_stmt;
}

void SQLiteParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void SQLiteParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


std::any SQLiteParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 62, SQLiteParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(863);
    match(SQLiteParser::DROP_);
    setState(864);
    antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 2324138882699886593) != 0))) {
      antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(867);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(865);
      match(SQLiteParser::IF_);
      setState(866);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(872);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(869);
      schema_name();
      setState(870);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(874);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

SQLiteParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Literal_valueContext* SQLiteParser::ExprContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::BIND_PARAMETER() {
  return getToken(SQLiteParser::BIND_PARAMETER, 0);
}

SQLiteParser::Column_nameContext* SQLiteParser::ExprContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::ExprContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::DOT() {
  return getTokens(SQLiteParser::DOT);
}

tree::TerminalNode* SQLiteParser::ExprContext::DOT(size_t i) {
  return getToken(SQLiteParser::DOT, i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::ExprContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

SQLiteParser::Unary_operatorContext* SQLiteParser::ExprContext::unary_operator() {
  return getRuleContext<SQLiteParser::Unary_operatorContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::ExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::ExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

SQLiteParser::Function_nameContext* SQLiteParser::ExprContext::function_name() {
  return getRuleContext<SQLiteParser::Function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::ExprContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

SQLiteParser::Over_clauseContext* SQLiteParser::ExprContext::over_clause() {
  return getRuleContext<SQLiteParser::Over_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::ExprContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::ExprContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Type_nameContext* SQLiteParser::ExprContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::ExprContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::WHEN_() {
  return getTokens(SQLiteParser::WHEN_);
}

tree::TerminalNode* SQLiteParser::ExprContext::WHEN_(size_t i) {
  return getToken(SQLiteParser::WHEN_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::ExprContext::THEN_() {
  return getTokens(SQLiteParser::THEN_);
}

tree::TerminalNode* SQLiteParser::ExprContext::THEN_(size_t i) {
  return getToken(SQLiteParser::THEN_, i);
}

tree::TerminalNode* SQLiteParser::ExprContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

SQLiteParser::Raise_functionContext* SQLiteParser::ExprContext::raise_function() {
  return getRuleContext<SQLiteParser::Raise_functionContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PIPE2() {
  return getToken(SQLiteParser::PIPE2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::DIV() {
  return getToken(SQLiteParser::DIV, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::MOD() {
  return getToken(SQLiteParser::MOD, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT2() {
  return getToken(SQLiteParser::LT2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT2() {
  return getToken(SQLiteParser::GT2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AMP() {
  return getToken(SQLiteParser::AMP, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::PIPE() {
  return getToken(SQLiteParser::PIPE, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT() {
  return getToken(SQLiteParser::LT, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LT_EQ() {
  return getToken(SQLiteParser::LT_EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT() {
  return getToken(SQLiteParser::GT, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GT_EQ() {
  return getToken(SQLiteParser::GT_EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::EQ() {
  return getToken(SQLiteParser::EQ, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_EQ1() {
  return getToken(SQLiteParser::NOT_EQ1, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOT_EQ2() {
  return getToken(SQLiteParser::NOT_EQ2, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::ExprContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::ExprContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::ExprContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}


size_t SQLiteParser::ExprContext::getRuleIndex() const {
  return SQLiteParser::RuleExpr;
}

void SQLiteParser::ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr(this);
}

void SQLiteParser::ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr(this);
}


std::any SQLiteParser::ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitExpr(this);
  else
    return visitor->visitChildren(this);
}


SQLiteParser::ExprContext* SQLiteParser::expr() {
   return expr(0);
}

SQLiteParser::ExprContext* SQLiteParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SQLiteParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  SQLiteParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 64;
  enterRecursionRule(_localctx, 64, SQLiteParser::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(964);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(877);
      literal_value();
      break;
    }

    case 2: {
      setState(878);
      match(SQLiteParser::BIND_PARAMETER);
      break;
    }

    case 3: {
      setState(887);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
      case 1: {
        setState(882);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
        case 1: {
          setState(879);
          schema_name();
          setState(880);
          match(SQLiteParser::DOT);
          break;
        }

        default:
          break;
        }
        setState(884);
        table_name();
        setState(885);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(889);
      column_name();
      break;
    }

    case 4: {
      setState(890);
      unary_operator();
      setState(891);
      expr(21);
      break;
    }

    case 5: {
      setState(893);
      function_name();
      setState(894);
      match(SQLiteParser::OPEN_PAR);
      setState(907);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::OPEN_PAR:
        case SQLiteParser::PLUS:
        case SQLiteParser::MINUS:
        case SQLiteParser::TILDE:
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::FIRST_VALUE_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::CUME_DIST_:
        case SQLiteParser::DENSE_RANK_:
        case SQLiteParser::LAG_:
        case SQLiteParser::LAST_VALUE_:
        case SQLiteParser::LEAD_:
        case SQLiteParser::NTH_VALUE_:
        case SQLiteParser::NTILE_:
        case SQLiteParser::PERCENT_RANK_:
        case SQLiteParser::RANK_:
        case SQLiteParser::ROW_NUMBER_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::NUMERIC_LITERAL:
        case SQLiteParser::BIND_PARAMETER:
        case SQLiteParser::STRING_LITERAL:
        case SQLiteParser::BLOB_LITERAL: {
          setState(896);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
          case 1: {
            setState(895);
            match(SQLiteParser::DISTINCT_);
            break;
          }

          default:
            break;
          }
          setState(898);
          expr(0);
          setState(903);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(899);
            match(SQLiteParser::COMMA);
            setState(900);
            expr(0);
            setState(905);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case SQLiteParser::STAR: {
          setState(906);
          match(SQLiteParser::STAR);
          break;
        }

        case SQLiteParser::CLOSE_PAR: {
          break;
        }

      default:
        break;
      }
      setState(909);
      match(SQLiteParser::CLOSE_PAR);
      setState(911);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(910);
        filter_clause();
        break;
      }

      default:
        break;
      }
      setState(914);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(913);
        over_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      setState(916);
      match(SQLiteParser::OPEN_PAR);
      setState(917);
      expr(0);
      setState(922);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(918);
        match(SQLiteParser::COMMA);
        setState(919);
        expr(0);
        setState(924);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(925);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 7: {
      setState(927);
      match(SQLiteParser::CAST_);
      setState(928);
      match(SQLiteParser::OPEN_PAR);
      setState(929);
      expr(0);
      setState(930);
      match(SQLiteParser::AS_);
      setState(931);
      type_name();
      setState(932);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 8: {
      setState(938);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::EXISTS_

      || _la == SQLiteParser::NOT_) {
        setState(935);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NOT_) {
          setState(934);
          match(SQLiteParser::NOT_);
        }
        setState(937);
        match(SQLiteParser::EXISTS_);
      }
      setState(940);
      match(SQLiteParser::OPEN_PAR);
      setState(941);
      select_stmt();
      setState(942);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 9: {
      setState(944);
      match(SQLiteParser::CASE_);
      setState(946);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
      case 1: {
        setState(945);
        expr(0);
        break;
      }

      default:
        break;
      }
      setState(953); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(948);
        match(SQLiteParser::WHEN_);
        setState(949);
        expr(0);
        setState(950);
        match(SQLiteParser::THEN_);
        setState(951);
        expr(0);
        setState(955); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SQLiteParser::WHEN_);
      setState(959);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ELSE_) {
        setState(957);
        match(SQLiteParser::ELSE_);
        setState(958);
        expr(0);
      }
      setState(961);
      match(SQLiteParser::END_);
      break;
    }

    case 10: {
      setState(963);
      raise_function();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1091);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1089);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(966);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(967);
          match(SQLiteParser::PIPE2);
          setState(968);
          expr(21);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(969);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(970);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 12416) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(971);
          expr(20);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(972);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(973);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::PLUS

          || _la == SQLiteParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(974);
          expr(19);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(975);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(976);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 245760) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(977);
          expr(18);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(978);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(979);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 3932160) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(980);
          expr(17);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(981);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(1000);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
          case 1: {
            setState(982);
            match(SQLiteParser::ASSIGN);
            break;
          }

          case 2: {
            setState(983);
            match(SQLiteParser::EQ);
            break;
          }

          case 3: {
            setState(984);
            match(SQLiteParser::NOT_EQ1);
            break;
          }

          case 4: {
            setState(985);
            match(SQLiteParser::NOT_EQ2);
            break;
          }

          case 5: {
            setState(986);
            match(SQLiteParser::IS_);
            break;
          }

          case 6: {
            setState(987);
            match(SQLiteParser::IS_);
            setState(988);
            match(SQLiteParser::NOT_);
            break;
          }

          case 7: {
            setState(989);
            match(SQLiteParser::IS_);
            setState(991);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::NOT_) {
              setState(990);
              match(SQLiteParser::NOT_);
            }
            setState(993);
            match(SQLiteParser::DISTINCT_);
            setState(994);
            match(SQLiteParser::FROM_);
            break;
          }

          case 8: {
            setState(995);
            match(SQLiteParser::IN_);
            break;
          }

          case 9: {
            setState(996);
            match(SQLiteParser::LIKE_);
            break;
          }

          case 10: {
            setState(997);
            match(SQLiteParser::GLOB_);
            break;
          }

          case 11: {
            setState(998);
            match(SQLiteParser::MATCH_);
            break;
          }

          case 12: {
            setState(999);
            match(SQLiteParser::REGEXP_);
            break;
          }

          default:
            break;
          }
          setState(1002);
          expr(16);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1003);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(1004);
          match(SQLiteParser::AND_);
          setState(1005);
          expr(15);
          break;
        }

        case 8: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1006);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(1007);
          match(SQLiteParser::OR_);
          setState(1008);
          expr(14);
          break;
        }

        case 9: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1009);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(1010);
          match(SQLiteParser::IS_);
          setState(1012);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
          case 1: {
            setState(1011);
            match(SQLiteParser::NOT_);
            break;
          }

          default:
            break;
          }
          setState(1014);
          expr(7);
          break;
        }

        case 10: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1015);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(1017);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1016);
            match(SQLiteParser::NOT_);
          }
          setState(1019);
          match(SQLiteParser::BETWEEN_);
          setState(1020);
          expr(0);
          setState(1021);
          match(SQLiteParser::AND_);
          setState(1022);
          expr(6);
          break;
        }

        case 11: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1024);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(1025);
          match(SQLiteParser::COLLATE_);
          setState(1026);
          collation_name();
          break;
        }

        case 12: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1027);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1029);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1028);
            match(SQLiteParser::NOT_);
          }
          setState(1031);
          _la = _input->LA(1);
          if (!(((((_la - 77) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 77)) & 2199028498433) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1032);
          expr(0);
          setState(1035);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
          case 1: {
            setState(1033);
            match(SQLiteParser::ESCAPE_);
            setState(1034);
            expr(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        case 13: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1037);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(1042);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::ISNULL_: {
              setState(1038);
              match(SQLiteParser::ISNULL_);
              break;
            }

            case SQLiteParser::NOTNULL_: {
              setState(1039);
              match(SQLiteParser::NOTNULL_);
              break;
            }

            case SQLiteParser::NOT_: {
              setState(1040);
              match(SQLiteParser::NOT_);
              setState(1041);
              match(SQLiteParser::NULL_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 14: {
          _localctx = _tracker.createInstance<ExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleExpr);
          setState(1044);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1046);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1045);
            match(SQLiteParser::NOT_);
          }
          setState(1048);
          match(SQLiteParser::IN_);
          setState(1087);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
          case 1: {
            setState(1049);
            match(SQLiteParser::OPEN_PAR);
            setState(1059);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
            case 1: {
              setState(1050);
              select_stmt();
              break;
            }

            case 2: {
              setState(1051);
              expr(0);
              setState(1056);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(1052);
                match(SQLiteParser::COMMA);
                setState(1053);
                expr(0);
                setState(1058);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
              break;
            }

            default:
              break;
            }
            setState(1061);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          case 2: {
            setState(1065);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
            case 1: {
              setState(1062);
              schema_name();
              setState(1063);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(1067);
            table_name();
            break;
          }

          case 3: {
            setState(1071);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx)) {
            case 1: {
              setState(1068);
              schema_name();
              setState(1069);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(1073);
            table_function_name();
            setState(1074);
            match(SQLiteParser::OPEN_PAR);
            setState(1083);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & -33552632) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 128)) & 4476578029606273023) != 0)) {
              setState(1075);
              expr(0);
              setState(1080);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(1076);
                match(SQLiteParser::COMMA);
                setState(1077);
                expr(0);
                setState(1082);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
            }
            setState(1085);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(1093);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Raise_functionContext ------------------------------------------------------------------

SQLiteParser::Raise_functionContext::Raise_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Error_messageContext* SQLiteParser::Raise_functionContext::error_message() {
  return getRuleContext<SQLiteParser::Error_messageContext>(0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}


size_t SQLiteParser::Raise_functionContext::getRuleIndex() const {
  return SQLiteParser::RuleRaise_function;
}

void SQLiteParser::Raise_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_function(this);
}

void SQLiteParser::Raise_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_function(this);
}


std::any SQLiteParser::Raise_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRaise_function(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Raise_functionContext* SQLiteParser::raise_function() {
  Raise_functionContext *_localctx = _tracker.createInstance<Raise_functionContext>(_ctx, getState());
  enterRule(_localctx, 66, SQLiteParser::RuleRaise_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1094);
    match(SQLiteParser::RAISE_);
    setState(1095);
    match(SQLiteParser::OPEN_PAR);
    setState(1100);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IGNORE_: {
        setState(1096);
        match(SQLiteParser::IGNORE_);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::ROLLBACK_: {
        setState(1097);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::ABORT_ || _la == SQLiteParser::FAIL_

        || _la == SQLiteParser::ROLLBACK_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1098);
        match(SQLiteParser::COMMA);
        setState(1099);
        error_message();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1102);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_valueContext ------------------------------------------------------------------

SQLiteParser::Literal_valueContext::Literal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::BLOB_LITERAL() {
  return getToken(SQLiteParser::BLOB_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}


size_t SQLiteParser::Literal_valueContext::getRuleIndex() const {
  return SQLiteParser::RuleLiteral_value;
}

void SQLiteParser::Literal_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_value(this);
}

void SQLiteParser::Literal_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_value(this);
}


std::any SQLiteParser::Literal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLiteral_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Literal_valueContext* SQLiteParser::literal_value() {
  Literal_valueContext *_localctx = _tracker.createInstance<Literal_valueContext>(_ctx, getState());
  enterRule(_localctx, 68, SQLiteParser::RuleLiteral_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1104);
    _la = _input->LA(1);
    if (!(((((_la - 52) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 52)) & 4503599627370503) != 0) || ((((_la - 172) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 172)) & 212995) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_rowContext ------------------------------------------------------------------

SQLiteParser::Value_rowContext::Value_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Value_rowContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Value_rowContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Value_rowContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Value_rowContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Value_rowContext::getRuleIndex() const {
  return SQLiteParser::RuleValue_row;
}

void SQLiteParser::Value_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_row(this);
}

void SQLiteParser::Value_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_row(this);
}


std::any SQLiteParser::Value_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValue_row(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Value_rowContext* SQLiteParser::value_row() {
  Value_rowContext *_localctx = _tracker.createInstance<Value_rowContext>(_ctx, getState());
  enterRule(_localctx, 70, SQLiteParser::RuleValue_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1106);
    match(SQLiteParser::OPEN_PAR);
    setState(1107);
    expr(0);
    setState(1112);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1108);
      match(SQLiteParser::COMMA);
      setState(1109);
      expr(0);
      setState(1114);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1115);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_clauseContext ------------------------------------------------------------------

SQLiteParser::Values_clauseContext::Values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

std::vector<SQLiteParser::Value_rowContext *> SQLiteParser::Values_clauseContext::value_row() {
  return getRuleContexts<SQLiteParser::Value_rowContext>();
}

SQLiteParser::Value_rowContext* SQLiteParser::Values_clauseContext::value_row(size_t i) {
  return getRuleContext<SQLiteParser::Value_rowContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Values_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Values_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleValues_clause;
}

void SQLiteParser::Values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues_clause(this);
}

void SQLiteParser::Values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues_clause(this);
}


std::any SQLiteParser::Values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValues_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Values_clauseContext* SQLiteParser::values_clause() {
  Values_clauseContext *_localctx = _tracker.createInstance<Values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 72, SQLiteParser::RuleValues_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1117);
    match(SQLiteParser::VALUES_);
    setState(1118);
    value_row();
    setState(1123);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1119);
      match(SQLiteParser::COMMA);
      setState(1120);
      value_row();
      setState(1125);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmtContext ------------------------------------------------------------------

SQLiteParser::Insert_stmtContext::Insert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Insert_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Insert_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Insert_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::Insert_stmtContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Insert_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Insert_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Insert_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Insert_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Insert_stmtContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Insert_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::Insert_stmtContext::upsert_clause() {
  return getRuleContext<SQLiteParser::Upsert_clauseContext>(0);
}


size_t SQLiteParser::Insert_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleInsert_stmt;
}

void SQLiteParser::Insert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt(this);
}

void SQLiteParser::Insert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt(this);
}


std::any SQLiteParser::Insert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::insert_stmt() {
  Insert_stmtContext *_localctx = _tracker.createInstance<Insert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, SQLiteParser::RuleInsert_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1127);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1126);
      with_clause();
    }
    setState(1134);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1129);
      match(SQLiteParser::INSERT_);
      break;
    }

    case 2: {
      setState(1130);
      match(SQLiteParser::REPLACE_);
      break;
    }

    case 3: {
      setState(1131);
      match(SQLiteParser::INSERT_);
      setState(1132);
      match(SQLiteParser::OR_);
      setState(1133);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1136);
    match(SQLiteParser::INTO_);
    setState(1140);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
    case 1: {
      setState(1137);
      schema_name();
      setState(1138);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1142);
    table_name();
    setState(1145);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1143);
      match(SQLiteParser::AS_);
      setState(1144);
      table_alias();
    }
    setState(1158);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1147);
      match(SQLiteParser::OPEN_PAR);
      setState(1148);
      column_name();
      setState(1153);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1149);
        match(SQLiteParser::COMMA);
        setState(1150);
        column_name();
        setState(1155);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1156);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(1169);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WITH_: {
        setState(1162);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
        case 1: {
          setState(1160);
          values_clause();
          break;
        }

        case 2: {
          setState(1161);
          select_stmt();
          break;
        }

        default:
          break;
        }
        setState(1165);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(1164);
          upsert_clause();
        }
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(1167);
        match(SQLiteParser::DEFAULT_);
        setState(1168);
        match(SQLiteParser::VALUES_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1172);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1171);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returning_clauseContext ------------------------------------------------------------------

SQLiteParser::Returning_clauseContext::Returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::RETURNING_() {
  return getToken(SQLiteParser::RETURNING_, 0);
}

std::vector<SQLiteParser::Result_columnContext *> SQLiteParser::Returning_clauseContext::result_column() {
  return getRuleContexts<SQLiteParser::Result_columnContext>();
}

SQLiteParser::Result_columnContext* SQLiteParser::Returning_clauseContext::result_column(size_t i) {
  return getRuleContext<SQLiteParser::Result_columnContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Returning_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Returning_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleReturning_clause;
}

void SQLiteParser::Returning_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturning_clause(this);
}

void SQLiteParser::Returning_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturning_clause(this);
}


std::any SQLiteParser::Returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReturning_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::returning_clause() {
  Returning_clauseContext *_localctx = _tracker.createInstance<Returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 76, SQLiteParser::RuleReturning_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1174);
    match(SQLiteParser::RETURNING_);
    setState(1175);
    result_column();
    setState(1180);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1176);
      match(SQLiteParser::COMMA);
      setState(1177);
      result_column();
      setState(1182);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Upsert_clauseContext ------------------------------------------------------------------

SQLiteParser::Upsert_clauseContext::Upsert_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::DO_() {
  return getToken(SQLiteParser::DO_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::NOTHING_() {
  return getToken(SQLiteParser::NOTHING_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Upsert_clauseContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Upsert_clauseContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Upsert_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Upsert_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::WHERE_() {
  return getTokens(SQLiteParser::WHERE_);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::WHERE_(size_t i) {
  return getToken(SQLiteParser::WHERE_, i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Upsert_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Upsert_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Upsert_clauseContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Upsert_clauseContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}


size_t SQLiteParser::Upsert_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleUpsert_clause;
}

void SQLiteParser::Upsert_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpsert_clause(this);
}

void SQLiteParser::Upsert_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpsert_clause(this);
}


std::any SQLiteParser::Upsert_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpsert_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::upsert_clause() {
  Upsert_clauseContext *_localctx = _tracker.createInstance<Upsert_clauseContext>(_ctx, getState());
  enterRule(_localctx, 78, SQLiteParser::RuleUpsert_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1183);
    match(SQLiteParser::ON_);
    setState(1184);
    match(SQLiteParser::CONFLICT_);
    setState(1199);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1185);
      match(SQLiteParser::OPEN_PAR);
      setState(1186);
      indexed_column();
      setState(1191);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1187);
        match(SQLiteParser::COMMA);
        setState(1188);
        indexed_column();
        setState(1193);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1194);
      match(SQLiteParser::CLOSE_PAR);
      setState(1197);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::WHERE_) {
        setState(1195);
        match(SQLiteParser::WHERE_);
        setState(1196);
        expr(0);
      }
    }
    setState(1201);
    match(SQLiteParser::DO_);
    setState(1228);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::NOTHING_: {
        setState(1202);
        match(SQLiteParser::NOTHING_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(1203);
        match(SQLiteParser::UPDATE_);
        setState(1204);
        match(SQLiteParser::SET_);

        setState(1207);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
        case 1: {
          setState(1205);
          column_name();
          break;
        }

        case 2: {
          setState(1206);
          column_name_list();
          break;
        }

        default:
          break;
        }
        setState(1209);
        match(SQLiteParser::ASSIGN);
        setState(1210);
        expr(0);
        setState(1221);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1211);
          match(SQLiteParser::COMMA);
          setState(1214);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
          case 1: {
            setState(1212);
            column_name();
            break;
          }

          case 2: {
            setState(1213);
            column_name_list();
            break;
          }

          default:
            break;
          }
          setState(1216);
          match(SQLiteParser::ASSIGN);
          setState(1217);
          expr(0);
          setState(1223);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1226);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1224);
          match(SQLiteParser::WHERE_);
          setState(1225);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_stmtContext ------------------------------------------------------------------

SQLiteParser::Pragma_stmtContext::Pragma_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::Pragma_stmtContext::pragma_name() {
  return getRuleContext<SQLiteParser::Pragma_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Pragma_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::Pragma_stmtContext::pragma_value() {
  return getRuleContext<SQLiteParser::Pragma_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Pragma_stmtContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_stmt;
}

void SQLiteParser::Pragma_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_stmt(this);
}

void SQLiteParser::Pragma_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_stmt(this);
}


std::any SQLiteParser::Pragma_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::pragma_stmt() {
  Pragma_stmtContext *_localctx = _tracker.createInstance<Pragma_stmtContext>(_ctx, getState());
  enterRule(_localctx, 80, SQLiteParser::RulePragma_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1230);
    match(SQLiteParser::PRAGMA_);
    setState(1234);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
    case 1: {
      setState(1231);
      schema_name();
      setState(1232);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1236);
    pragma_name();
    setState(1243);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ASSIGN: {
        setState(1237);
        match(SQLiteParser::ASSIGN);
        setState(1238);
        pragma_value();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1239);
        match(SQLiteParser::OPEN_PAR);
        setState(1240);
        pragma_value();
        setState(1241);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DROP_:
      case SQLiteParser::END_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WITH_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_valueContext ------------------------------------------------------------------

SQLiteParser::Pragma_valueContext::Pragma_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Signed_numberContext* SQLiteParser::Pragma_valueContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::NameContext* SQLiteParser::Pragma_valueContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Pragma_valueContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_value;
}

void SQLiteParser::Pragma_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_value(this);
}

void SQLiteParser::Pragma_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_value(this);
}


std::any SQLiteParser::Pragma_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::pragma_value() {
  Pragma_valueContext *_localctx = _tracker.createInstance<Pragma_valueContext>(_ctx, getState());
  enterRule(_localctx, 82, SQLiteParser::RulePragma_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1248);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1245);
      signed_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1246);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1247);
      match(SQLiteParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_stmtContext ------------------------------------------------------------------

SQLiteParser::Reindex_stmtContext::Reindex_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Reindex_stmtContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Reindex_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Reindex_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Reindex_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Reindex_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleReindex_stmt;
}

void SQLiteParser::Reindex_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReindex_stmt(this);
}

void SQLiteParser::Reindex_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReindex_stmt(this);
}


std::any SQLiteParser::Reindex_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReindex_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::reindex_stmt() {
  Reindex_stmtContext *_localctx = _tracker.createInstance<Reindex_stmtContext>(_ctx, getState());
  enterRule(_localctx, 84, SQLiteParser::RuleReindex_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1250);
    match(SQLiteParser::REINDEX_);
    setState(1261);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(1251);
      collation_name();
      break;
    }

    case 2: {
      setState(1255);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
      case 1: {
        setState(1252);
        schema_name();
        setState(1253);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1259);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
      case 1: {
        setState(1257);
        table_name();
        break;
      }

      case 2: {
        setState(1258);
        index_name();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_stmtContext ------------------------------------------------------------------

SQLiteParser::Select_stmtContext::Select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

std::vector<SQLiteParser::Compound_operatorContext *> SQLiteParser::Select_stmtContext::compound_operator() {
  return getRuleContexts<SQLiteParser::Compound_operatorContext>();
}

SQLiteParser::Compound_operatorContext* SQLiteParser::Select_stmtContext::compound_operator(size_t i) {
  return getRuleContext<SQLiteParser::Compound_operatorContext>(i);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}


size_t SQLiteParser::Select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_stmt;
}

void SQLiteParser::Select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_stmt(this);
}

void SQLiteParser::Select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_stmt(this);
}


std::any SQLiteParser::Select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_stmtContext* SQLiteParser::select_stmt() {
  Select_stmtContext *_localctx = _tracker.createInstance<Select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 86, SQLiteParser::RuleSelect_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1264);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1263);
      common_table_stmt();
    }
    setState(1266);
    select_core();
    setState(1272);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1267);
        compound_operator();
        setState(1268);
        select_core(); 
      }
      setState(1274);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx);
    }
    setState(1276);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1275);
      order_by_stmt();
    }
    setState(1279);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1278);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_clauseContext ------------------------------------------------------------------

SQLiteParser::Join_clauseContext::Join_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Join_clauseContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Join_clauseContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

std::vector<SQLiteParser::Join_operatorContext *> SQLiteParser::Join_clauseContext::join_operator() {
  return getRuleContexts<SQLiteParser::Join_operatorContext>();
}

SQLiteParser::Join_operatorContext* SQLiteParser::Join_clauseContext::join_operator(size_t i) {
  return getRuleContext<SQLiteParser::Join_operatorContext>(i);
}

std::vector<SQLiteParser::Join_constraintContext *> SQLiteParser::Join_clauseContext::join_constraint() {
  return getRuleContexts<SQLiteParser::Join_constraintContext>();
}

SQLiteParser::Join_constraintContext* SQLiteParser::Join_clauseContext::join_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Join_constraintContext>(i);
}


size_t SQLiteParser::Join_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_clause;
}

void SQLiteParser::Join_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_clause(this);
}

void SQLiteParser::Join_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_clause(this);
}


std::any SQLiteParser::Join_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_clauseContext* SQLiteParser::join_clause() {
  Join_clauseContext *_localctx = _tracker.createInstance<Join_clauseContext>(_ctx, getState());
  enterRule(_localctx, 88, SQLiteParser::RuleJoin_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1281);
    table_or_subquery();
    setState(1289);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA

    || _la == SQLiteParser::CROSS_ || ((((_la - 76) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 76)) & 562949971511297) != 0)) {
      setState(1282);
      join_operator();
      setState(1283);
      table_or_subquery();
      setState(1285);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 171, _ctx)) {
      case 1: {
        setState(1284);
        join_constraint();
        break;
      }

      default:
        break;
      }
      setState(1291);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_coreContext ------------------------------------------------------------------

SQLiteParser::Select_coreContext::Select_coreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Select_coreContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

std::vector<SQLiteParser::Result_columnContext *> SQLiteParser::Select_coreContext::result_column() {
  return getRuleContexts<SQLiteParser::Result_columnContext>();
}

SQLiteParser::Result_columnContext* SQLiteParser::Select_coreContext::result_column(size_t i) {
  return getRuleContext<SQLiteParser::Result_columnContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

std::vector<SQLiteParser::Window_nameContext *> SQLiteParser::Select_coreContext::window_name() {
  return getRuleContexts<SQLiteParser::Window_nameContext>();
}

SQLiteParser::Window_nameContext* SQLiteParser::Select_coreContext::window_name(size_t i) {
  return getRuleContext<SQLiteParser::Window_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}

std::vector<SQLiteParser::Window_defnContext *> SQLiteParser::Select_coreContext::window_defn() {
  return getRuleContexts<SQLiteParser::Window_defnContext>();
}

SQLiteParser::Window_defnContext* SQLiteParser::Select_coreContext::window_defn(size_t i) {
  return getRuleContext<SQLiteParser::Window_defnContext>(i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Select_coreContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Select_coreContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Select_coreContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Select_coreContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Select_coreContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Select_coreContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}


size_t SQLiteParser::Select_coreContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_core;
}

void SQLiteParser::Select_coreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_core(this);
}

void SQLiteParser::Select_coreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_core(this);
}


std::any SQLiteParser::Select_coreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_core(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_coreContext* SQLiteParser::select_core() {
  Select_coreContext *_localctx = _tracker.createInstance<Select_coreContext>(_ctx, getState());
  enterRule(_localctx, 90, SQLiteParser::RuleSelect_core);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1355);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_: {
        enterOuterAlt(_localctx, 1);
        setState(1292);
        match(SQLiteParser::SELECT_);
        setState(1294);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
        case 1: {
          setState(1293);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::ALL_

          || _la == SQLiteParser::DISTINCT_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(1296);
        result_column();
        setState(1301);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1297);
          match(SQLiteParser::COMMA);
          setState(1298);
          result_column();
          setState(1303);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1316);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::FROM_) {
          setState(1304);
          match(SQLiteParser::FROM_);
          setState(1314);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 176, _ctx)) {
          case 1: {
            setState(1305);
            table_or_subquery();
            setState(1310);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == SQLiteParser::COMMA) {
              setState(1306);
              match(SQLiteParser::COMMA);
              setState(1307);
              table_or_subquery();
              setState(1312);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

          case 2: {
            setState(1313);
            join_clause();
            break;
          }

          default:
            break;
          }
        }
        setState(1320);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1318);
          match(SQLiteParser::WHERE_);
          setState(1319);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->whereExpr = expr(0);
        }
        setState(1336);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GROUP_) {
          setState(1322);
          match(SQLiteParser::GROUP_);
          setState(1323);
          match(SQLiteParser::BY_);
          setState(1324);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->groupByExpr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
          setState(1329);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1325);
            match(SQLiteParser::COMMA);
            setState(1326);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->groupByExpr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
            setState(1331);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1334);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::HAVING_) {
            setState(1332);
            match(SQLiteParser::HAVING_);
            setState(1333);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->havingExpr = expr(0);
          }
        }
        setState(1352);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WINDOW_) {
          setState(1338);
          match(SQLiteParser::WINDOW_);
          setState(1339);
          window_name();
          setState(1340);
          match(SQLiteParser::AS_);
          setState(1341);
          window_defn();
          setState(1349);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1342);
            match(SQLiteParser::COMMA);
            setState(1343);
            window_name();
            setState(1344);
            match(SQLiteParser::AS_);
            setState(1345);
            window_defn();
            setState(1351);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

      case SQLiteParser::VALUES_: {
        enterOuterAlt(_localctx, 2);
        setState(1354);
        values_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Factored_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Factored_select_stmtContext::Factored_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Factored_select_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Factored_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleFactored_select_stmt;
}

void SQLiteParser::Factored_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactored_select_stmt(this);
}

void SQLiteParser::Factored_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactored_select_stmt(this);
}


std::any SQLiteParser::Factored_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFactored_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Factored_select_stmtContext* SQLiteParser::factored_select_stmt() {
  Factored_select_stmtContext *_localctx = _tracker.createInstance<Factored_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 92, SQLiteParser::RuleFactored_select_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1357);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Simple_select_stmtContext::Simple_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_coreContext* SQLiteParser::Simple_select_stmtContext::select_core() {
  return getRuleContext<SQLiteParser::Select_coreContext>(0);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Simple_select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Simple_select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Simple_select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}


size_t SQLiteParser::Simple_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_select_stmt;
}

void SQLiteParser::Simple_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_select_stmt(this);
}

void SQLiteParser::Simple_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_select_stmt(this);
}


std::any SQLiteParser::Simple_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_select_stmtContext* SQLiteParser::simple_select_stmt() {
  Simple_select_stmtContext *_localctx = _tracker.createInstance<Simple_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 94, SQLiteParser::RuleSimple_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1360);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1359);
      common_table_stmt();
    }
    setState(1362);
    select_core();
    setState(1364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1363);
      order_by_stmt();
    }
    setState(1367);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1366);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Compound_select_stmtContext::Compound_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Compound_select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Compound_select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Compound_select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Compound_select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Compound_select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::UNION_() {
  return getTokens(SQLiteParser::UNION_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::UNION_(size_t i) {
  return getToken(SQLiteParser::UNION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::INTERSECT_() {
  return getTokens(SQLiteParser::INTERSECT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::INTERSECT_(size_t i) {
  return getToken(SQLiteParser::INTERSECT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::EXCEPT_() {
  return getTokens(SQLiteParser::EXCEPT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::EXCEPT_(size_t i) {
  return getToken(SQLiteParser::EXCEPT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::ALL_() {
  return getTokens(SQLiteParser::ALL_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::ALL_(size_t i) {
  return getToken(SQLiteParser::ALL_, i);
}


size_t SQLiteParser::Compound_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_select_stmt;
}

void SQLiteParser::Compound_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_select_stmt(this);
}

void SQLiteParser::Compound_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_select_stmt(this);
}


std::any SQLiteParser::Compound_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_select_stmtContext* SQLiteParser::compound_select_stmt() {
  Compound_select_stmtContext *_localctx = _tracker.createInstance<Compound_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 96, SQLiteParser::RuleCompound_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1370);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1369);
      common_table_stmt();
    }
    setState(1372);
    select_core();
    setState(1382); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1379);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::UNION_: {
          setState(1373);
          match(SQLiteParser::UNION_);
          setState(1375);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::ALL_) {
            setState(1374);
            match(SQLiteParser::ALL_);
          }
          break;
        }

        case SQLiteParser::INTERSECT_: {
          setState(1377);
          match(SQLiteParser::INTERSECT_);
          break;
        }

        case SQLiteParser::EXCEPT_: {
          setState(1378);
          match(SQLiteParser::EXCEPT_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1381);
      select_core();
      setState(1384); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::EXCEPT_

    || _la == SQLiteParser::INTERSECT_ || _la == SQLiteParser::UNION_);
    setState(1387);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1386);
      order_by_stmt();
    }
    setState(1390);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1389);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_subqueryContext ------------------------------------------------------------------

SQLiteParser::Table_or_subqueryContext::Table_or_subqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Table_or_subqueryContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Table_or_subqueryContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::Table_or_subqueryContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Table_or_subqueryContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::Table_or_subqueryContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Table_or_subqueryContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Table_or_subqueryContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_or_subqueryContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_or_subqueryContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Table_or_subqueryContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Table_or_subqueryContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Table_or_subqueryContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Table_or_subqueryContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Table_or_subqueryContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_subquery;
}

void SQLiteParser::Table_or_subqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_or_subquery(this);
}

void SQLiteParser::Table_or_subqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_or_subquery(this);
}


std::any SQLiteParser::Table_or_subqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_or_subquery(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::table_or_subquery() {
  Table_or_subqueryContext *_localctx = _tracker.createInstance<Table_or_subqueryContext>(_ctx, getState());
  enterRule(_localctx, 98, SQLiteParser::RuleTable_or_subquery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1456);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 206, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1395);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
      case 1: {
        setState(1392);
        schema_name();
        setState(1393);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1397);
      table_name();
      setState(1402);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
      case 1: {
        setState(1399);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
        case 1: {
          setState(1398);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1401);
        table_alias();
        break;
      }

      default:
        break;
      }
      setState(1409);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::INDEXED_: {
          setState(1404);
          match(SQLiteParser::INDEXED_);
          setState(1405);
          match(SQLiteParser::BY_);
          setState(1406);
          index_name();
          break;
        }

        case SQLiteParser::NOT_: {
          setState(1407);
          match(SQLiteParser::NOT_);
          setState(1408);
          match(SQLiteParser::INDEXED_);
          break;
        }

        case SQLiteParser::EOF:
        case SQLiteParser::SCOL:
        case SQLiteParser::CLOSE_PAR:
        case SQLiteParser::COMMA:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DROP_:
        case SQLiteParser::END_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::ON_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WINDOW_: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1414);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
      case 1: {
        setState(1411);
        schema_name();
        setState(1412);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1416);
      table_function_name();
      setState(1417);
      match(SQLiteParser::OPEN_PAR);
      setState(1418);
      expr(0);
      setState(1423);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1419);
        match(SQLiteParser::COMMA);
        setState(1420);
        expr(0);
        setState(1425);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1426);
      match(SQLiteParser::CLOSE_PAR);
      setState(1431);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
      case 1: {
        setState(1428);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
        case 1: {
          setState(1427);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1430);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1433);
      match(SQLiteParser::OPEN_PAR);
      setState(1443);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
      case 1: {
        setState(1434);
        table_or_subquery();
        setState(1439);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1435);
          match(SQLiteParser::COMMA);
          setState(1436);
          table_or_subquery();
          setState(1441);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1442);
        join_clause();
        break;
      }

      default:
        break;
      }
      setState(1445);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1447);
      match(SQLiteParser::OPEN_PAR);
      setState(1448);
      select_stmt();
      setState(1449);
      match(SQLiteParser::CLOSE_PAR);
      setState(1454);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
      case 1: {
        setState(1451);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
        case 1: {
          setState(1450);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1453);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Result_columnContext ------------------------------------------------------------------

SQLiteParser::Result_columnContext::Result_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Result_columnContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Result_columnContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Result_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Column_aliasContext* SQLiteParser::Result_columnContext::column_alias() {
  return getRuleContext<SQLiteParser::Column_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}


size_t SQLiteParser::Result_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleResult_column;
}

void SQLiteParser::Result_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResult_column(this);
}

void SQLiteParser::Result_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResult_column(this);
}


std::any SQLiteParser::Result_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitResult_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Result_columnContext* SQLiteParser::result_column() {
  Result_columnContext *_localctx = _tracker.createInstance<Result_columnContext>(_ctx, getState());
  enterRule(_localctx, 100, SQLiteParser::RuleResult_column);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1470);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1458);
      match(SQLiteParser::STAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1459);
      table_name();
      setState(1460);
      match(SQLiteParser::DOT);
      setState(1461);
      match(SQLiteParser::STAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1463);
      expr(0);
      setState(1468);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::AS_ || _la == SQLiteParser::IDENTIFIER

      || _la == SQLiteParser::STRING_LITERAL) {
        setState(1465);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::AS_) {
          setState(1464);
          match(SQLiteParser::AS_);
        }
        setState(1467);
        column_alias();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_operatorContext ------------------------------------------------------------------

SQLiteParser::Join_operatorContext::Join_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::RIGHT_() {
  return getToken(SQLiteParser::RIGHT_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::FULL_() {
  return getToken(SQLiteParser::FULL_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}


size_t SQLiteParser::Join_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_operator;
}

void SQLiteParser::Join_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_operator(this);
}

void SQLiteParser::Join_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_operator(this);
}


std::any SQLiteParser::Join_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_operatorContext* SQLiteParser::join_operator() {
  Join_operatorContext *_localctx = _tracker.createInstance<Join_operatorContext>(_ctx, getState());
  enterRule(_localctx, 102, SQLiteParser::RuleJoin_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1485);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::COMMA: {
        enterOuterAlt(_localctx, 1);
        setState(1472);
        match(SQLiteParser::COMMA);
        break;
      }

      case SQLiteParser::CROSS_:
      case SQLiteParser::FULL_:
      case SQLiteParser::INNER_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::RIGHT_: {
        enterOuterAlt(_localctx, 2);
        setState(1474);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NATURAL_) {
          setState(1473);
          match(SQLiteParser::NATURAL_);
        }
        setState(1482);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::FULL_:
          case SQLiteParser::LEFT_:
          case SQLiteParser::RIGHT_: {
            setState(1476);
            _la = _input->LA(1);
            if (!(((((_la - 76) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 76)) & 562949954469889) != 0))) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(1478);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::OUTER_) {
              setState(1477);
              match(SQLiteParser::OUTER_);
            }
            break;
          }

          case SQLiteParser::INNER_: {
            setState(1480);
            match(SQLiteParser::INNER_);
            break;
          }

          case SQLiteParser::CROSS_: {
            setState(1481);
            match(SQLiteParser::CROSS_);
            break;
          }

          case SQLiteParser::JOIN_: {
            break;
          }

        default:
          break;
        }
        setState(1484);
        match(SQLiteParser::JOIN_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_constraintContext ------------------------------------------------------------------

SQLiteParser::Join_constraintContext::Join_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Join_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Join_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Join_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Join_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Join_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_constraint;
}

void SQLiteParser::Join_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_constraint(this);
}

void SQLiteParser::Join_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_constraint(this);
}


std::any SQLiteParser::Join_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_constraintContext* SQLiteParser::join_constraint() {
  Join_constraintContext *_localctx = _tracker.createInstance<Join_constraintContext>(_ctx, getState());
  enterRule(_localctx, 104, SQLiteParser::RuleJoin_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1501);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ON_: {
        enterOuterAlt(_localctx, 1);
        setState(1487);
        match(SQLiteParser::ON_);
        setState(1488);
        expr(0);
        break;
      }

      case SQLiteParser::USING_: {
        enterOuterAlt(_localctx, 2);
        setState(1489);
        match(SQLiteParser::USING_);
        setState(1490);
        match(SQLiteParser::OPEN_PAR);
        setState(1491);
        column_name();
        setState(1496);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1492);
          match(SQLiteParser::COMMA);
          setState(1493);
          column_name();
          setState(1498);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1499);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_operatorContext ------------------------------------------------------------------

SQLiteParser::Compound_operatorContext::Compound_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}


size_t SQLiteParser::Compound_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_operator;
}

void SQLiteParser::Compound_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_operator(this);
}

void SQLiteParser::Compound_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_operator(this);
}


std::any SQLiteParser::Compound_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_operatorContext* SQLiteParser::compound_operator() {
  Compound_operatorContext *_localctx = _tracker.createInstance<Compound_operatorContext>(_ctx, getState());
  enterRule(_localctx, 106, SQLiteParser::RuleCompound_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1509);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::UNION_: {
        enterOuterAlt(_localctx, 1);
        setState(1503);
        match(SQLiteParser::UNION_);
        setState(1505);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ALL_) {
          setState(1504);
          match(SQLiteParser::ALL_);
        }
        break;
      }

      case SQLiteParser::INTERSECT_: {
        enterOuterAlt(_localctx, 2);
        setState(1507);
        match(SQLiteParser::INTERSECT_);
        break;
      }

      case SQLiteParser::EXCEPT_: {
        enterOuterAlt(_localctx, 3);
        setState(1508);
        match(SQLiteParser::EXCEPT_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmtContext ------------------------------------------------------------------

SQLiteParser::Update_stmtContext::Update_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmtContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmtContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmtContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmtContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Update_stmtContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Update_stmtContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Update_stmtContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}


size_t SQLiteParser::Update_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt;
}

void SQLiteParser::Update_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt(this);
}

void SQLiteParser::Update_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt(this);
}


std::any SQLiteParser::Update_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmtContext* SQLiteParser::update_stmt() {
  Update_stmtContext *_localctx = _tracker.createInstance<Update_stmtContext>(_ctx, getState());
  enterRule(_localctx, 108, SQLiteParser::RuleUpdate_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1512);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1511);
      with_clause();
    }
    setState(1514);
    match(SQLiteParser::UPDATE_);
    setState(1517);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      setState(1515);
      match(SQLiteParser::OR_);
      setState(1516);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1519);
    qualified_table_name();
    setState(1520);
    match(SQLiteParser::SET_);
    setState(1523);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
    case 1: {
      setState(1521);
      column_name();
      break;
    }

    case 2: {
      setState(1522);
      column_name_list();
      break;
    }

    default:
      break;
    }
    setState(1525);
    match(SQLiteParser::ASSIGN);
    setState(1526);
    expr(0);
    setState(1537);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1527);
      match(SQLiteParser::COMMA);
      setState(1530);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
      case 1: {
        setState(1528);
        column_name();
        break;
      }

      case 2: {
        setState(1529);
        column_name_list();
        break;
      }

      default:
        break;
      }
      setState(1532);
      match(SQLiteParser::ASSIGN);
      setState(1533);
      expr(0);
      setState(1539);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1552);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FROM_) {
      setState(1540);
      match(SQLiteParser::FROM_);
      setState(1550);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
      case 1: {
        setState(1541);
        table_or_subquery();
        setState(1546);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1542);
          match(SQLiteParser::COMMA);
          setState(1543);
          table_or_subquery();
          setState(1548);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1549);
        join_clause();
        break;
      }

      default:
        break;
      }
    }
    setState(1556);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1554);
      match(SQLiteParser::WHERE_);
      setState(1555);
      expr(0);
    }
    setState(1559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1558);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

SQLiteParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Column_name_listContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_name_listContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Column_name_listContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Column_name_listContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name_list;
}

void SQLiteParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void SQLiteParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}


std::any SQLiteParser::Column_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_name_listContext* SQLiteParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 110, SQLiteParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1561);
    match(SQLiteParser::OPEN_PAR);
    setState(1562);
    column_name();
    setState(1567);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1563);
      match(SQLiteParser::COMMA);
      setState(1564);
      column_name();
      setState(1569);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1570);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Update_stmt_limitedContext::Update_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmt_limitedContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmt_limitedContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmt_limitedContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmt_limitedContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmt_limitedContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmt_limitedContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Update_stmt_limitedContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Update_stmt_limitedContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}


size_t SQLiteParser::Update_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt_limited;
}

void SQLiteParser::Update_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt_limited(this);
}

void SQLiteParser::Update_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt_limited(this);
}


std::any SQLiteParser::Update_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::update_stmt_limited() {
  Update_stmt_limitedContext *_localctx = _tracker.createInstance<Update_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 112, SQLiteParser::RuleUpdate_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1573);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1572);
      with_clause();
    }
    setState(1575);
    match(SQLiteParser::UPDATE_);
    setState(1578);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(1576);
      match(SQLiteParser::OR_);
      setState(1577);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1580);
    qualified_table_name();
    setState(1581);
    match(SQLiteParser::SET_);
    setState(1584);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
    case 1: {
      setState(1582);
      column_name();
      break;
    }

    case 2: {
      setState(1583);
      column_name_list();
      break;
    }

    default:
      break;
    }
    setState(1586);
    match(SQLiteParser::ASSIGN);
    setState(1587);
    expr(0);
    setState(1598);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1588);
      match(SQLiteParser::COMMA);
      setState(1591);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        setState(1589);
        column_name();
        break;
      }

      case 2: {
        setState(1590);
        column_name_list();
        break;
      }

      default:
        break;
      }
      setState(1593);
      match(SQLiteParser::ASSIGN);
      setState(1594);
      expr(0);
      setState(1600);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1601);
      match(SQLiteParser::WHERE_);
      setState(1602);
      expr(0);
    }
    setState(1606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1605);
      returning_clause();
    }
    setState(1612);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_

    || _la == SQLiteParser::ORDER_) {
      setState(1609);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(1608);
        order_by_stmt();
      }
      setState(1611);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_table_nameContext ------------------------------------------------------------------

SQLiteParser::Qualified_table_nameContext::Qualified_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Qualified_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Qualified_table_nameContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::AliasContext* SQLiteParser::Qualified_table_nameContext::alias() {
  return getRuleContext<SQLiteParser::AliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Qualified_table_nameContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Qualified_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleQualified_table_name;
}

void SQLiteParser::Qualified_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_table_name(this);
}

void SQLiteParser::Qualified_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_table_name(this);
}


std::any SQLiteParser::Qualified_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitQualified_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::qualified_table_name() {
  Qualified_table_nameContext *_localctx = _tracker.createInstance<Qualified_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 114, SQLiteParser::RuleQualified_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1617);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
    case 1: {
      setState(1614);
      schema_name();
      setState(1615);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1619);
    table_name();
    setState(1622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1620);
      match(SQLiteParser::AS_);
      setState(1621);
      alias();
    }
    setState(1629);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::INDEXED_: {
        setState(1624);
        match(SQLiteParser::INDEXED_);
        setState(1625);
        match(SQLiteParser::BY_);
        setState(1626);
        index_name();
        break;
      }

      case SQLiteParser::NOT_: {
        setState(1627);
        match(SQLiteParser::NOT_);
        setState(1628);
        match(SQLiteParser::INDEXED_);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DROP_:
      case SQLiteParser::END_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_stmtContext ------------------------------------------------------------------

SQLiteParser::Vacuum_stmtContext::Vacuum_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Vacuum_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::FilenameContext* SQLiteParser::Vacuum_stmtContext::filename() {
  return getRuleContext<SQLiteParser::FilenameContext>(0);
}


size_t SQLiteParser::Vacuum_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleVacuum_stmt;
}

void SQLiteParser::Vacuum_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVacuum_stmt(this);
}

void SQLiteParser::Vacuum_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVacuum_stmt(this);
}


std::any SQLiteParser::Vacuum_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::vacuum_stmt() {
  Vacuum_stmtContext *_localctx = _tracker.createInstance<Vacuum_stmtContext>(_ctx, getState());
  enterRule(_localctx, 116, SQLiteParser::RuleVacuum_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1631);
    match(SQLiteParser::VACUUM_);
    setState(1633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
    case 1: {
      setState(1632);
      schema_name();
      break;
    }

    default:
      break;
    }
    setState(1637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::INTO_) {
      setState(1635);
      match(SQLiteParser::INTO_);
      setState(1636);
      filename();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filter_clauseContext ------------------------------------------------------------------

SQLiteParser::Filter_clauseContext::Filter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Filter_clauseContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Filter_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFilter_clause;
}

void SQLiteParser::Filter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilter_clause(this);
}

void SQLiteParser::Filter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilter_clause(this);
}


std::any SQLiteParser::Filter_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilter_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::filter_clause() {
  Filter_clauseContext *_localctx = _tracker.createInstance<Filter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 118, SQLiteParser::RuleFilter_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1639);
    match(SQLiteParser::FILTER_);
    setState(1640);
    match(SQLiteParser::OPEN_PAR);
    setState(1641);
    match(SQLiteParser::WHERE_);
    setState(1642);
    expr(0);
    setState(1643);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_defnContext ------------------------------------------------------------------

SQLiteParser::Window_defnContext::Window_defnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Window_defnContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_defnContext::BY_() {
  return getTokens(SQLiteParser::BY_);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::BY_(size_t i) {
  return getToken(SQLiteParser::BY_, i);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Window_defnContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Window_defnContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Window_defnContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_defnContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_defnContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

SQLiteParser::Frame_specContext* SQLiteParser::Window_defnContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_defnContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_defnContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_defn;
}

void SQLiteParser::Window_defnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_defn(this);
}

void SQLiteParser::Window_defnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_defn(this);
}


std::any SQLiteParser::Window_defnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_defn(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_defnContext* SQLiteParser::window_defn() {
  Window_defnContext *_localctx = _tracker.createInstance<Window_defnContext>(_ctx, getState());
  enterRule(_localctx, 120, SQLiteParser::RuleWindow_defn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1645);
    match(SQLiteParser::OPEN_PAR);
    setState(1647);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      setState(1646);
      base_window_name();
      break;
    }

    default:
      break;
    }
    setState(1659);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PARTITION_) {
      setState(1649);
      match(SQLiteParser::PARTITION_);
      setState(1650);
      match(SQLiteParser::BY_);
      setState(1651);
      expr(0);
      setState(1656);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1652);
        match(SQLiteParser::COMMA);
        setState(1653);
        expr(0);
        setState(1658);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

    setState(1661);
    match(SQLiteParser::ORDER_);
    setState(1662);
    match(SQLiteParser::BY_);
    setState(1663);
    ordering_term();
    setState(1668);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1664);
      match(SQLiteParser::COMMA);
      setState(1665);
      ordering_term();
      setState(1670);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1672);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
      setState(1671);
      frame_spec();
    }
    setState(1674);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

SQLiteParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Over_clauseContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Over_clauseContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Over_clauseContext::BY_() {
  return getTokens(SQLiteParser::BY_);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::BY_(size_t i) {
  return getToken(SQLiteParser::BY_, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Over_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Over_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Over_clauseContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Over_clauseContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

SQLiteParser::Frame_specContext* SQLiteParser::Over_clauseContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Over_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Over_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleOver_clause;
}

void SQLiteParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void SQLiteParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}


std::any SQLiteParser::Over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOver_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Over_clauseContext* SQLiteParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 122, SQLiteParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1676);
    match(SQLiteParser::OVER_);
    setState(1710);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      setState(1677);
      window_name();
      break;
    }

    case 2: {
      setState(1678);
      match(SQLiteParser::OPEN_PAR);
      setState(1680);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 248, _ctx)) {
      case 1: {
        setState(1679);
        base_window_name();
        break;
      }

      default:
        break;
      }
      setState(1692);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::PARTITION_) {
        setState(1682);
        match(SQLiteParser::PARTITION_);
        setState(1683);
        match(SQLiteParser::BY_);
        setState(1684);
        expr(0);
        setState(1689);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1685);
          match(SQLiteParser::COMMA);
          setState(1686);
          expr(0);
          setState(1691);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1704);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(1694);
        match(SQLiteParser::ORDER_);
        setState(1695);
        match(SQLiteParser::BY_);
        setState(1696);
        ordering_term();
        setState(1701);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1697);
          match(SQLiteParser::COMMA);
          setState(1698);
          ordering_term();
          setState(1703);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1707);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
        setState(1706);
        frame_spec();
      }
      setState(1709);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_specContext ------------------------------------------------------------------

SQLiteParser::Frame_specContext::Frame_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Frame_clauseContext* SQLiteParser::Frame_specContext::frame_clause() {
  return getRuleContext<SQLiteParser::Frame_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::OTHERS_() {
  return getToken(SQLiteParser::OTHERS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::TIES_() {
  return getToken(SQLiteParser::TIES_, 0);
}


size_t SQLiteParser::Frame_specContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_spec;
}

void SQLiteParser::Frame_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_spec(this);
}

void SQLiteParser::Frame_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_spec(this);
}


std::any SQLiteParser::Frame_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_spec(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_specContext* SQLiteParser::frame_spec() {
  Frame_specContext *_localctx = _tracker.createInstance<Frame_specContext>(_ctx, getState());
  enterRule(_localctx, 124, SQLiteParser::RuleFrame_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1712);
    frame_clause();
    setState(1722);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXCLUDE_) {
      setState(1713);
      match(SQLiteParser::EXCLUDE_);
      setState(1720);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::NO_: {
          setState(1714);
          match(SQLiteParser::NO_);
          setState(1715);
          match(SQLiteParser::OTHERS_);
          break;
        }

        case SQLiteParser::CURRENT_: {
          setState(1716);
          match(SQLiteParser::CURRENT_);
          setState(1717);
          match(SQLiteParser::ROW_);
          break;
        }

        case SQLiteParser::GROUP_: {
          setState(1718);
          match(SQLiteParser::GROUP_);
          break;
        }

        case SQLiteParser::TIES_: {
          setState(1719);
          match(SQLiteParser::TIES_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_clauseContext ------------------------------------------------------------------

SQLiteParser::Frame_clauseContext::Frame_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

SQLiteParser::Frame_singleContext* SQLiteParser::Frame_clauseContext::frame_single() {
  return getRuleContext<SQLiteParser::Frame_singleContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

SQLiteParser::Frame_leftContext* SQLiteParser::Frame_clauseContext::frame_left() {
  return getRuleContext<SQLiteParser::Frame_leftContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

SQLiteParser::Frame_rightContext* SQLiteParser::Frame_clauseContext::frame_right() {
  return getRuleContext<SQLiteParser::Frame_rightContext>(0);
}


size_t SQLiteParser::Frame_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_clause;
}

void SQLiteParser::Frame_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_clause(this);
}

void SQLiteParser::Frame_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_clause(this);
}


std::any SQLiteParser::Frame_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_clauseContext* SQLiteParser::frame_clause() {
  Frame_clauseContext *_localctx = _tracker.createInstance<Frame_clauseContext>(_ctx, getState());
  enterRule(_localctx, 126, SQLiteParser::RuleFrame_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1724);
    _la = _input->LA(1);
    if (!(((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 2251799880794113) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
    case 1: {
      setState(1725);
      frame_single();
      break;
    }

    case 2: {
      setState(1726);
      match(SQLiteParser::BETWEEN_);
      setState(1727);
      frame_left();
      setState(1728);
      match(SQLiteParser::AND_);
      setState(1729);
      frame_right();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Simple_function_invocationContext::Simple_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Simple_funcContext* SQLiteParser::Simple_function_invocationContext::simple_func() {
  return getRuleContext<SQLiteParser::Simple_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Simple_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Simple_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Simple_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Simple_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_function_invocation;
}

void SQLiteParser::Simple_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_function_invocation(this);
}

void SQLiteParser::Simple_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_function_invocation(this);
}


std::any SQLiteParser::Simple_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_function_invocationContext* SQLiteParser::simple_function_invocation() {
  Simple_function_invocationContext *_localctx = _tracker.createInstance<Simple_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 128, SQLiteParser::RuleSimple_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1733);
    simple_func();
    setState(1734);
    match(SQLiteParser::OPEN_PAR);
    setState(1744);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1735);
        expr(0);
        setState(1740);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1736);
          match(SQLiteParser::COMMA);
          setState(1737);
          expr(0);
          setState(1742);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1743);
        match(SQLiteParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1746);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Aggregate_function_invocationContext::Aggregate_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::Aggregate_function_invocationContext::aggregate_func() {
  return getRuleContext<SQLiteParser::Aggregate_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Aggregate_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Aggregate_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Aggregate_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Aggregate_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Aggregate_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_function_invocation;
}

void SQLiteParser::Aggregate_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_function_invocation(this);
}

void SQLiteParser::Aggregate_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_function_invocation(this);
}


std::any SQLiteParser::Aggregate_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_function_invocationContext* SQLiteParser::aggregate_function_invocation() {
  Aggregate_function_invocationContext *_localctx = _tracker.createInstance<Aggregate_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 130, SQLiteParser::RuleAggregate_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1748);
    aggregate_func();
    setState(1749);
    match(SQLiteParser::OPEN_PAR);
    setState(1762);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1751);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 260, _ctx)) {
        case 1: {
          setState(1750);
          match(SQLiteParser::DISTINCT_);
          break;
        }

        default:
          break;
        }
        setState(1753);
        expr(0);
        setState(1758);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1754);
          match(SQLiteParser::COMMA);
          setState(1755);
          expr(0);
          setState(1760);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1761);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1764);
    match(SQLiteParser::CLOSE_PAR);
    setState(1766);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1765);
      filter_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Window_function_invocationContext::Window_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Window_functionContext* SQLiteParser::Window_function_invocationContext::window_function() {
  return getRuleContext<SQLiteParser::Window_functionContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_defnContext* SQLiteParser::Window_function_invocationContext::window_defn() {
  return getRuleContext<SQLiteParser::Window_defnContext>(0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Window_function_invocationContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Window_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_function_invocation;
}

void SQLiteParser::Window_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_function_invocation(this);
}

void SQLiteParser::Window_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_function_invocation(this);
}


std::any SQLiteParser::Window_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_function_invocationContext* SQLiteParser::window_function_invocation() {
  Window_function_invocationContext *_localctx = _tracker.createInstance<Window_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 132, SQLiteParser::RuleWindow_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1768);
    window_function();
    setState(1769);
    match(SQLiteParser::OPEN_PAR);
    setState(1779);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1770);
        expr(0);
        setState(1775);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1771);
          match(SQLiteParser::COMMA);
          setState(1772);
          expr(0);
          setState(1777);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1778);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1781);
    match(SQLiteParser::CLOSE_PAR);
    setState(1783);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1782);
      filter_clause();
    }
    setState(1785);
    match(SQLiteParser::OVER_);
    setState(1788);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
    case 1: {
      setState(1786);
      window_defn();
      break;
    }

    case 2: {
      setState(1787);
      window_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Common_table_stmtContext::Common_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

std::vector<SQLiteParser::Common_table_expressionContext *> SQLiteParser::Common_table_stmtContext::common_table_expression() {
  return getRuleContexts<SQLiteParser::Common_table_expressionContext>();
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::Common_table_stmtContext::common_table_expression(size_t i) {
  return getRuleContext<SQLiteParser::Common_table_expressionContext>(i);
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Common_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCommon_table_stmt;
}

void SQLiteParser::Common_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_stmt(this);
}

void SQLiteParser::Common_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_stmt(this);
}


std::any SQLiteParser::Common_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::common_table_stmt() {
  Common_table_stmtContext *_localctx = _tracker.createInstance<Common_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 134, SQLiteParser::RuleCommon_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1790);
    match(SQLiteParser::WITH_);
    setState(1792);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 268, _ctx)) {
    case 1: {
      setState(1791);
      match(SQLiteParser::RECURSIVE_);
      break;
    }

    default:
      break;
    }
    setState(1794);
    common_table_expression();
    setState(1799);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1795);
      match(SQLiteParser::COMMA);
      setState(1796);
      common_table_expression();
      setState(1801);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_stmtContext ------------------------------------------------------------------

SQLiteParser::Order_by_stmtContext::Order_by_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Order_by_stmtContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Order_by_stmtContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Order_by_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Order_by_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_stmt;
}

void SQLiteParser::Order_by_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_stmt(this);
}

void SQLiteParser::Order_by_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_stmt(this);
}


std::any SQLiteParser::Order_by_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::order_by_stmt() {
  Order_by_stmtContext *_localctx = _tracker.createInstance<Order_by_stmtContext>(_ctx, getState());
  enterRule(_localctx, 136, SQLiteParser::RuleOrder_by_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1802);
    match(SQLiteParser::ORDER_);
    setState(1803);
    match(SQLiteParser::BY_);
    setState(1804);
    ordering_term();
    setState(1809);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1805);
      match(SQLiteParser::COMMA);
      setState(1806);
      ordering_term();
      setState(1811);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_stmtContext ------------------------------------------------------------------

SQLiteParser::Limit_stmtContext::Limit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Limit_stmtContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Limit_stmtContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Limit_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleLimit_stmt;
}

void SQLiteParser::Limit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimit_stmt(this);
}

void SQLiteParser::Limit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimit_stmt(this);
}


std::any SQLiteParser::Limit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLimit_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::limit_stmt() {
  Limit_stmtContext *_localctx = _tracker.createInstance<Limit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 138, SQLiteParser::RuleLimit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1812);
    match(SQLiteParser::LIMIT_);
    setState(1813);
    expr(0);
    setState(1816);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_) {
      setState(1814);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1815);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordering_termContext ------------------------------------------------------------------

SQLiteParser::Ordering_termContext::Ordering_termContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Ordering_termContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Ordering_termContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Ordering_termContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}


size_t SQLiteParser::Ordering_termContext::getRuleIndex() const {
  return SQLiteParser::RuleOrdering_term;
}

void SQLiteParser::Ordering_termContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdering_term(this);
}

void SQLiteParser::Ordering_termContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdering_term(this);
}


std::any SQLiteParser::Ordering_termContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrdering_term(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Ordering_termContext* SQLiteParser::ordering_term() {
  Ordering_termContext *_localctx = _tracker.createInstance<Ordering_termContext>(_ctx, getState());
  enterRule(_localctx, 140, SQLiteParser::RuleOrdering_term);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1818);
    expr(0);
    setState(1821);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(1819);
      match(SQLiteParser::COLLATE_);
      setState(1820);
      collation_name();
    }
    setState(1824);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(1823);
      asc_desc();
    }
    setState(1828);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::NULLS_) {
      setState(1826);
      match(SQLiteParser::NULLS_);
      setState(1827);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::FIRST_

      || _la == SQLiteParser::LAST_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Asc_descContext ------------------------------------------------------------------

SQLiteParser::Asc_descContext::Asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Asc_descContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::Asc_descContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}


size_t SQLiteParser::Asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleAsc_desc;
}

void SQLiteParser::Asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsc_desc(this);
}

void SQLiteParser::Asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsc_desc(this);
}


std::any SQLiteParser::Asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAsc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Asc_descContext* SQLiteParser::asc_desc() {
  Asc_descContext *_localctx = _tracker.createInstance<Asc_descContext>(_ctx, getState());
  enterRule(_localctx, 142, SQLiteParser::RuleAsc_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1830);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_leftContext ------------------------------------------------------------------

SQLiteParser::Frame_leftContext::Frame_leftContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_leftContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_leftContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_left;
}

void SQLiteParser::Frame_leftContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_left(this);
}

void SQLiteParser::Frame_leftContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_left(this);
}


std::any SQLiteParser::Frame_leftContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_left(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_leftContext* SQLiteParser::frame_left() {
  Frame_leftContext *_localctx = _tracker.createInstance<Frame_leftContext>(_ctx, getState());
  enterRule(_localctx, 144, SQLiteParser::RuleFrame_left);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1842);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1832);
      expr(0);
      setState(1833);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1835);
      expr(0);
      setState(1836);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1838);
      match(SQLiteParser::CURRENT_);
      setState(1839);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1840);
      match(SQLiteParser::UNBOUNDED_);
      setState(1841);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_rightContext ------------------------------------------------------------------

SQLiteParser::Frame_rightContext::Frame_rightContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_rightContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_rightContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_right;
}

void SQLiteParser::Frame_rightContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_right(this);
}

void SQLiteParser::Frame_rightContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_right(this);
}


std::any SQLiteParser::Frame_rightContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_right(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_rightContext* SQLiteParser::frame_right() {
  Frame_rightContext *_localctx = _tracker.createInstance<Frame_rightContext>(_ctx, getState());
  enterRule(_localctx, 146, SQLiteParser::RuleFrame_right);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1854);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1844);
      expr(0);
      setState(1845);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1847);
      expr(0);
      setState(1848);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1850);
      match(SQLiteParser::CURRENT_);
      setState(1851);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1852);
      match(SQLiteParser::UNBOUNDED_);
      setState(1853);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_singleContext ------------------------------------------------------------------

SQLiteParser::Frame_singleContext::Frame_singleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_singleContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}


size_t SQLiteParser::Frame_singleContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_single;
}

void SQLiteParser::Frame_singleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_single(this);
}

void SQLiteParser::Frame_singleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_single(this);
}


std::any SQLiteParser::Frame_singleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_single(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_singleContext* SQLiteParser::frame_single() {
  Frame_singleContext *_localctx = _tracker.createInstance<Frame_singleContext>(_ctx, getState());
  enterRule(_localctx, 148, SQLiteParser::RuleFrame_single);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1863);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1856);
      expr(0);
      setState(1857);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1859);
      match(SQLiteParser::UNBOUNDED_);
      setState(1860);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1861);
      match(SQLiteParser::CURRENT_);
      setState(1862);
      match(SQLiteParser::ROW_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_functionContext ------------------------------------------------------------------

SQLiteParser::Window_functionContext::Window_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_functionContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

SQLiteParser::ExprContext* SQLiteParser::Window_functionContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_functionContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Order_by_expr_asc_descContext* SQLiteParser::Window_functionContext::order_by_expr_asc_desc() {
  return getRuleContext<SQLiteParser::Order_by_expr_asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::FIRST_VALUE_() {
  return getToken(SQLiteParser::FIRST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LAST_VALUE_() {
  return getToken(SQLiteParser::LAST_VALUE_, 0);
}

SQLiteParser::Partition_byContext* SQLiteParser::Window_functionContext::partition_by() {
  return getRuleContext<SQLiteParser::Partition_byContext>(0);
}

SQLiteParser::Frame_clauseContext* SQLiteParser::Window_functionContext::frame_clause() {
  return getRuleContext<SQLiteParser::Frame_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::CUME_DIST_() {
  return getToken(SQLiteParser::CUME_DIST_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::PERCENT_RANK_() {
  return getToken(SQLiteParser::PERCENT_RANK_, 0);
}

SQLiteParser::Order_by_exprContext* SQLiteParser::Window_functionContext::order_by_expr() {
  return getRuleContext<SQLiteParser::Order_by_exprContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::DENSE_RANK_() {
  return getToken(SQLiteParser::DENSE_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::RANK_() {
  return getToken(SQLiteParser::RANK_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::ROW_NUMBER_() {
  return getToken(SQLiteParser::ROW_NUMBER_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LAG_() {
  return getToken(SQLiteParser::LAG_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LEAD_() {
  return getToken(SQLiteParser::LEAD_, 0);
}

SQLiteParser::OffsetContext* SQLiteParser::Window_functionContext::offset() {
  return getRuleContext<SQLiteParser::OffsetContext>(0);
}

SQLiteParser::Default_valueContext* SQLiteParser::Window_functionContext::default_value() {
  return getRuleContext<SQLiteParser::Default_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::NTH_VALUE_() {
  return getToken(SQLiteParser::NTH_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Window_functionContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::NTILE_() {
  return getToken(SQLiteParser::NTILE_, 0);
}


size_t SQLiteParser::Window_functionContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_function;
}

void SQLiteParser::Window_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_function(this);
}

void SQLiteParser::Window_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_function(this);
}


std::any SQLiteParser::Window_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_function(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_functionContext* SQLiteParser::window_function() {
  Window_functionContext *_localctx = _tracker.createInstance<Window_functionContext>(_ctx, getState());
  enterRule(_localctx, 150, SQLiteParser::RuleWindow_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1950);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::LAST_VALUE_: {
        enterOuterAlt(_localctx, 1);
        setState(1865);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::FIRST_VALUE_

        || _la == SQLiteParser::LAST_VALUE_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1866);
        match(SQLiteParser::OPEN_PAR);
        setState(1867);
        expr(0);
        setState(1868);
        match(SQLiteParser::CLOSE_PAR);
        setState(1869);
        match(SQLiteParser::OVER_);
        setState(1870);
        match(SQLiteParser::OPEN_PAR);
        setState(1872);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1871);
          partition_by();
        }
        setState(1874);
        order_by_expr_asc_desc();
        setState(1876);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
          setState(1875);
          frame_clause();
        }
        setState(1878);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::PERCENT_RANK_: {
        enterOuterAlt(_localctx, 2);
        setState(1880);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::CUME_DIST_

        || _la == SQLiteParser::PERCENT_RANK_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1881);
        match(SQLiteParser::OPEN_PAR);
        setState(1882);
        match(SQLiteParser::CLOSE_PAR);
        setState(1883);
        match(SQLiteParser::OVER_);
        setState(1884);
        match(SQLiteParser::OPEN_PAR);
        setState(1886);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1885);
          partition_by();
        }
        setState(1889);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ORDER_) {
          setState(1888);
          order_by_expr();
        }
        setState(1891);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_: {
        enterOuterAlt(_localctx, 3);
        setState(1892);
        _la = _input->LA(1);
        if (!(((((_la - 160) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 160)) & 385) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1893);
        match(SQLiteParser::OPEN_PAR);
        setState(1894);
        match(SQLiteParser::CLOSE_PAR);
        setState(1895);
        match(SQLiteParser::OVER_);
        setState(1896);
        match(SQLiteParser::OPEN_PAR);
        setState(1898);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1897);
          partition_by();
        }
        setState(1900);
        order_by_expr_asc_desc();
        setState(1901);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::LAG_:
      case SQLiteParser::LEAD_: {
        enterOuterAlt(_localctx, 4);
        setState(1903);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::LAG_

        || _la == SQLiteParser::LEAD_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1904);
        match(SQLiteParser::OPEN_PAR);
        setState(1905);
        expr(0);
        setState(1907);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
        case 1: {
          setState(1906);
          offset();
          break;
        }

        default:
          break;
        }
        setState(1910);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::COMMA) {
          setState(1909);
          default_value();
        }
        setState(1912);
        match(SQLiteParser::CLOSE_PAR);
        setState(1913);
        match(SQLiteParser::OVER_);
        setState(1914);
        match(SQLiteParser::OPEN_PAR);
        setState(1916);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1915);
          partition_by();
        }
        setState(1918);
        order_by_expr_asc_desc();
        setState(1919);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::NTH_VALUE_: {
        enterOuterAlt(_localctx, 5);
        setState(1921);
        match(SQLiteParser::NTH_VALUE_);
        setState(1922);
        match(SQLiteParser::OPEN_PAR);
        setState(1923);
        expr(0);
        setState(1924);
        match(SQLiteParser::COMMA);
        setState(1925);
        signed_number();
        setState(1926);
        match(SQLiteParser::CLOSE_PAR);
        setState(1927);
        match(SQLiteParser::OVER_);
        setState(1928);
        match(SQLiteParser::OPEN_PAR);
        setState(1930);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1929);
          partition_by();
        }
        setState(1932);
        order_by_expr_asc_desc();
        setState(1934);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
          setState(1933);
          frame_clause();
        }
        setState(1936);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::NTILE_: {
        enterOuterAlt(_localctx, 6);
        setState(1938);
        match(SQLiteParser::NTILE_);
        setState(1939);
        match(SQLiteParser::OPEN_PAR);
        setState(1940);
        expr(0);
        setState(1941);
        match(SQLiteParser::CLOSE_PAR);
        setState(1942);
        match(SQLiteParser::OVER_);
        setState(1943);
        match(SQLiteParser::OPEN_PAR);
        setState(1945);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1944);
          partition_by();
        }
        setState(1947);
        order_by_expr_asc_desc();
        setState(1948);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OffsetContext ------------------------------------------------------------------

SQLiteParser::OffsetContext::OffsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::OffsetContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::OffsetContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}


size_t SQLiteParser::OffsetContext::getRuleIndex() const {
  return SQLiteParser::RuleOffset;
}

void SQLiteParser::OffsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOffset(this);
}

void SQLiteParser::OffsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOffset(this);
}


std::any SQLiteParser::OffsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOffset(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::OffsetContext* SQLiteParser::offset() {
  OffsetContext *_localctx = _tracker.createInstance<OffsetContext>(_ctx, getState());
  enterRule(_localctx, 152, SQLiteParser::RuleOffset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1952);
    match(SQLiteParser::COMMA);
    setState(1953);
    signed_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

SQLiteParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Default_valueContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Default_valueContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}


size_t SQLiteParser::Default_valueContext::getRuleIndex() const {
  return SQLiteParser::RuleDefault_value;
}

void SQLiteParser::Default_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_value(this);
}

void SQLiteParser::Default_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_value(this);
}


std::any SQLiteParser::Default_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDefault_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Default_valueContext* SQLiteParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 154, SQLiteParser::RuleDefault_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1955);
    match(SQLiteParser::COMMA);
    setState(1956);
    signed_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_byContext ------------------------------------------------------------------

SQLiteParser::Partition_byContext::Partition_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Partition_byContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::Partition_byContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Partition_byContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Partition_byContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}


size_t SQLiteParser::Partition_byContext::getRuleIndex() const {
  return SQLiteParser::RulePartition_by;
}

void SQLiteParser::Partition_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_by(this);
}

void SQLiteParser::Partition_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_by(this);
}


std::any SQLiteParser::Partition_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPartition_by(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Partition_byContext* SQLiteParser::partition_by() {
  Partition_byContext *_localctx = _tracker.createInstance<Partition_byContext>(_ctx, getState());
  enterRule(_localctx, 156, SQLiteParser::RulePartition_by);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1958);
    match(SQLiteParser::PARTITION_);
    setState(1959);
    match(SQLiteParser::BY_);
    setState(1961); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1960);
              expr(0);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1963); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_exprContext ------------------------------------------------------------------

SQLiteParser::Order_by_exprContext::Order_by_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_exprContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_exprContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Order_by_exprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Order_by_exprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}


size_t SQLiteParser::Order_by_exprContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_expr;
}

void SQLiteParser::Order_by_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expr(this);
}

void SQLiteParser::Order_by_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expr(this);
}


std::any SQLiteParser::Order_by_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_expr(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_exprContext* SQLiteParser::order_by_expr() {
  Order_by_exprContext *_localctx = _tracker.createInstance<Order_by_exprContext>(_ctx, getState());
  enterRule(_localctx, 158, SQLiteParser::RuleOrder_by_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1965);
    match(SQLiteParser::ORDER_);
    setState(1966);
    match(SQLiteParser::BY_);
    setState(1968); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1967);
      expr(0);
      setState(1970); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -33552632) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4476578029606273023) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expr_asc_descContext ------------------------------------------------------------------

SQLiteParser::Order_by_expr_asc_descContext::Order_by_expr_asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_expr_asc_descContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_expr_asc_descContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Expr_asc_descContext* SQLiteParser::Order_by_expr_asc_descContext::expr_asc_desc() {
  return getRuleContext<SQLiteParser::Expr_asc_descContext>(0);
}


size_t SQLiteParser::Order_by_expr_asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_expr_asc_desc;
}

void SQLiteParser::Order_by_expr_asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expr_asc_desc(this);
}

void SQLiteParser::Order_by_expr_asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expr_asc_desc(this);
}


std::any SQLiteParser::Order_by_expr_asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_expr_asc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_expr_asc_descContext* SQLiteParser::order_by_expr_asc_desc() {
  Order_by_expr_asc_descContext *_localctx = _tracker.createInstance<Order_by_expr_asc_descContext>(_ctx, getState());
  enterRule(_localctx, 160, SQLiteParser::RuleOrder_by_expr_asc_desc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1972);
    match(SQLiteParser::ORDER_);
    setState(1973);
    match(SQLiteParser::BY_);
    setState(1974);
    expr_asc_desc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_asc_descContext ------------------------------------------------------------------

SQLiteParser::Expr_asc_descContext::Expr_asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Expr_asc_descContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Expr_asc_descContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Asc_descContext *> SQLiteParser::Expr_asc_descContext::asc_desc() {
  return getRuleContexts<SQLiteParser::Asc_descContext>();
}

SQLiteParser::Asc_descContext* SQLiteParser::Expr_asc_descContext::asc_desc(size_t i) {
  return getRuleContext<SQLiteParser::Asc_descContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Expr_asc_descContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Expr_asc_descContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Expr_asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleExpr_asc_desc;
}

void SQLiteParser::Expr_asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_asc_desc(this);
}

void SQLiteParser::Expr_asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_asc_desc(this);
}


std::any SQLiteParser::Expr_asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitExpr_asc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Expr_asc_descContext* SQLiteParser::expr_asc_desc() {
  Expr_asc_descContext *_localctx = _tracker.createInstance<Expr_asc_descContext>(_ctx, getState());
  enterRule(_localctx, 162, SQLiteParser::RuleExpr_asc_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1976);
    expr(0);
    setState(1978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(1977);
      asc_desc();
    }
    setState(1987);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1980);
      match(SQLiteParser::COMMA);
      setState(1981);
      expr(0);
      setState(1983);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ASC_

      || _la == SQLiteParser::DESC_) {
        setState(1982);
        asc_desc();
      }
      setState(1989);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_selectContext ------------------------------------------------------------------

SQLiteParser::Initial_selectContext::Initial_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Initial_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Initial_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleInitial_select;
}

void SQLiteParser::Initial_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_select(this);
}

void SQLiteParser::Initial_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_select(this);
}


std::any SQLiteParser::Initial_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInitial_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Initial_selectContext* SQLiteParser::initial_select() {
  Initial_selectContext *_localctx = _tracker.createInstance<Initial_selectContext>(_ctx, getState());
  enterRule(_localctx, 164, SQLiteParser::RuleInitial_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1990);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_selectContext ------------------------------------------------------------------

SQLiteParser::Recursive_selectContext::Recursive_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Recursive_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Recursive_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_select;
}

void SQLiteParser::Recursive_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_select(this);
}

void SQLiteParser::Recursive_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_select(this);
}


std::any SQLiteParser::Recursive_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::recursive_select() {
  Recursive_selectContext *_localctx = _tracker.createInstance<Recursive_selectContext>(_ctx, getState());
  enterRule(_localctx, 166, SQLiteParser::RuleRecursive_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1992);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

SQLiteParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::TILDE() {
  return getToken(SQLiteParser::TILDE, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Unary_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleUnary_operator;
}

void SQLiteParser::Unary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator(this);
}

void SQLiteParser::Unary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator(this);
}


std::any SQLiteParser::Unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUnary_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Unary_operatorContext* SQLiteParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 168, SQLiteParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1994);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1792) != 0) || _la == SQLiteParser::NOT_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_messageContext ------------------------------------------------------------------

SQLiteParser::Error_messageContext::Error_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Error_messageContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Error_messageContext::getRuleIndex() const {
  return SQLiteParser::RuleError_message;
}

void SQLiteParser::Error_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterError_message(this);
}

void SQLiteParser::Error_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitError_message(this);
}


std::any SQLiteParser::Error_messageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitError_message(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Error_messageContext* SQLiteParser::error_message() {
  Error_messageContext *_localctx = _tracker.createInstance<Error_messageContext>(_ctx, getState());
  enterRule(_localctx, 170, SQLiteParser::RuleError_message);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1996);
    match(SQLiteParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_argumentContext ------------------------------------------------------------------

SQLiteParser::Module_argumentContext::Module_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Module_argumentContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Column_defContext* SQLiteParser::Module_argumentContext::column_def() {
  return getRuleContext<SQLiteParser::Column_defContext>(0);
}


size_t SQLiteParser::Module_argumentContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_argument;
}

void SQLiteParser::Module_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_argument(this);
}

void SQLiteParser::Module_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_argument(this);
}


std::any SQLiteParser::Module_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_argument(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_argumentContext* SQLiteParser::module_argument() {
  Module_argumentContext *_localctx = _tracker.createInstance<Module_argumentContext>(_ctx, getState());
  enterRule(_localctx, 172, SQLiteParser::RuleModule_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2000);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1998);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1999);
      column_def();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

SQLiteParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_aliasContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}

tree::TerminalNode* SQLiteParser::Column_aliasContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Column_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_alias;
}

void SQLiteParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void SQLiteParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}


std::any SQLiteParser::Column_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_aliasContext* SQLiteParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 174, SQLiteParser::RuleColumn_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2002);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::IDENTIFIER

    || _la == SQLiteParser::STRING_LITERAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

SQLiteParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::KeywordContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ACTION_() {
  return getToken(SQLiteParser::ACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASCADE_() {
  return getToken(SQLiteParser::CASCADE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FULL_() {
  return getToken(SQLiteParser::FULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OF_() {
  return getToken(SQLiteParser::OF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RESTRICT_() {
  return getToken(SQLiteParser::RESTRICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RIGHT_() {
  return getToken(SQLiteParser::RIGHT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::THEN_() {
  return getToken(SQLiteParser::THEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITHOUT_() {
  return getToken(SQLiteParser::WITHOUT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FIRST_VALUE_() {
  return getToken(SQLiteParser::FIRST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CUME_DIST_() {
  return getToken(SQLiteParser::CUME_DIST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DENSE_RANK_() {
  return getToken(SQLiteParser::DENSE_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAG_() {
  return getToken(SQLiteParser::LAG_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAST_VALUE_() {
  return getToken(SQLiteParser::LAST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LEAD_() {
  return getToken(SQLiteParser::LEAD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NTH_VALUE_() {
  return getToken(SQLiteParser::NTH_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NTILE_() {
  return getToken(SQLiteParser::NTILE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PERCENT_RANK_() {
  return getToken(SQLiteParser::PERCENT_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANK_() {
  return getToken(SQLiteParser::RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROW_NUMBER_() {
  return getToken(SQLiteParser::ROW_NUMBER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}


size_t SQLiteParser::KeywordContext::getRuleIndex() const {
  return SQLiteParser::RuleKeyword;
}

void SQLiteParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void SQLiteParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


std::any SQLiteParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::KeywordContext* SQLiteParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 176, SQLiteParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2004);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -33554432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 9007199254740991) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

SQLiteParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::NameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::NameContext::getRuleIndex() const {
  return SQLiteParser::RuleName;
}

void SQLiteParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void SQLiteParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any SQLiteParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::NameContext* SQLiteParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 178, SQLiteParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2006);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_nameContext ------------------------------------------------------------------

SQLiteParser::Function_nameContext::Function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleFunction_name;
}

void SQLiteParser::Function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_name(this);
}

void SQLiteParser::Function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_name(this);
}


std::any SQLiteParser::Function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFunction_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Function_nameContext* SQLiteParser::function_name() {
  Function_nameContext *_localctx = _tracker.createInstance<Function_nameContext>(_ctx, getState());
  enterRule(_localctx, 180, SQLiteParser::RuleFunction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2008);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_nameContext ------------------------------------------------------------------

SQLiteParser::Schema_nameContext::Schema_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Schema_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Schema_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSchema_name;
}

void SQLiteParser::Schema_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_name(this);
}

void SQLiteParser::Schema_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_name(this);
}


std::any SQLiteParser::Schema_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSchema_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Schema_nameContext* SQLiteParser::schema_name() {
  Schema_nameContext *_localctx = _tracker.createInstance<Schema_nameContext>(_ctx, getState());
  enterRule(_localctx, 182, SQLiteParser::RuleSchema_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2010);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

SQLiteParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_name;
}

void SQLiteParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void SQLiteParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}


std::any SQLiteParser::Table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_nameContext* SQLiteParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 184, SQLiteParser::RuleTable_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2012);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_index_nameContext ------------------------------------------------------------------

SQLiteParser::Table_or_index_nameContext::Table_or_index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_or_index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_or_index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_index_name;
}

void SQLiteParser::Table_or_index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_or_index_name(this);
}

void SQLiteParser::Table_or_index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_or_index_name(this);
}


std::any SQLiteParser::Table_or_index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_or_index_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::table_or_index_name() {
  Table_or_index_nameContext *_localctx = _tracker.createInstance<Table_or_index_nameContext>(_ctx, getState());
  enterRule(_localctx, 186, SQLiteParser::RuleTable_or_index_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2014);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_nameContext ------------------------------------------------------------------

SQLiteParser::Column_nameContext::Column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Column_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Column_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name;
}

void SQLiteParser::Column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name(this);
}

void SQLiteParser::Column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name(this);
}


std::any SQLiteParser::Column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_nameContext* SQLiteParser::column_name() {
  Column_nameContext *_localctx = _tracker.createInstance<Column_nameContext>(_ctx, getState());
  enterRule(_localctx, 188, SQLiteParser::RuleColumn_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2016);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collation_nameContext ------------------------------------------------------------------

SQLiteParser::Collation_nameContext::Collation_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Collation_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Collation_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCollation_name;
}

void SQLiteParser::Collation_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollation_name(this);
}

void SQLiteParser::Collation_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollation_name(this);
}


std::any SQLiteParser::Collation_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCollation_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Collation_nameContext* SQLiteParser::collation_name() {
  Collation_nameContext *_localctx = _tracker.createInstance<Collation_nameContext>(_ctx, getState());
  enterRule(_localctx, 190, SQLiteParser::RuleCollation_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2018);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_tableContext ------------------------------------------------------------------

SQLiteParser::Foreign_tableContext::Foreign_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Foreign_tableContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Foreign_tableContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_table;
}

void SQLiteParser::Foreign_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_table(this);
}

void SQLiteParser::Foreign_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_table(this);
}


std::any SQLiteParser::Foreign_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_table(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::foreign_table() {
  Foreign_tableContext *_localctx = _tracker.createInstance<Foreign_tableContext>(_ctx, getState());
  enterRule(_localctx, 192, SQLiteParser::RuleForeign_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2020);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_nameContext ------------------------------------------------------------------

SQLiteParser::Index_nameContext::Index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleIndex_name;
}

void SQLiteParser::Index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_name(this);
}

void SQLiteParser::Index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_name(this);
}


std::any SQLiteParser::Index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndex_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Index_nameContext* SQLiteParser::index_name() {
  Index_nameContext *_localctx = _tracker.createInstance<Index_nameContext>(_ctx, getState());
  enterRule(_localctx, 194, SQLiteParser::RuleIndex_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_nameContext ------------------------------------------------------------------

SQLiteParser::Trigger_nameContext::Trigger_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Trigger_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Trigger_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTrigger_name;
}

void SQLiteParser::Trigger_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_name(this);
}

void SQLiteParser::Trigger_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_name(this);
}


std::any SQLiteParser::Trigger_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::trigger_name() {
  Trigger_nameContext *_localctx = _tracker.createInstance<Trigger_nameContext>(_ctx, getState());
  enterRule(_localctx, 196, SQLiteParser::RuleTrigger_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2024);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_nameContext ------------------------------------------------------------------

SQLiteParser::View_nameContext::View_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::View_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::View_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleView_name;
}

void SQLiteParser::View_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_name(this);
}

void SQLiteParser::View_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_name(this);
}


std::any SQLiteParser::View_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitView_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::View_nameContext* SQLiteParser::view_name() {
  View_nameContext *_localctx = _tracker.createInstance<View_nameContext>(_ctx, getState());
  enterRule(_localctx, 198, SQLiteParser::RuleView_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2026);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_nameContext ------------------------------------------------------------------

SQLiteParser::Module_nameContext::Module_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Module_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Module_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_name;
}

void SQLiteParser::Module_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_name(this);
}

void SQLiteParser::Module_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_name(this);
}


std::any SQLiteParser::Module_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_nameContext* SQLiteParser::module_name() {
  Module_nameContext *_localctx = _tracker.createInstance<Module_nameContext>(_ctx, getState());
  enterRule(_localctx, 200, SQLiteParser::RuleModule_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2028);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_nameContext ------------------------------------------------------------------

SQLiteParser::Pragma_nameContext::Pragma_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Pragma_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Pragma_nameContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_name;
}

void SQLiteParser::Pragma_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_name(this);
}

void SQLiteParser::Pragma_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_name(this);
}


std::any SQLiteParser::Pragma_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::pragma_name() {
  Pragma_nameContext *_localctx = _tracker.createInstance<Pragma_nameContext>(_ctx, getState());
  enterRule(_localctx, 202, SQLiteParser::RulePragma_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2030);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_nameContext ------------------------------------------------------------------

SQLiteParser::Savepoint_nameContext::Savepoint_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Savepoint_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Savepoint_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_name;
}

void SQLiteParser::Savepoint_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_name(this);
}

void SQLiteParser::Savepoint_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_name(this);
}


std::any SQLiteParser::Savepoint_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::savepoint_name() {
  Savepoint_nameContext *_localctx = _tracker.createInstance<Savepoint_nameContext>(_ctx, getState());
  enterRule(_localctx, 204, SQLiteParser::RuleSavepoint_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2032);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

SQLiteParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_aliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_alias;
}

void SQLiteParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void SQLiteParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}


std::any SQLiteParser::Table_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_aliasContext* SQLiteParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 206, SQLiteParser::RuleTable_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2034);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_nameContext ------------------------------------------------------------------

SQLiteParser::Transaction_nameContext::Transaction_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Transaction_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Transaction_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTransaction_name;
}

void SQLiteParser::Transaction_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_name(this);
}

void SQLiteParser::Transaction_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_name(this);
}


std::any SQLiteParser::Transaction_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Transaction_nameContext* SQLiteParser::transaction_name() {
  Transaction_nameContext *_localctx = _tracker.createInstance<Transaction_nameContext>(_ctx, getState());
  enterRule(_localctx, 208, SQLiteParser::RuleTransaction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2036);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_nameContext ------------------------------------------------------------------

SQLiteParser::Window_nameContext::Window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_name;
}

void SQLiteParser::Window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_name(this);
}

void SQLiteParser::Window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_name(this);
}


std::any SQLiteParser::Window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_nameContext* SQLiteParser::window_name() {
  Window_nameContext *_localctx = _tracker.createInstance<Window_nameContext>(_ctx, getState());
  enterRule(_localctx, 210, SQLiteParser::RuleWindow_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2038);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasContext ------------------------------------------------------------------

SQLiteParser::AliasContext::AliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::AliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::AliasContext::getRuleIndex() const {
  return SQLiteParser::RuleAlias;
}

void SQLiteParser::AliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlias(this);
}

void SQLiteParser::AliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlias(this);
}


std::any SQLiteParser::AliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::AliasContext* SQLiteParser::alias() {
  AliasContext *_localctx = _tracker.createInstance<AliasContext>(_ctx, getState());
  enterRule(_localctx, 212, SQLiteParser::RuleAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2040);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilenameContext ------------------------------------------------------------------

SQLiteParser::FilenameContext::FilenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::FilenameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::FilenameContext::getRuleIndex() const {
  return SQLiteParser::RuleFilename;
}

void SQLiteParser::FilenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilename(this);
}

void SQLiteParser::FilenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilename(this);
}


std::any SQLiteParser::FilenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilename(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::FilenameContext* SQLiteParser::filename() {
  FilenameContext *_localctx = _tracker.createInstance<FilenameContext>(_ctx, getState());
  enterRule(_localctx, 214, SQLiteParser::RuleFilename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2042);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_window_nameContext ------------------------------------------------------------------

SQLiteParser::Base_window_nameContext::Base_window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Base_window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Base_window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleBase_window_name;
}

void SQLiteParser::Base_window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBase_window_name(this);
}

void SQLiteParser::Base_window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBase_window_name(this);
}


std::any SQLiteParser::Base_window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBase_window_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::base_window_name() {
  Base_window_nameContext *_localctx = _tracker.createInstance<Base_window_nameContext>(_ctx, getState());
  enterRule(_localctx, 216, SQLiteParser::RuleBase_window_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2044);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_funcContext ------------------------------------------------------------------

SQLiteParser::Simple_funcContext::Simple_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Simple_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Simple_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_func;
}

void SQLiteParser::Simple_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_func(this);
}

void SQLiteParser::Simple_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_func(this);
}


std::any SQLiteParser::Simple_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_funcContext* SQLiteParser::simple_func() {
  Simple_funcContext *_localctx = _tracker.createInstance<Simple_funcContext>(_ctx, getState());
  enterRule(_localctx, 218, SQLiteParser::RuleSimple_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2046);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_funcContext ------------------------------------------------------------------

SQLiteParser::Aggregate_funcContext::Aggregate_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Aggregate_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Aggregate_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_func;
}

void SQLiteParser::Aggregate_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_func(this);
}

void SQLiteParser::Aggregate_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_func(this);
}


std::any SQLiteParser::Aggregate_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::aggregate_func() {
  Aggregate_funcContext *_localctx = _tracker.createInstance<Aggregate_funcContext>(_ctx, getState());
  enterRule(_localctx, 220, SQLiteParser::RuleAggregate_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2048);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_function_nameContext ------------------------------------------------------------------

SQLiteParser::Table_function_nameContext::Table_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_function_name;
}

void SQLiteParser::Table_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_function_name(this);
}

void SQLiteParser::Table_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_function_name(this);
}


std::any SQLiteParser::Table_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_function_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::table_function_name() {
  Table_function_nameContext *_localctx = _tracker.createInstance<Table_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 222, SQLiteParser::RuleTable_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2050);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_nameContext ------------------------------------------------------------------

SQLiteParser::Any_nameContext::Any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Any_nameContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}

SQLiteParser::KeywordContext* SQLiteParser::Any_nameContext::keyword() {
  return getRuleContext<SQLiteParser::KeywordContext>(0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Any_nameContext* SQLiteParser::Any_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Any_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleAny_name;
}

void SQLiteParser::Any_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_name(this);
}

void SQLiteParser::Any_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_name(this);
}


std::any SQLiteParser::Any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAny_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Any_nameContext* SQLiteParser::any_name() {
  Any_nameContext *_localctx = _tracker.createInstance<Any_nameContext>(_ctx, getState());
  enterRule(_localctx, 224, SQLiteParser::RuleAny_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2059);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2052);
        match(SQLiteParser::IDENTIFIER);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_: {
        enterOuterAlt(_localctx, 2);
        setState(2053);
        keyword();
        break;
      }

      case SQLiteParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(2054);
        match(SQLiteParser::STRING_LITERAL);
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        enterOuterAlt(_localctx, 4);
        setState(2055);
        match(SQLiteParser::OPEN_PAR);
        setState(2056);
        any_name();
        setState(2057);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SQLiteParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 32: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SQLiteParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 20);
    case 1: return precpred(_ctx, 19);
    case 2: return precpred(_ctx, 18);
    case 3: return precpred(_ctx, 17);
    case 4: return precpred(_ctx, 16);
    case 5: return precpred(_ctx, 15);
    case 6: return precpred(_ctx, 14);
    case 7: return precpred(_ctx, 13);
    case 8: return precpred(_ctx, 6);
    case 9: return precpred(_ctx, 5);
    case 10: return precpred(_ctx, 9);
    case 11: return precpred(_ctx, 8);
    case 12: return precpred(_ctx, 7);
    case 13: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

void SQLiteParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  sqliteparserParserInitialize();
#else
  ::antlr4::internal::call_once(sqliteparserParserOnceFlag, sqliteparserParserInitialize);
#endif
}
