
// Generated from SQLiteParser.g4 by ANTLR 4.13.2


#include "SQLiteParserListener.h"
#include "SQLiteParserVisitor.h"

#include "SQLiteParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct SQLiteParserStaticData final {
  SQLiteParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  SQLiteParserStaticData(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData(SQLiteParserStaticData&&) = delete;
  SQLiteParserStaticData& operator=(const SQLiteParserStaticData&) = delete;
  SQLiteParserStaticData& operator=(SQLiteParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag sqliteparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<SQLiteParserStaticData> sqliteparserParserStaticData = nullptr;

void sqliteparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (sqliteparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(sqliteparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<SQLiteParserStaticData>(
    std::vector<std::string>{
      "parse", "sql_stmt_list", "sql_stmt", "alter_table_stmt", "analyze_stmt", 
      "attach_stmt", "begin_stmt", "commit_stmt", "rollback_stmt", "savepoint_stmt", 
      "release_stmt", "create_index_stmt", "indexed_column", "create_table_stmt", 
      "column_def", "type_name", "column_constraint", "signed_number", "table_constraint", 
      "foreign_key_clause", "conflict_clause", "create_trigger_stmt", "create_view_stmt", 
      "create_virtual_table_stmt", "with_clause", "cte_table_name", "recursive_cte", 
      "common_table_expression", "delete_stmt", "delete_stmt_limited", "detach_stmt", 
      "drop_stmt", "expr", "raise_function", "literal_value", "value_row", 
      "values_clause", "insert_stmt", "returning_clause", "upsert_clause", 
      "pragma_stmt", "pragma_value", "reindex_stmt", "select_stmt", "join_clause", 
      "select_core", "factored_select_stmt", "simple_select_stmt", "compound_select_stmt", 
      "table_or_subquery", "result_column", "join_operator", "join_constraint", 
      "compound_operator", "update_stmt", "column_name_list", "update_stmt_limited", 
      "qualified_table_name", "vacuum_stmt", "filter_clause", "window_defn", 
      "over_clause", "frame_spec", "frame_clause", "simple_function_invocation", 
      "aggregate_function_invocation", "window_function_invocation", "common_table_stmt", 
      "order_by_stmt", "limit_stmt", "ordering_term", "asc_desc", "frame_left", 
      "frame_right", "frame_single", "window_function", "offset", "default_value", 
      "partition_by", "order_by_expr", "order_by_expr_asc_desc", "expr_asc_desc", 
      "initial_select", "recursive_select", "unary_operator", "error_message", 
      "module_argument", "column_alias", "keyword", "name", "function_name", 
      "schema_name", "table_name", "table_or_index_name", "column_name", 
      "collation_name", "foreign_table", "index_name", "trigger_name", "view_name", 
      "module_name", "pragma_name", "savepoint_name", "table_alias", "transaction_name", 
      "window_name", "alias", "filename", "base_window_name", "simple_func", 
      "aggregate_func", "table_function_name", "any_name"
    },
    std::vector<std::string>{
      "", "';'", "'.'", "'('", "')'", "','", "'='", "'*'", "'+'", "'-'", 
      "'~'", "'||'", "'/'", "'%'", "'<<'", "'>>'", "'&'", "'|'", "'<'", 
      "'<='", "'>'", "'>='", "'=='", "'!='", "'<>'", "'ABORT'", "'ACTION'", 
      "'ADD'", "'AFTER'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'AS'", 
      "'ASC'", "'ATTACH'", "'AUTOINCREMENT'", "'BEFORE'", "'BEGIN'", "'BETWEEN'", 
      "'BY'", "'CASCADE'", "'CASE'", "'CAST'", "'CHECK'", "'COLLATE'", "'COLUMN'", 
      "'COMMIT'", "'CONFLICT'", "'CONSTRAINT'", "'CREATE'", "'CROSS'", "'CURRENT_DATE'", 
      "'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'DATABASE'", "'DEFAULT'", 
      "'DEFERRABLE'", "'DEFERRED'", "'DELETE'", "'DESC'", "'DETACH'", "'DISTINCT'", 
      "'DROP'", "'EACH'", "'ELSE'", "'END'", "'ESCAPE'", "'EXCEPT'", "'EXCLUSIVE'", 
      "'EXISTS'", "'EXPLAIN'", "'FAIL'", "'FOR'", "'FOREIGN'", "'FROM'", 
      "'FULL'", "'GLOB'", "'GROUP'", "'HAVING'", "'IF'", "'IGNORE'", "'IMMEDIATE'", 
      "'IN'", "'INDEX'", "'INDEXED'", "'INITIALLY'", "'INNER'", "'INSERT'", 
      "'INSTEAD'", "'INTERSECT'", "'INTO'", "'IS'", "'ISNULL'", "'JOIN'", 
      "'KEY'", "'LEFT'", "'LIKE'", "'LIMIT'", "'MATCH'", "'NATURAL'", "'NO'", 
      "'NOT'", "'NOTNULL'", "'NULL'", "'OF'", "'OFFSET'", "'ON'", "'OR'", 
      "'ORDER'", "'OUTER'", "'PLAN'", "'PRAGMA'", "'PRIMARY'", "'QUERY'", 
      "'RAISE'", "'RECURSIVE'", "'REFERENCES'", "'REGEXP'", "'REINDEX'", 
      "'RELEASE'", "'RENAME'", "'REPLACE'", "'RESTRICT'", "'RETURNING'", 
      "'RIGHT'", "'ROLLBACK'", "'ROW'", "'ROWS'", "'SAVEPOINT'", "'SELECT'", 
      "'SET'", "'TABLE'", "'TEMP'", "'TEMPORARY'", "'THEN'", "'TO'", "'TRANSACTION'", 
      "'TRIGGER'", "'UNION'", "'UNIQUE'", "'UPDATE'", "'USING'", "'VACUUM'", 
      "'VALUES'", "'VIEW'", "'VIRTUAL'", "'WHEN'", "'WHERE'", "'WITH'", 
      "'WITHOUT'", "'FIRST_VALUE'", "'OVER'", "'PARTITION'", "'RANGE'", 
      "'PRECEDING'", "'UNBOUNDED'", "'CURRENT'", "'FOLLOWING'", "'CUME_DIST'", 
      "'DENSE_RANK'", "'LAG'", "'LAST_VALUE'", "'LEAD'", "'NTH_VALUE'", 
      "'NTILE'", "'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'GENERATED'", 
      "'ALWAYS'", "'STORED'", "'TRUE'", "'FALSE'", "'WINDOW'", "'NULLS'", 
      "'FIRST'", "'LAST'", "'FILTER'", "'GROUPS'", "'EXCLUDE'", "'TIES'", 
      "'OTHERS'", "'DO'", "'NOTHING'"
    },
    std::vector<std::string>{
      "", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", "COMMA", "ASSIGN", "STAR", 
      "PLUS", "MINUS", "TILDE", "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", 
      "PIPE", "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
      "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", "ANALYZE_", 
      "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", "BEFORE_", "BEGIN_", 
      "BETWEEN_", "BY_", "CASCADE_", "CASE_", "CAST_", "CHECK_", "COLLATE_", 
      "COLUMN_", "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", "CROSS_", 
      "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", "DATABASE_", 
      "DEFAULT_", "DEFERRABLE_", "DEFERRED_", "DELETE_", "DESC_", "DETACH_", 
      "DISTINCT_", "DROP_", "EACH_", "ELSE_", "END_", "ESCAPE_", "EXCEPT_", 
      "EXCLUSIVE_", "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
      "FROM_", "FULL_", "GLOB_", "GROUP_", "HAVING_", "IF_", "IGNORE_", 
      "IMMEDIATE_", "IN_", "INDEX_", "INDEXED_", "INITIALLY_", "INNER_", 
      "INSERT_", "INSTEAD_", "INTERSECT_", "INTO_", "IS_", "ISNULL_", "JOIN_", 
      "KEY_", "LEFT_", "LIKE_", "LIMIT_", "MATCH_", "NATURAL_", "NO_", "NOT_", 
      "NOTNULL_", "NULL_", "OF_", "OFFSET_", "ON_", "OR_", "ORDER_", "OUTER_", 
      "PLAN_", "PRAGMA_", "PRIMARY_", "QUERY_", "RAISE_", "RECURSIVE_", 
      "REFERENCES_", "REGEXP_", "REINDEX_", "RELEASE_", "RENAME_", "REPLACE_", 
      "RESTRICT_", "RETURNING_", "RIGHT_", "ROLLBACK_", "ROW_", "ROWS_", 
      "SAVEPOINT_", "SELECT_", "SET_", "TABLE_", "TEMP_", "TEMPORARY_", 
      "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", "UNION_", "UNIQUE_", "UPDATE_", 
      "USING_", "VACUUM_", "VALUES_", "VIEW_", "VIRTUAL_", "WHEN_", "WHERE_", 
      "WITH_", "WITHOUT_", "FIRST_VALUE_", "OVER_", "PARTITION_", "RANGE_", 
      "PRECEDING_", "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "CUME_DIST_", 
      "DENSE_RANK_", "LAG_", "LAST_VALUE_", "LEAD_", "NTH_VALUE_", "NTILE_", 
      "PERCENT_RANK_", "RANK_", "ROW_NUMBER_", "GENERATED_", "ALWAYS_", 
      "STORED_", "TRUE_", "FALSE_", "WINDOW_", "NULLS_", "FIRST_", "LAST_", 
      "FILTER_", "GROUPS_", "EXCLUDE_", "TIES_", "OTHERS_", "DO_", "NOTHING_", 
      "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", "STRING_LITERAL", 
      "BLOB_LITERAL", "SINGLE_LINE_COMMENT", "MULTILINE_COMMENT", "SPACES", 
      "UNEXPECTED_CHAR"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,193,2056,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
  	2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,
  	7,14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,
  	7,21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,
  	7,28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,
  	7,35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,
  	7,42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,
  	7,49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,
  	7,56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,
  	7,63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,
  	7,70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,
  	7,77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,
  	7,84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,
  	7,91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,
  	7,98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,
  	7,104,2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,
  	7,110,2,111,7,111,2,112,7,112,1,0,5,0,228,8,0,10,0,12,0,231,9,0,1,0,1,
  	0,1,1,5,1,236,8,1,10,1,12,1,239,9,1,1,1,1,1,4,1,243,8,1,11,1,12,1,244,
  	1,1,5,1,248,8,1,10,1,12,1,251,9,1,1,1,5,1,254,8,1,10,1,12,1,257,9,1,1,
  	2,1,2,1,2,3,2,262,8,2,3,2,264,8,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
  	1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,290,8,
  	2,1,3,1,3,1,3,1,3,1,3,3,3,297,8,3,1,3,1,3,1,3,1,3,1,3,3,3,304,8,3,1,3,
  	1,3,1,3,1,3,3,3,310,8,3,1,3,1,3,3,3,314,8,3,1,3,1,3,1,3,3,3,319,8,3,1,
  	3,3,3,322,8,3,1,4,1,4,1,4,1,4,1,4,3,4,329,8,4,1,4,3,4,332,8,4,1,5,1,5,
  	3,5,336,8,5,1,5,1,5,1,5,1,5,1,6,1,6,3,6,344,8,6,1,6,1,6,3,6,348,8,6,3,
  	6,350,8,6,1,7,1,7,3,7,354,8,7,1,8,1,8,3,8,358,8,8,1,8,1,8,3,8,362,8,8,
  	1,8,3,8,365,8,8,1,9,1,9,1,9,1,10,1,10,3,10,372,8,10,1,10,1,10,1,11,1,
  	11,3,11,378,8,11,1,11,1,11,1,11,1,11,3,11,384,8,11,1,11,1,11,1,11,3,11,
  	389,8,11,1,11,1,11,1,11,1,11,1,11,1,11,1,11,5,11,398,8,11,10,11,12,11,
  	401,9,11,1,11,1,11,1,11,3,11,406,8,11,1,12,1,12,3,12,410,8,12,1,12,1,
  	12,3,12,414,8,12,1,12,3,12,417,8,12,1,13,1,13,3,13,421,8,13,1,13,1,13,
  	1,13,1,13,3,13,427,8,13,1,13,1,13,1,13,3,13,432,8,13,1,13,1,13,1,13,1,
  	13,1,13,5,13,439,8,13,10,13,12,13,442,9,13,1,13,1,13,5,13,446,8,13,10,
  	13,12,13,449,9,13,1,13,1,13,1,13,3,13,454,8,13,1,13,1,13,3,13,458,8,13,
  	1,14,1,14,3,14,462,8,14,1,14,5,14,465,8,14,10,14,12,14,468,9,14,1,15,
  	4,15,471,8,15,11,15,12,15,472,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,
  	1,15,1,15,3,15,485,8,15,1,16,1,16,3,16,489,8,16,1,16,1,16,1,16,3,16,494,
  	8,16,1,16,3,16,497,8,16,1,16,3,16,500,8,16,1,16,3,16,503,8,16,1,16,1,
  	16,3,16,507,8,16,1,16,3,16,510,8,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,
  	1,16,1,16,1,16,1,16,1,16,3,16,524,8,16,1,16,1,16,1,16,1,16,1,16,3,16,
  	531,8,16,1,16,1,16,1,16,1,16,1,16,3,16,538,8,16,3,16,540,8,16,1,17,3,
  	17,543,8,17,1,17,1,17,1,18,1,18,3,18,549,8,18,1,18,1,18,1,18,3,18,554,
  	8,18,1,18,1,18,1,18,1,18,5,18,560,8,18,10,18,12,18,563,9,18,1,18,1,18,
  	3,18,567,8,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,1,18,
  	5,18,580,8,18,10,18,12,18,583,9,18,1,18,1,18,1,18,3,18,588,8,18,1,19,
  	1,19,1,19,1,19,1,19,1,19,5,19,596,8,19,10,19,12,19,599,9,19,1,19,1,19,
  	3,19,603,8,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,3,19,613,8,19,1,
  	19,1,19,5,19,617,8,19,10,19,12,19,620,9,19,1,19,3,19,623,8,19,1,19,1,
  	19,1,19,3,19,628,8,19,3,19,630,8,19,1,20,1,20,1,20,1,20,1,21,1,21,3,21,
  	638,8,21,1,21,1,21,1,21,1,21,3,21,644,8,21,1,21,1,21,1,21,3,21,649,8,
  	21,1,21,1,21,1,21,1,21,1,21,3,21,656,8,21,1,21,1,21,1,21,1,21,1,21,1,
  	21,1,21,5,21,665,8,21,10,21,12,21,668,9,21,3,21,670,8,21,3,21,672,8,21,
  	1,21,1,21,1,21,1,21,1,21,3,21,679,8,21,1,21,1,21,3,21,683,8,21,1,21,1,
  	21,1,21,1,21,1,21,3,21,690,8,21,1,21,1,21,4,21,694,8,21,11,21,12,21,695,
  	1,21,1,21,1,22,1,22,3,22,702,8,22,1,22,1,22,1,22,1,22,3,22,708,8,22,1,
  	22,1,22,1,22,3,22,713,8,22,1,22,1,22,1,22,1,22,1,22,5,22,720,8,22,10,
  	22,12,22,723,9,22,1,22,1,22,3,22,727,8,22,1,22,1,22,1,22,1,23,1,23,1,
  	23,1,23,1,23,1,23,3,23,738,8,23,1,23,1,23,1,23,3,23,743,8,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,1,23,5,23,752,8,23,10,23,12,23,755,9,23,1,23,1,23,
  	3,23,759,8,23,1,24,1,24,3,24,763,8,24,1,24,1,24,1,24,1,24,1,24,1,24,1,
  	24,1,24,1,24,1,24,1,24,1,24,5,24,777,8,24,10,24,12,24,780,9,24,1,25,1,
  	25,1,25,1,25,1,25,5,25,787,8,25,10,25,12,25,790,9,25,1,25,1,25,3,25,794,
  	8,25,1,26,1,26,1,26,1,26,1,26,1,26,3,26,802,8,26,1,26,1,26,1,26,1,27,
  	1,27,1,27,1,27,1,27,5,27,812,8,27,10,27,12,27,815,9,27,1,27,1,27,3,27,
  	819,8,27,1,27,1,27,1,27,1,27,1,27,1,28,3,28,827,8,28,1,28,1,28,1,28,1,
  	28,1,28,3,28,834,8,28,1,28,3,28,837,8,28,1,29,3,29,840,8,29,1,29,1,29,
  	1,29,1,29,1,29,3,29,847,8,29,1,29,3,29,850,8,29,1,29,3,29,853,8,29,1,
  	29,3,29,856,8,29,1,30,1,30,3,30,860,8,30,1,30,1,30,1,31,1,31,1,31,1,31,
  	3,31,868,8,31,1,31,1,31,1,31,3,31,873,8,31,1,31,1,31,1,32,1,32,1,32,1,
  	32,1,32,1,32,3,32,883,8,32,1,32,1,32,1,32,3,32,888,8,32,1,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,3,32,897,8,32,1,32,1,32,1,32,5,32,902,8,32,10,32,
  	12,32,905,9,32,1,32,3,32,908,8,32,1,32,1,32,3,32,912,8,32,1,32,3,32,915,
  	8,32,1,32,1,32,1,32,1,32,5,32,921,8,32,10,32,12,32,924,9,32,1,32,1,32,
  	1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,936,8,32,1,32,3,32,939,8,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,947,8,32,1,32,1,32,1,32,1,32,1,
  	32,4,32,954,8,32,11,32,12,32,955,1,32,1,32,3,32,960,8,32,1,32,1,32,1,
  	32,3,32,965,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,3,32,995,8,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,1,
  	32,1,32,1,32,3,32,1007,8,32,1,32,1,32,1,32,3,32,1012,8,32,1,32,1,32,1,
  	32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,3,32,1024,8,32,1,32,1,32,1,32,1,
  	32,3,32,1030,8,32,1,32,1,32,1,32,1,32,1,32,3,32,1037,8,32,1,32,1,32,3,
  	32,1041,8,32,1,32,1,32,1,32,1,32,1,32,1,32,5,32,1049,8,32,10,32,12,32,
  	1052,9,32,3,32,1054,8,32,1,32,1,32,1,32,1,32,3,32,1060,8,32,1,32,1,32,
  	1,32,1,32,3,32,1066,8,32,1,32,1,32,1,32,1,32,1,32,5,32,1073,8,32,10,32,
  	12,32,1076,9,32,3,32,1078,8,32,1,32,1,32,3,32,1082,8,32,5,32,1084,8,32,
  	10,32,12,32,1087,9,32,1,33,1,33,1,33,1,33,1,33,1,33,3,33,1095,8,33,1,
  	33,1,33,1,34,1,34,1,35,1,35,1,35,1,35,5,35,1105,8,35,10,35,12,35,1108,
  	9,35,1,35,1,35,1,36,1,36,1,36,1,36,5,36,1116,8,36,10,36,12,36,1119,9,
  	36,1,37,3,37,1122,8,37,1,37,1,37,1,37,1,37,1,37,3,37,1129,8,37,1,37,1,
  	37,1,37,1,37,3,37,1135,8,37,1,37,1,37,1,37,3,37,1140,8,37,1,37,1,37,1,
  	37,1,37,5,37,1146,8,37,10,37,12,37,1149,9,37,1,37,1,37,3,37,1153,8,37,
  	1,37,1,37,3,37,1157,8,37,1,37,3,37,1160,8,37,1,37,1,37,3,37,1164,8,37,
  	1,37,3,37,1167,8,37,1,38,1,38,1,38,1,38,5,38,1173,8,38,10,38,12,38,1176,
  	9,38,1,39,1,39,1,39,1,39,1,39,1,39,5,39,1184,8,39,10,39,12,39,1187,9,
  	39,1,39,1,39,1,39,3,39,1192,8,39,3,39,1194,8,39,1,39,1,39,1,39,1,39,1,
  	39,1,39,3,39,1202,8,39,1,39,1,39,1,39,1,39,1,39,3,39,1209,8,39,1,39,1,
  	39,1,39,5,39,1214,8,39,10,39,12,39,1217,9,39,1,39,1,39,3,39,1221,8,39,
  	3,39,1223,8,39,1,40,1,40,1,40,1,40,3,40,1229,8,40,1,40,1,40,1,40,1,40,
  	1,40,1,40,1,40,3,40,1238,8,40,1,41,1,41,1,41,3,41,1243,8,41,1,42,1,42,
  	1,42,1,42,1,42,3,42,1250,8,42,1,42,1,42,3,42,1254,8,42,3,42,1256,8,42,
  	1,43,3,43,1259,8,43,1,43,1,43,1,43,1,43,5,43,1265,8,43,10,43,12,43,1268,
  	9,43,1,43,3,43,1271,8,43,1,43,3,43,1274,8,43,1,44,1,44,1,44,1,44,3,44,
  	1280,8,44,5,44,1282,8,44,10,44,12,44,1285,9,44,1,45,1,45,3,45,1289,8,
  	45,1,45,1,45,1,45,5,45,1294,8,45,10,45,12,45,1297,9,45,1,45,1,45,1,45,
  	1,45,5,45,1303,8,45,10,45,12,45,1306,9,45,1,45,3,45,1309,8,45,3,45,1311,
  	8,45,1,45,1,45,3,45,1315,8,45,1,45,1,45,1,45,1,45,1,45,5,45,1322,8,45,
  	10,45,12,45,1325,9,45,1,45,1,45,3,45,1329,8,45,3,45,1331,8,45,1,45,1,
  	45,1,45,1,45,1,45,1,45,1,45,1,45,1,45,5,45,1342,8,45,10,45,12,45,1345,
  	9,45,3,45,1347,8,45,1,45,3,45,1350,8,45,1,46,1,46,1,47,3,47,1355,8,47,
  	1,47,1,47,3,47,1359,8,47,1,47,3,47,1362,8,47,1,48,3,48,1365,8,48,1,48,
  	1,48,1,48,3,48,1370,8,48,1,48,1,48,3,48,1374,8,48,1,48,4,48,1377,8,48,
  	11,48,12,48,1378,1,48,3,48,1382,8,48,1,48,3,48,1385,8,48,1,49,1,49,1,
  	49,3,49,1390,8,49,1,49,1,49,3,49,1394,8,49,1,49,3,49,1397,8,49,1,49,1,
  	49,1,49,1,49,1,49,3,49,1404,8,49,1,49,1,49,1,49,3,49,1409,8,49,1,49,1,
  	49,1,49,1,49,1,49,5,49,1416,8,49,10,49,12,49,1419,9,49,1,49,1,49,3,49,
  	1423,8,49,1,49,3,49,1426,8,49,1,49,1,49,1,49,1,49,5,49,1432,8,49,10,49,
  	12,49,1435,9,49,1,49,3,49,1438,8,49,1,49,1,49,1,49,1,49,1,49,1,49,3,49,
  	1446,8,49,1,49,3,49,1449,8,49,3,49,1451,8,49,1,50,1,50,1,50,1,50,1,50,
  	1,50,1,50,3,50,1460,8,50,1,50,3,50,1463,8,50,3,50,1465,8,50,1,51,1,51,
  	3,51,1469,8,51,1,51,1,51,3,51,1473,8,51,1,51,1,51,3,51,1477,8,51,1,51,
  	3,51,1480,8,51,1,52,1,52,1,52,1,52,1,52,1,52,1,52,5,52,1489,8,52,10,52,
  	12,52,1492,9,52,1,52,1,52,3,52,1496,8,52,1,53,1,53,3,53,1500,8,53,1,53,
  	1,53,3,53,1504,8,53,1,54,3,54,1507,8,54,1,54,1,54,1,54,3,54,1512,8,54,
  	1,54,1,54,1,54,1,54,3,54,1518,8,54,1,54,1,54,1,54,1,54,1,54,3,54,1525,
  	8,54,1,54,1,54,1,54,5,54,1530,8,54,10,54,12,54,1533,9,54,1,54,1,54,1,
  	54,1,54,5,54,1539,8,54,10,54,12,54,1542,9,54,1,54,3,54,1545,8,54,3,54,
  	1547,8,54,1,54,1,54,3,54,1551,8,54,1,54,3,54,1554,8,54,1,55,1,55,1,55,
  	1,55,5,55,1560,8,55,10,55,12,55,1563,9,55,1,55,1,55,1,56,3,56,1568,8,
  	56,1,56,1,56,1,56,3,56,1573,8,56,1,56,1,56,1,56,1,56,3,56,1579,8,56,1,
  	56,1,56,1,56,1,56,1,56,3,56,1586,8,56,1,56,1,56,1,56,5,56,1591,8,56,10,
  	56,12,56,1594,9,56,1,56,1,56,3,56,1598,8,56,1,56,3,56,1601,8,56,1,56,
  	3,56,1604,8,56,1,56,3,56,1607,8,56,1,57,1,57,1,57,3,57,1612,8,57,1,57,
  	1,57,1,57,3,57,1617,8,57,1,57,1,57,1,57,1,57,1,57,3,57,1624,8,57,1,58,
  	1,58,3,58,1628,8,58,1,58,1,58,3,58,1632,8,58,1,59,1,59,1,59,1,59,1,59,
  	1,59,1,60,1,60,3,60,1642,8,60,1,60,1,60,1,60,1,60,1,60,5,60,1649,8,60,
  	10,60,12,60,1652,9,60,3,60,1654,8,60,1,60,1,60,1,60,1,60,1,60,5,60,1661,
  	8,60,10,60,12,60,1664,9,60,1,60,3,60,1667,8,60,1,60,1,60,1,61,1,61,1,
  	61,1,61,3,61,1675,8,61,1,61,1,61,1,61,1,61,1,61,5,61,1682,8,61,10,61,
  	12,61,1685,9,61,3,61,1687,8,61,1,61,1,61,1,61,1,61,1,61,5,61,1694,8,61,
  	10,61,12,61,1697,9,61,3,61,1699,8,61,1,61,3,61,1702,8,61,1,61,3,61,1705,
  	8,61,1,62,1,62,1,62,1,62,1,62,1,62,1,62,1,62,3,62,1715,8,62,3,62,1717,
  	8,62,1,63,1,63,1,63,1,63,1,63,1,63,1,63,3,63,1726,8,63,1,64,1,64,1,64,
  	1,64,1,64,5,64,1733,8,64,10,64,12,64,1736,9,64,1,64,3,64,1739,8,64,1,
  	64,1,64,1,65,1,65,1,65,3,65,1746,8,65,1,65,1,65,1,65,5,65,1751,8,65,10,
  	65,12,65,1754,9,65,1,65,3,65,1757,8,65,1,65,1,65,3,65,1761,8,65,1,66,
  	1,66,1,66,1,66,1,66,5,66,1768,8,66,10,66,12,66,1771,9,66,1,66,3,66,1774,
  	8,66,1,66,1,66,3,66,1778,8,66,1,66,1,66,1,66,3,66,1783,8,66,1,67,1,67,
  	3,67,1787,8,67,1,67,1,67,1,67,5,67,1792,8,67,10,67,12,67,1795,9,67,1,
  	68,1,68,1,68,1,68,1,68,5,68,1802,8,68,10,68,12,68,1805,9,68,1,69,1,69,
  	1,69,1,69,3,69,1811,8,69,1,70,1,70,1,70,3,70,1816,8,70,1,70,3,70,1819,
  	8,70,1,70,1,70,3,70,1823,8,70,1,71,1,71,1,72,1,72,1,72,1,72,1,72,1,72,
  	1,72,1,72,1,72,1,72,3,72,1837,8,72,1,73,1,73,1,73,1,73,1,73,1,73,1,73,
  	1,73,1,73,1,73,3,73,1849,8,73,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,
  	1858,8,74,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1867,8,75,1,75,1,75,
  	3,75,1871,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1881,8,75,
  	1,75,3,75,1884,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1893,8,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1902,8,75,1,75,3,75,1905,8,75,
  	1,75,1,75,1,75,1,75,3,75,1911,8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,3,75,1925,8,75,1,75,1,75,3,75,1929,8,75,1,75,
  	1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,1940,8,75,1,75,1,75,1,75,
  	3,75,1945,8,75,1,76,1,76,1,76,1,77,1,77,1,77,1,78,1,78,1,78,4,78,1956,
  	8,78,11,78,12,78,1957,1,79,1,79,1,79,4,79,1963,8,79,11,79,12,79,1964,
  	1,80,1,80,1,80,1,80,1,81,1,81,3,81,1973,8,81,1,81,1,81,1,81,3,81,1978,
  	8,81,5,81,1980,8,81,10,81,12,81,1983,9,81,1,82,1,82,1,83,1,83,1,84,1,
  	84,1,85,1,85,1,86,1,86,3,86,1995,8,86,1,87,1,87,1,88,1,88,1,89,1,89,1,
  	90,1,90,1,91,1,91,1,92,1,92,1,93,1,93,1,94,1,94,1,95,1,95,1,96,1,96,1,
  	97,1,97,1,98,1,98,1,99,1,99,1,100,1,100,1,101,1,101,1,102,1,102,1,103,
  	1,103,1,104,1,104,1,105,1,105,1,106,1,106,1,107,1,107,1,108,1,108,1,109,
  	1,109,1,110,1,110,1,111,1,111,1,112,1,112,1,112,1,112,1,112,1,112,1,112,
  	3,112,2054,8,112,1,112,2,440,472,1,64,113,0,2,4,6,8,10,12,14,16,18,20,
  	22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,
  	68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,
  	112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,
  	148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,
  	184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,
  	220,222,224,0,28,3,0,58,58,69,69,82,82,2,0,47,47,66,66,1,0,133,134,2,
  	0,146,146,171,171,1,0,8,9,2,0,59,59,141,141,2,0,56,56,104,104,2,0,58,
  	58,82,82,5,0,25,25,72,72,81,81,122,122,126,126,4,0,84,84,132,132,138,
  	138,145,145,2,0,7,7,12,13,1,0,14,17,1,0,18,21,4,0,77,77,97,97,99,99,118,
  	118,3,0,25,25,72,72,126,126,5,0,52,54,104,104,172,173,186,186,188,189,
  	2,0,29,29,62,62,3,0,128,128,154,154,179,179,2,0,5,5,106,106,1,0,176,177,
  	2,0,34,34,60,60,2,0,151,151,162,162,2,0,159,159,166,166,2,0,160,160,167,
  	168,2,0,161,161,163,163,2,0,8,10,102,102,2,0,185,185,188,188,2,0,25,123,
  	125,180,2338,0,229,1,0,0,0,2,237,1,0,0,0,4,263,1,0,0,0,6,291,1,0,0,0,
  	8,323,1,0,0,0,10,333,1,0,0,0,12,341,1,0,0,0,14,351,1,0,0,0,16,355,1,0,
  	0,0,18,366,1,0,0,0,20,369,1,0,0,0,22,375,1,0,0,0,24,409,1,0,0,0,26,418,
  	1,0,0,0,28,459,1,0,0,0,30,470,1,0,0,0,32,488,1,0,0,0,34,542,1,0,0,0,36,
  	548,1,0,0,0,38,589,1,0,0,0,40,631,1,0,0,0,42,635,1,0,0,0,44,699,1,0,0,
  	0,46,731,1,0,0,0,48,760,1,0,0,0,50,781,1,0,0,0,52,795,1,0,0,0,54,806,
  	1,0,0,0,56,826,1,0,0,0,58,839,1,0,0,0,60,857,1,0,0,0,62,863,1,0,0,0,64,
  	964,1,0,0,0,66,1088,1,0,0,0,68,1098,1,0,0,0,70,1100,1,0,0,0,72,1111,1,
  	0,0,0,74,1121,1,0,0,0,76,1168,1,0,0,0,78,1177,1,0,0,0,80,1224,1,0,0,0,
  	82,1242,1,0,0,0,84,1244,1,0,0,0,86,1258,1,0,0,0,88,1275,1,0,0,0,90,1349,
  	1,0,0,0,92,1351,1,0,0,0,94,1354,1,0,0,0,96,1364,1,0,0,0,98,1450,1,0,0,
  	0,100,1464,1,0,0,0,102,1479,1,0,0,0,104,1495,1,0,0,0,106,1503,1,0,0,0,
  	108,1506,1,0,0,0,110,1555,1,0,0,0,112,1567,1,0,0,0,114,1611,1,0,0,0,116,
  	1625,1,0,0,0,118,1633,1,0,0,0,120,1639,1,0,0,0,122,1670,1,0,0,0,124,1706,
  	1,0,0,0,126,1718,1,0,0,0,128,1727,1,0,0,0,130,1742,1,0,0,0,132,1762,1,
  	0,0,0,134,1784,1,0,0,0,136,1796,1,0,0,0,138,1806,1,0,0,0,140,1812,1,0,
  	0,0,142,1824,1,0,0,0,144,1836,1,0,0,0,146,1848,1,0,0,0,148,1857,1,0,0,
  	0,150,1944,1,0,0,0,152,1946,1,0,0,0,154,1949,1,0,0,0,156,1952,1,0,0,0,
  	158,1959,1,0,0,0,160,1966,1,0,0,0,162,1970,1,0,0,0,164,1984,1,0,0,0,166,
  	1986,1,0,0,0,168,1988,1,0,0,0,170,1990,1,0,0,0,172,1994,1,0,0,0,174,1996,
  	1,0,0,0,176,1998,1,0,0,0,178,2000,1,0,0,0,180,2002,1,0,0,0,182,2004,1,
  	0,0,0,184,2006,1,0,0,0,186,2008,1,0,0,0,188,2010,1,0,0,0,190,2012,1,0,
  	0,0,192,2014,1,0,0,0,194,2016,1,0,0,0,196,2018,1,0,0,0,198,2020,1,0,0,
  	0,200,2022,1,0,0,0,202,2024,1,0,0,0,204,2026,1,0,0,0,206,2028,1,0,0,0,
  	208,2030,1,0,0,0,210,2032,1,0,0,0,212,2034,1,0,0,0,214,2036,1,0,0,0,216,
  	2038,1,0,0,0,218,2040,1,0,0,0,220,2042,1,0,0,0,222,2044,1,0,0,0,224,2053,
  	1,0,0,0,226,228,3,2,1,0,227,226,1,0,0,0,228,231,1,0,0,0,229,227,1,0,0,
  	0,229,230,1,0,0,0,230,232,1,0,0,0,231,229,1,0,0,0,232,233,5,0,0,1,233,
  	1,1,0,0,0,234,236,5,1,0,0,235,234,1,0,0,0,236,239,1,0,0,0,237,235,1,0,
  	0,0,237,238,1,0,0,0,238,240,1,0,0,0,239,237,1,0,0,0,240,249,3,4,2,0,241,
  	243,5,1,0,0,242,241,1,0,0,0,243,244,1,0,0,0,244,242,1,0,0,0,244,245,1,
  	0,0,0,245,246,1,0,0,0,246,248,3,4,2,0,247,242,1,0,0,0,248,251,1,0,0,0,
  	249,247,1,0,0,0,249,250,1,0,0,0,250,255,1,0,0,0,251,249,1,0,0,0,252,254,
  	5,1,0,0,253,252,1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,255,256,1,0,0,
  	0,256,3,1,0,0,0,257,255,1,0,0,0,258,261,5,71,0,0,259,260,5,114,0,0,260,
  	262,5,111,0,0,261,259,1,0,0,0,261,262,1,0,0,0,262,264,1,0,0,0,263,258,
  	1,0,0,0,263,264,1,0,0,0,264,289,1,0,0,0,265,290,3,6,3,0,266,290,3,8,4,
  	0,267,290,3,10,5,0,268,290,3,12,6,0,269,290,3,14,7,0,270,290,3,22,11,
  	0,271,290,3,26,13,0,272,290,3,42,21,0,273,290,3,44,22,0,274,290,3,46,
  	23,0,275,290,3,56,28,0,276,290,3,58,29,0,277,290,3,60,30,0,278,290,3,
  	62,31,0,279,290,3,74,37,0,280,290,3,80,40,0,281,290,3,84,42,0,282,290,
  	3,20,10,0,283,290,3,16,8,0,284,290,3,18,9,0,285,290,3,86,43,0,286,290,
  	3,108,54,0,287,290,3,112,56,0,288,290,3,116,58,0,289,265,1,0,0,0,289,
  	266,1,0,0,0,289,267,1,0,0,0,289,268,1,0,0,0,289,269,1,0,0,0,289,270,1,
  	0,0,0,289,271,1,0,0,0,289,272,1,0,0,0,289,273,1,0,0,0,289,274,1,0,0,0,
  	289,275,1,0,0,0,289,276,1,0,0,0,289,277,1,0,0,0,289,278,1,0,0,0,289,279,
  	1,0,0,0,289,280,1,0,0,0,289,281,1,0,0,0,289,282,1,0,0,0,289,283,1,0,0,
  	0,289,284,1,0,0,0,289,285,1,0,0,0,289,286,1,0,0,0,289,287,1,0,0,0,289,
  	288,1,0,0,0,290,5,1,0,0,0,291,292,5,30,0,0,292,296,5,132,0,0,293,294,
  	3,182,91,0,294,295,5,2,0,0,295,297,1,0,0,0,296,293,1,0,0,0,296,297,1,
  	0,0,0,297,298,1,0,0,0,298,321,3,184,92,0,299,309,5,121,0,0,300,301,5,
  	136,0,0,301,310,3,184,92,0,302,304,5,46,0,0,303,302,1,0,0,0,303,304,1,
  	0,0,0,304,305,1,0,0,0,305,306,3,188,94,0,306,307,5,136,0,0,307,308,3,
  	188,94,0,308,310,1,0,0,0,309,300,1,0,0,0,309,303,1,0,0,0,310,322,1,0,
  	0,0,311,313,5,27,0,0,312,314,5,46,0,0,313,312,1,0,0,0,313,314,1,0,0,0,
  	314,315,1,0,0,0,315,322,3,28,14,0,316,318,5,63,0,0,317,319,5,46,0,0,318,
  	317,1,0,0,0,318,319,1,0,0,0,319,320,1,0,0,0,320,322,3,188,94,0,321,299,
  	1,0,0,0,321,311,1,0,0,0,321,316,1,0,0,0,322,7,1,0,0,0,323,331,5,31,0,
  	0,324,332,3,182,91,0,325,326,3,182,91,0,326,327,5,2,0,0,327,329,1,0,0,
  	0,328,325,1,0,0,0,328,329,1,0,0,0,329,330,1,0,0,0,330,332,3,186,93,0,
  	331,324,1,0,0,0,331,328,1,0,0,0,331,332,1,0,0,0,332,9,1,0,0,0,333,335,
  	5,35,0,0,334,336,5,55,0,0,335,334,1,0,0,0,335,336,1,0,0,0,336,337,1,0,
  	0,0,337,338,3,64,32,0,338,339,5,33,0,0,339,340,3,182,91,0,340,11,1,0,
  	0,0,341,343,5,38,0,0,342,344,7,0,0,0,343,342,1,0,0,0,343,344,1,0,0,0,
  	344,349,1,0,0,0,345,347,5,137,0,0,346,348,3,208,104,0,347,346,1,0,0,0,
  	347,348,1,0,0,0,348,350,1,0,0,0,349,345,1,0,0,0,349,350,1,0,0,0,350,13,
  	1,0,0,0,351,353,7,1,0,0,352,354,5,137,0,0,353,352,1,0,0,0,353,354,1,0,
  	0,0,354,15,1,0,0,0,355,357,5,126,0,0,356,358,5,137,0,0,357,356,1,0,0,
  	0,357,358,1,0,0,0,358,364,1,0,0,0,359,361,5,136,0,0,360,362,5,129,0,0,
  	361,360,1,0,0,0,361,362,1,0,0,0,362,363,1,0,0,0,363,365,3,204,102,0,364,
  	359,1,0,0,0,364,365,1,0,0,0,365,17,1,0,0,0,366,367,5,129,0,0,367,368,
  	3,204,102,0,368,19,1,0,0,0,369,371,5,120,0,0,370,372,5,129,0,0,371,370,
  	1,0,0,0,371,372,1,0,0,0,372,373,1,0,0,0,373,374,3,204,102,0,374,21,1,
  	0,0,0,375,377,5,50,0,0,376,378,5,140,0,0,377,376,1,0,0,0,377,378,1,0,
  	0,0,378,379,1,0,0,0,379,383,5,84,0,0,380,381,5,80,0,0,381,382,5,102,0,
  	0,382,384,5,70,0,0,383,380,1,0,0,0,383,384,1,0,0,0,384,388,1,0,0,0,385,
  	386,3,182,91,0,386,387,5,2,0,0,387,389,1,0,0,0,388,385,1,0,0,0,388,389,
  	1,0,0,0,389,390,1,0,0,0,390,391,3,194,97,0,391,392,5,107,0,0,392,393,
  	3,184,92,0,393,394,5,3,0,0,394,399,3,24,12,0,395,396,5,5,0,0,396,398,
  	3,24,12,0,397,395,1,0,0,0,398,401,1,0,0,0,399,397,1,0,0,0,399,400,1,0,
  	0,0,400,402,1,0,0,0,401,399,1,0,0,0,402,405,5,4,0,0,403,404,5,148,0,0,
  	404,406,3,64,32,0,405,403,1,0,0,0,405,406,1,0,0,0,406,23,1,0,0,0,407,
  	410,3,188,94,0,408,410,3,64,32,0,409,407,1,0,0,0,409,408,1,0,0,0,410,
  	413,1,0,0,0,411,412,5,45,0,0,412,414,3,190,95,0,413,411,1,0,0,0,413,414,
  	1,0,0,0,414,416,1,0,0,0,415,417,3,142,71,0,416,415,1,0,0,0,416,417,1,
  	0,0,0,417,25,1,0,0,0,418,420,5,50,0,0,419,421,7,2,0,0,420,419,1,0,0,0,
  	420,421,1,0,0,0,421,422,1,0,0,0,422,426,5,132,0,0,423,424,5,80,0,0,424,
  	425,5,102,0,0,425,427,5,70,0,0,426,423,1,0,0,0,426,427,1,0,0,0,427,431,
  	1,0,0,0,428,429,3,182,91,0,429,430,5,2,0,0,430,432,1,0,0,0,431,428,1,
  	0,0,0,431,432,1,0,0,0,432,433,1,0,0,0,433,457,3,184,92,0,434,435,5,3,
  	0,0,435,440,3,28,14,0,436,437,5,5,0,0,437,439,3,28,14,0,438,436,1,0,0,
  	0,439,442,1,0,0,0,440,441,1,0,0,0,440,438,1,0,0,0,441,447,1,0,0,0,442,
  	440,1,0,0,0,443,444,5,5,0,0,444,446,3,36,18,0,445,443,1,0,0,0,446,449,
  	1,0,0,0,447,445,1,0,0,0,447,448,1,0,0,0,448,450,1,0,0,0,449,447,1,0,0,
  	0,450,453,5,4,0,0,451,452,5,150,0,0,452,454,5,185,0,0,453,451,1,0,0,0,
  	453,454,1,0,0,0,454,458,1,0,0,0,455,456,5,33,0,0,456,458,3,86,43,0,457,
  	434,1,0,0,0,457,455,1,0,0,0,458,27,1,0,0,0,459,461,3,188,94,0,460,462,
  	3,30,15,0,461,460,1,0,0,0,461,462,1,0,0,0,462,466,1,0,0,0,463,465,3,32,
  	16,0,464,463,1,0,0,0,465,468,1,0,0,0,466,464,1,0,0,0,466,467,1,0,0,0,
  	467,29,1,0,0,0,468,466,1,0,0,0,469,471,3,178,89,0,470,469,1,0,0,0,471,
  	472,1,0,0,0,472,473,1,0,0,0,472,470,1,0,0,0,473,484,1,0,0,0,474,475,5,
  	3,0,0,475,476,3,34,17,0,476,477,5,4,0,0,477,485,1,0,0,0,478,479,5,3,0,
  	0,479,480,3,34,17,0,480,481,5,5,0,0,481,482,3,34,17,0,482,483,5,4,0,0,
  	483,485,1,0,0,0,484,474,1,0,0,0,484,478,1,0,0,0,484,485,1,0,0,0,485,31,
  	1,0,0,0,486,487,5,49,0,0,487,489,3,178,89,0,488,486,1,0,0,0,488,489,1,
  	0,0,0,489,539,1,0,0,0,490,491,5,113,0,0,491,493,5,95,0,0,492,494,3,142,
  	71,0,493,492,1,0,0,0,493,494,1,0,0,0,494,496,1,0,0,0,495,497,3,40,20,
  	0,496,495,1,0,0,0,496,497,1,0,0,0,497,499,1,0,0,0,498,500,5,36,0,0,499,
  	498,1,0,0,0,499,500,1,0,0,0,500,540,1,0,0,0,501,503,5,102,0,0,502,501,
  	1,0,0,0,502,503,1,0,0,0,503,504,1,0,0,0,504,507,5,104,0,0,505,507,5,140,
  	0,0,506,502,1,0,0,0,506,505,1,0,0,0,507,509,1,0,0,0,508,510,3,40,20,0,
  	509,508,1,0,0,0,509,510,1,0,0,0,510,540,1,0,0,0,511,512,5,44,0,0,512,
  	513,5,3,0,0,513,514,3,64,32,0,514,515,5,4,0,0,515,540,1,0,0,0,516,523,
  	5,56,0,0,517,524,3,34,17,0,518,524,3,68,34,0,519,520,5,3,0,0,520,521,
  	3,64,32,0,521,522,5,4,0,0,522,524,1,0,0,0,523,517,1,0,0,0,523,518,1,0,
  	0,0,523,519,1,0,0,0,524,540,1,0,0,0,525,526,5,45,0,0,526,540,3,190,95,
  	0,527,540,3,38,19,0,528,529,5,169,0,0,529,531,5,170,0,0,530,528,1,0,0,
  	0,530,531,1,0,0,0,531,532,1,0,0,0,532,533,5,33,0,0,533,534,5,3,0,0,534,
  	535,3,64,32,0,535,537,5,4,0,0,536,538,7,3,0,0,537,536,1,0,0,0,537,538,
  	1,0,0,0,538,540,1,0,0,0,539,490,1,0,0,0,539,506,1,0,0,0,539,511,1,0,0,
  	0,539,516,1,0,0,0,539,525,1,0,0,0,539,527,1,0,0,0,539,530,1,0,0,0,540,
  	33,1,0,0,0,541,543,7,4,0,0,542,541,1,0,0,0,542,543,1,0,0,0,543,544,1,
  	0,0,0,544,545,5,186,0,0,545,35,1,0,0,0,546,547,5,49,0,0,547,549,3,178,
  	89,0,548,546,1,0,0,0,548,549,1,0,0,0,549,587,1,0,0,0,550,551,5,113,0,
  	0,551,554,5,95,0,0,552,554,5,140,0,0,553,550,1,0,0,0,553,552,1,0,0,0,
  	554,555,1,0,0,0,555,556,5,3,0,0,556,561,3,24,12,0,557,558,5,5,0,0,558,
  	560,3,24,12,0,559,557,1,0,0,0,560,563,1,0,0,0,561,559,1,0,0,0,561,562,
  	1,0,0,0,562,564,1,0,0,0,563,561,1,0,0,0,564,566,5,4,0,0,565,567,3,40,
  	20,0,566,565,1,0,0,0,566,567,1,0,0,0,567,588,1,0,0,0,568,569,5,44,0,0,
  	569,570,5,3,0,0,570,571,3,64,32,0,571,572,5,4,0,0,572,588,1,0,0,0,573,
  	574,5,74,0,0,574,575,5,95,0,0,575,576,5,3,0,0,576,581,3,188,94,0,577,
  	578,5,5,0,0,578,580,3,188,94,0,579,577,1,0,0,0,580,583,1,0,0,0,581,579,
  	1,0,0,0,581,582,1,0,0,0,582,584,1,0,0,0,583,581,1,0,0,0,584,585,5,4,0,
  	0,585,586,3,38,19,0,586,588,1,0,0,0,587,553,1,0,0,0,587,568,1,0,0,0,587,
  	573,1,0,0,0,588,37,1,0,0,0,589,590,5,117,0,0,590,602,3,192,96,0,591,592,
  	5,3,0,0,592,597,3,188,94,0,593,594,5,5,0,0,594,596,3,188,94,0,595,593,
  	1,0,0,0,596,599,1,0,0,0,597,595,1,0,0,0,597,598,1,0,0,0,598,600,1,0,0,
  	0,599,597,1,0,0,0,600,601,5,4,0,0,601,603,1,0,0,0,602,591,1,0,0,0,602,
  	603,1,0,0,0,603,618,1,0,0,0,604,605,5,107,0,0,605,612,7,5,0,0,606,607,
  	5,131,0,0,607,613,7,6,0,0,608,613,5,41,0,0,609,613,5,123,0,0,610,611,
  	5,101,0,0,611,613,5,26,0,0,612,606,1,0,0,0,612,608,1,0,0,0,612,609,1,
  	0,0,0,612,610,1,0,0,0,613,617,1,0,0,0,614,615,5,99,0,0,615,617,3,178,
  	89,0,616,604,1,0,0,0,616,614,1,0,0,0,617,620,1,0,0,0,618,616,1,0,0,0,
  	618,619,1,0,0,0,619,629,1,0,0,0,620,618,1,0,0,0,621,623,5,102,0,0,622,
  	621,1,0,0,0,622,623,1,0,0,0,623,624,1,0,0,0,624,627,5,57,0,0,625,626,
  	5,86,0,0,626,628,7,7,0,0,627,625,1,0,0,0,627,628,1,0,0,0,628,630,1,0,
  	0,0,629,622,1,0,0,0,629,630,1,0,0,0,630,39,1,0,0,0,631,632,5,107,0,0,
  	632,633,5,48,0,0,633,634,7,8,0,0,634,41,1,0,0,0,635,637,5,50,0,0,636,
  	638,7,2,0,0,637,636,1,0,0,0,637,638,1,0,0,0,638,639,1,0,0,0,639,643,5,
  	138,0,0,640,641,5,80,0,0,641,642,5,102,0,0,642,644,5,70,0,0,643,640,1,
  	0,0,0,643,644,1,0,0,0,644,648,1,0,0,0,645,646,3,182,91,0,646,647,5,2,
  	0,0,647,649,1,0,0,0,648,645,1,0,0,0,648,649,1,0,0,0,649,650,1,0,0,0,650,
  	655,3,196,98,0,651,656,5,37,0,0,652,656,5,28,0,0,653,654,5,89,0,0,654,
  	656,5,105,0,0,655,651,1,0,0,0,655,652,1,0,0,0,655,653,1,0,0,0,655,656,
  	1,0,0,0,656,671,1,0,0,0,657,672,5,59,0,0,658,672,5,88,0,0,659,669,5,141,
  	0,0,660,661,5,105,0,0,661,666,3,188,94,0,662,663,5,5,0,0,663,665,3,188,
  	94,0,664,662,1,0,0,0,665,668,1,0,0,0,666,664,1,0,0,0,666,667,1,0,0,0,
  	667,670,1,0,0,0,668,666,1,0,0,0,669,660,1,0,0,0,669,670,1,0,0,0,670,672,
  	1,0,0,0,671,657,1,0,0,0,671,658,1,0,0,0,671,659,1,0,0,0,672,673,1,0,0,
  	0,673,674,5,107,0,0,674,678,3,184,92,0,675,676,5,73,0,0,676,677,5,64,
  	0,0,677,679,5,127,0,0,678,675,1,0,0,0,678,679,1,0,0,0,679,682,1,0,0,0,
  	680,681,5,147,0,0,681,683,3,64,32,0,682,680,1,0,0,0,682,683,1,0,0,0,683,
  	684,1,0,0,0,684,693,5,38,0,0,685,690,3,108,54,0,686,690,3,74,37,0,687,
  	690,3,56,28,0,688,690,3,86,43,0,689,685,1,0,0,0,689,686,1,0,0,0,689,687,
  	1,0,0,0,689,688,1,0,0,0,690,691,1,0,0,0,691,692,5,1,0,0,692,694,1,0,0,
  	0,693,689,1,0,0,0,694,695,1,0,0,0,695,693,1,0,0,0,695,696,1,0,0,0,696,
  	697,1,0,0,0,697,698,5,66,0,0,698,43,1,0,0,0,699,701,5,50,0,0,700,702,
  	7,2,0,0,701,700,1,0,0,0,701,702,1,0,0,0,702,703,1,0,0,0,703,707,5,145,
  	0,0,704,705,5,80,0,0,705,706,5,102,0,0,706,708,5,70,0,0,707,704,1,0,0,
  	0,707,708,1,0,0,0,708,712,1,0,0,0,709,710,3,182,91,0,710,711,5,2,0,0,
  	711,713,1,0,0,0,712,709,1,0,0,0,712,713,1,0,0,0,713,714,1,0,0,0,714,726,
  	3,198,99,0,715,716,5,3,0,0,716,721,3,188,94,0,717,718,5,5,0,0,718,720,
  	3,188,94,0,719,717,1,0,0,0,720,723,1,0,0,0,721,719,1,0,0,0,721,722,1,
  	0,0,0,722,724,1,0,0,0,723,721,1,0,0,0,724,725,5,4,0,0,725,727,1,0,0,0,
  	726,715,1,0,0,0,726,727,1,0,0,0,727,728,1,0,0,0,728,729,5,33,0,0,729,
  	730,3,86,43,0,730,45,1,0,0,0,731,732,5,50,0,0,732,733,5,146,0,0,733,737,
  	5,132,0,0,734,735,5,80,0,0,735,736,5,102,0,0,736,738,5,70,0,0,737,734,
  	1,0,0,0,737,738,1,0,0,0,738,742,1,0,0,0,739,740,3,182,91,0,740,741,5,
  	2,0,0,741,743,1,0,0,0,742,739,1,0,0,0,742,743,1,0,0,0,743,744,1,0,0,0,
  	744,745,3,184,92,0,745,746,5,142,0,0,746,758,3,200,100,0,747,748,5,3,
  	0,0,748,753,3,172,86,0,749,750,5,5,0,0,750,752,3,172,86,0,751,749,1,0,
  	0,0,752,755,1,0,0,0,753,751,1,0,0,0,753,754,1,0,0,0,754,756,1,0,0,0,755,
  	753,1,0,0,0,756,757,5,4,0,0,757,759,1,0,0,0,758,747,1,0,0,0,758,759,1,
  	0,0,0,759,47,1,0,0,0,760,762,5,149,0,0,761,763,5,116,0,0,762,761,1,0,
  	0,0,762,763,1,0,0,0,763,764,1,0,0,0,764,765,3,50,25,0,765,766,5,33,0,
  	0,766,767,5,3,0,0,767,768,3,86,43,0,768,778,5,4,0,0,769,770,5,5,0,0,770,
  	771,3,50,25,0,771,772,5,33,0,0,772,773,5,3,0,0,773,774,3,86,43,0,774,
  	775,5,4,0,0,775,777,1,0,0,0,776,769,1,0,0,0,777,780,1,0,0,0,778,776,1,
  	0,0,0,778,779,1,0,0,0,779,49,1,0,0,0,780,778,1,0,0,0,781,793,3,184,92,
  	0,782,783,5,3,0,0,783,788,3,188,94,0,784,785,5,5,0,0,785,787,3,188,94,
  	0,786,784,1,0,0,0,787,790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,
  	791,1,0,0,0,790,788,1,0,0,0,791,792,5,4,0,0,792,794,1,0,0,0,793,782,1,
  	0,0,0,793,794,1,0,0,0,794,51,1,0,0,0,795,796,3,50,25,0,796,797,5,33,0,
  	0,797,798,5,3,0,0,798,799,3,164,82,0,799,801,5,139,0,0,800,802,5,29,0,
  	0,801,800,1,0,0,0,801,802,1,0,0,0,802,803,1,0,0,0,803,804,3,166,83,0,
  	804,805,5,4,0,0,805,53,1,0,0,0,806,818,3,184,92,0,807,808,5,3,0,0,808,
  	813,3,188,94,0,809,810,5,5,0,0,810,812,3,188,94,0,811,809,1,0,0,0,812,
  	815,1,0,0,0,813,811,1,0,0,0,813,814,1,0,0,0,814,816,1,0,0,0,815,813,1,
  	0,0,0,816,817,5,4,0,0,817,819,1,0,0,0,818,807,1,0,0,0,818,819,1,0,0,0,
  	819,820,1,0,0,0,820,821,5,33,0,0,821,822,5,3,0,0,822,823,3,86,43,0,823,
  	824,5,4,0,0,824,55,1,0,0,0,825,827,3,48,24,0,826,825,1,0,0,0,826,827,
  	1,0,0,0,827,828,1,0,0,0,828,829,5,59,0,0,829,830,5,75,0,0,830,833,3,114,
  	57,0,831,832,5,148,0,0,832,834,3,64,32,0,833,831,1,0,0,0,833,834,1,0,
  	0,0,834,836,1,0,0,0,835,837,3,76,38,0,836,835,1,0,0,0,836,837,1,0,0,0,
  	837,57,1,0,0,0,838,840,3,48,24,0,839,838,1,0,0,0,839,840,1,0,0,0,840,
  	841,1,0,0,0,841,842,5,59,0,0,842,843,5,75,0,0,843,846,3,114,57,0,844,
  	845,5,148,0,0,845,847,3,64,32,0,846,844,1,0,0,0,846,847,1,0,0,0,847,849,
  	1,0,0,0,848,850,3,76,38,0,849,848,1,0,0,0,849,850,1,0,0,0,850,855,1,0,
  	0,0,851,853,3,136,68,0,852,851,1,0,0,0,852,853,1,0,0,0,853,854,1,0,0,
  	0,854,856,3,138,69,0,855,852,1,0,0,0,855,856,1,0,0,0,856,59,1,0,0,0,857,
  	859,5,61,0,0,858,860,5,55,0,0,859,858,1,0,0,0,859,860,1,0,0,0,860,861,
  	1,0,0,0,861,862,3,182,91,0,862,61,1,0,0,0,863,864,5,63,0,0,864,867,7,
  	9,0,0,865,866,5,80,0,0,866,868,5,70,0,0,867,865,1,0,0,0,867,868,1,0,0,
  	0,868,872,1,0,0,0,869,870,3,182,91,0,870,871,5,2,0,0,871,873,1,0,0,0,
  	872,869,1,0,0,0,872,873,1,0,0,0,873,874,1,0,0,0,874,875,3,224,112,0,875,
  	63,1,0,0,0,876,877,6,32,-1,0,877,965,3,68,34,0,878,965,5,187,0,0,879,
  	880,3,182,91,0,880,881,5,2,0,0,881,883,1,0,0,0,882,879,1,0,0,0,882,883,
  	1,0,0,0,883,884,1,0,0,0,884,885,3,184,92,0,885,886,5,2,0,0,886,888,1,
  	0,0,0,887,882,1,0,0,0,887,888,1,0,0,0,888,889,1,0,0,0,889,965,3,188,94,
  	0,890,891,3,168,84,0,891,892,3,64,32,21,892,965,1,0,0,0,893,894,3,180,
  	90,0,894,907,5,3,0,0,895,897,5,62,0,0,896,895,1,0,0,0,896,897,1,0,0,0,
  	897,898,1,0,0,0,898,903,3,64,32,0,899,900,5,5,0,0,900,902,3,64,32,0,901,
  	899,1,0,0,0,902,905,1,0,0,0,903,901,1,0,0,0,903,904,1,0,0,0,904,908,1,
  	0,0,0,905,903,1,0,0,0,906,908,5,7,0,0,907,896,1,0,0,0,907,906,1,0,0,0,
  	907,908,1,0,0,0,908,909,1,0,0,0,909,911,5,4,0,0,910,912,3,118,59,0,911,
  	910,1,0,0,0,911,912,1,0,0,0,912,914,1,0,0,0,913,915,3,122,61,0,914,913,
  	1,0,0,0,914,915,1,0,0,0,915,965,1,0,0,0,916,917,5,3,0,0,917,922,3,64,
  	32,0,918,919,5,5,0,0,919,921,3,64,32,0,920,918,1,0,0,0,921,924,1,0,0,
  	0,922,920,1,0,0,0,922,923,1,0,0,0,923,925,1,0,0,0,924,922,1,0,0,0,925,
  	926,5,4,0,0,926,965,1,0,0,0,927,928,5,43,0,0,928,929,5,3,0,0,929,930,
  	3,64,32,0,930,931,5,33,0,0,931,932,3,30,15,0,932,933,5,4,0,0,933,965,
  	1,0,0,0,934,936,5,102,0,0,935,934,1,0,0,0,935,936,1,0,0,0,936,937,1,0,
  	0,0,937,939,5,70,0,0,938,935,1,0,0,0,938,939,1,0,0,0,939,940,1,0,0,0,
  	940,941,5,3,0,0,941,942,3,86,43,0,942,943,5,4,0,0,943,965,1,0,0,0,944,
  	946,5,42,0,0,945,947,3,64,32,0,946,945,1,0,0,0,946,947,1,0,0,0,947,953,
  	1,0,0,0,948,949,5,147,0,0,949,950,3,64,32,0,950,951,5,135,0,0,951,952,
  	3,64,32,0,952,954,1,0,0,0,953,948,1,0,0,0,954,955,1,0,0,0,955,953,1,0,
  	0,0,955,956,1,0,0,0,956,959,1,0,0,0,957,958,5,65,0,0,958,960,3,64,32,
  	0,959,957,1,0,0,0,959,960,1,0,0,0,960,961,1,0,0,0,961,962,5,66,0,0,962,
  	965,1,0,0,0,963,965,3,66,33,0,964,876,1,0,0,0,964,878,1,0,0,0,964,887,
  	1,0,0,0,964,890,1,0,0,0,964,893,1,0,0,0,964,916,1,0,0,0,964,927,1,0,0,
  	0,964,938,1,0,0,0,964,944,1,0,0,0,964,963,1,0,0,0,965,1085,1,0,0,0,966,
  	967,10,20,0,0,967,968,5,11,0,0,968,1084,3,64,32,21,969,970,10,19,0,0,
  	970,971,7,10,0,0,971,1084,3,64,32,20,972,973,10,18,0,0,973,974,7,4,0,
  	0,974,1084,3,64,32,19,975,976,10,17,0,0,976,977,7,11,0,0,977,1084,3,64,
  	32,18,978,979,10,16,0,0,979,980,7,12,0,0,980,1084,3,64,32,17,981,994,
  	10,15,0,0,982,995,5,6,0,0,983,995,5,22,0,0,984,995,5,23,0,0,985,995,5,
  	24,0,0,986,995,5,92,0,0,987,988,5,92,0,0,988,995,5,102,0,0,989,995,5,
  	83,0,0,990,995,5,97,0,0,991,995,5,77,0,0,992,995,5,99,0,0,993,995,5,118,
  	0,0,994,982,1,0,0,0,994,983,1,0,0,0,994,984,1,0,0,0,994,985,1,0,0,0,994,
  	986,1,0,0,0,994,987,1,0,0,0,994,989,1,0,0,0,994,990,1,0,0,0,994,991,1,
  	0,0,0,994,992,1,0,0,0,994,993,1,0,0,0,995,996,1,0,0,0,996,1084,3,64,32,
  	16,997,998,10,14,0,0,998,999,5,32,0,0,999,1084,3,64,32,15,1000,1001,10,
  	13,0,0,1001,1002,5,108,0,0,1002,1084,3,64,32,14,1003,1004,10,6,0,0,1004,
  	1006,5,92,0,0,1005,1007,5,102,0,0,1006,1005,1,0,0,0,1006,1007,1,0,0,0,
  	1007,1008,1,0,0,0,1008,1084,3,64,32,7,1009,1011,10,5,0,0,1010,1012,5,
  	102,0,0,1011,1010,1,0,0,0,1011,1012,1,0,0,0,1012,1013,1,0,0,0,1013,1014,
  	5,39,0,0,1014,1015,3,64,32,0,1015,1016,5,32,0,0,1016,1017,3,64,32,6,1017,
  	1084,1,0,0,0,1018,1019,10,9,0,0,1019,1020,5,45,0,0,1020,1084,3,190,95,
  	0,1021,1023,10,8,0,0,1022,1024,5,102,0,0,1023,1022,1,0,0,0,1023,1024,
  	1,0,0,0,1024,1025,1,0,0,0,1025,1026,7,13,0,0,1026,1029,3,64,32,0,1027,
  	1028,5,67,0,0,1028,1030,3,64,32,0,1029,1027,1,0,0,0,1029,1030,1,0,0,0,
  	1030,1084,1,0,0,0,1031,1036,10,7,0,0,1032,1037,5,93,0,0,1033,1037,5,103,
  	0,0,1034,1035,5,102,0,0,1035,1037,5,104,0,0,1036,1032,1,0,0,0,1036,1033,
  	1,0,0,0,1036,1034,1,0,0,0,1037,1084,1,0,0,0,1038,1040,10,4,0,0,1039,1041,
  	5,102,0,0,1040,1039,1,0,0,0,1040,1041,1,0,0,0,1041,1042,1,0,0,0,1042,
  	1081,5,83,0,0,1043,1053,5,3,0,0,1044,1054,3,86,43,0,1045,1050,3,64,32,
  	0,1046,1047,5,5,0,0,1047,1049,3,64,32,0,1048,1046,1,0,0,0,1049,1052,1,
  	0,0,0,1050,1048,1,0,0,0,1050,1051,1,0,0,0,1051,1054,1,0,0,0,1052,1050,
  	1,0,0,0,1053,1044,1,0,0,0,1053,1045,1,0,0,0,1053,1054,1,0,0,0,1054,1055,
  	1,0,0,0,1055,1082,5,4,0,0,1056,1057,3,182,91,0,1057,1058,5,2,0,0,1058,
  	1060,1,0,0,0,1059,1056,1,0,0,0,1059,1060,1,0,0,0,1060,1061,1,0,0,0,1061,
  	1082,3,184,92,0,1062,1063,3,182,91,0,1063,1064,5,2,0,0,1064,1066,1,0,
  	0,0,1065,1062,1,0,0,0,1065,1066,1,0,0,0,1066,1067,1,0,0,0,1067,1068,3,
  	222,111,0,1068,1077,5,3,0,0,1069,1074,3,64,32,0,1070,1071,5,5,0,0,1071,
  	1073,3,64,32,0,1072,1070,1,0,0,0,1073,1076,1,0,0,0,1074,1072,1,0,0,0,
  	1074,1075,1,0,0,0,1075,1078,1,0,0,0,1076,1074,1,0,0,0,1077,1069,1,0,0,
  	0,1077,1078,1,0,0,0,1078,1079,1,0,0,0,1079,1080,5,4,0,0,1080,1082,1,0,
  	0,0,1081,1043,1,0,0,0,1081,1059,1,0,0,0,1081,1065,1,0,0,0,1082,1084,1,
  	0,0,0,1083,966,1,0,0,0,1083,969,1,0,0,0,1083,972,1,0,0,0,1083,975,1,0,
  	0,0,1083,978,1,0,0,0,1083,981,1,0,0,0,1083,997,1,0,0,0,1083,1000,1,0,
  	0,0,1083,1003,1,0,0,0,1083,1009,1,0,0,0,1083,1018,1,0,0,0,1083,1021,1,
  	0,0,0,1083,1031,1,0,0,0,1083,1038,1,0,0,0,1084,1087,1,0,0,0,1085,1083,
  	1,0,0,0,1085,1086,1,0,0,0,1086,65,1,0,0,0,1087,1085,1,0,0,0,1088,1089,
  	5,115,0,0,1089,1094,5,3,0,0,1090,1095,5,81,0,0,1091,1092,7,14,0,0,1092,
  	1093,5,5,0,0,1093,1095,3,170,85,0,1094,1090,1,0,0,0,1094,1091,1,0,0,0,
  	1095,1096,1,0,0,0,1096,1097,5,4,0,0,1097,67,1,0,0,0,1098,1099,7,15,0,
  	0,1099,69,1,0,0,0,1100,1101,5,3,0,0,1101,1106,3,64,32,0,1102,1103,5,5,
  	0,0,1103,1105,3,64,32,0,1104,1102,1,0,0,0,1105,1108,1,0,0,0,1106,1104,
  	1,0,0,0,1106,1107,1,0,0,0,1107,1109,1,0,0,0,1108,1106,1,0,0,0,1109,1110,
  	5,4,0,0,1110,71,1,0,0,0,1111,1112,5,144,0,0,1112,1117,3,70,35,0,1113,
  	1114,5,5,0,0,1114,1116,3,70,35,0,1115,1113,1,0,0,0,1116,1119,1,0,0,0,
  	1117,1115,1,0,0,0,1117,1118,1,0,0,0,1118,73,1,0,0,0,1119,1117,1,0,0,0,
  	1120,1122,3,48,24,0,1121,1120,1,0,0,0,1121,1122,1,0,0,0,1122,1128,1,0,
  	0,0,1123,1129,5,88,0,0,1124,1129,5,122,0,0,1125,1126,5,88,0,0,1126,1127,
  	5,108,0,0,1127,1129,7,8,0,0,1128,1123,1,0,0,0,1128,1124,1,0,0,0,1128,
  	1125,1,0,0,0,1129,1130,1,0,0,0,1130,1134,5,91,0,0,1131,1132,3,182,91,
  	0,1132,1133,5,2,0,0,1133,1135,1,0,0,0,1134,1131,1,0,0,0,1134,1135,1,0,
  	0,0,1135,1136,1,0,0,0,1136,1139,3,184,92,0,1137,1138,5,33,0,0,1138,1140,
  	3,206,103,0,1139,1137,1,0,0,0,1139,1140,1,0,0,0,1140,1152,1,0,0,0,1141,
  	1142,5,3,0,0,1142,1147,3,188,94,0,1143,1144,5,5,0,0,1144,1146,3,188,94,
  	0,1145,1143,1,0,0,0,1146,1149,1,0,0,0,1147,1145,1,0,0,0,1147,1148,1,0,
  	0,0,1148,1150,1,0,0,0,1149,1147,1,0,0,0,1150,1151,5,4,0,0,1151,1153,1,
  	0,0,0,1152,1141,1,0,0,0,1152,1153,1,0,0,0,1153,1163,1,0,0,0,1154,1157,
  	3,72,36,0,1155,1157,3,86,43,0,1156,1154,1,0,0,0,1156,1155,1,0,0,0,1157,
  	1159,1,0,0,0,1158,1160,3,78,39,0,1159,1158,1,0,0,0,1159,1160,1,0,0,0,
  	1160,1164,1,0,0,0,1161,1162,5,56,0,0,1162,1164,5,144,0,0,1163,1156,1,
  	0,0,0,1163,1161,1,0,0,0,1164,1166,1,0,0,0,1165,1167,3,76,38,0,1166,1165,
  	1,0,0,0,1166,1167,1,0,0,0,1167,75,1,0,0,0,1168,1169,5,124,0,0,1169,1174,
  	3,100,50,0,1170,1171,5,5,0,0,1171,1173,3,100,50,0,1172,1170,1,0,0,0,1173,
  	1176,1,0,0,0,1174,1172,1,0,0,0,1174,1175,1,0,0,0,1175,77,1,0,0,0,1176,
  	1174,1,0,0,0,1177,1178,5,107,0,0,1178,1193,5,48,0,0,1179,1180,5,3,0,0,
  	1180,1185,3,24,12,0,1181,1182,5,5,0,0,1182,1184,3,24,12,0,1183,1181,1,
  	0,0,0,1184,1187,1,0,0,0,1185,1183,1,0,0,0,1185,1186,1,0,0,0,1186,1188,
  	1,0,0,0,1187,1185,1,0,0,0,1188,1191,5,4,0,0,1189,1190,5,148,0,0,1190,
  	1192,3,64,32,0,1191,1189,1,0,0,0,1191,1192,1,0,0,0,1192,1194,1,0,0,0,
  	1193,1179,1,0,0,0,1193,1194,1,0,0,0,1194,1195,1,0,0,0,1195,1222,5,183,
  	0,0,1196,1223,5,184,0,0,1197,1198,5,141,0,0,1198,1201,5,131,0,0,1199,
  	1202,3,188,94,0,1200,1202,3,110,55,0,1201,1199,1,0,0,0,1201,1200,1,0,
  	0,0,1202,1203,1,0,0,0,1203,1204,5,6,0,0,1204,1215,3,64,32,0,1205,1208,
  	5,5,0,0,1206,1209,3,188,94,0,1207,1209,3,110,55,0,1208,1206,1,0,0,0,1208,
  	1207,1,0,0,0,1209,1210,1,0,0,0,1210,1211,5,6,0,0,1211,1212,3,64,32,0,
  	1212,1214,1,0,0,0,1213,1205,1,0,0,0,1214,1217,1,0,0,0,1215,1213,1,0,0,
  	0,1215,1216,1,0,0,0,1216,1220,1,0,0,0,1217,1215,1,0,0,0,1218,1219,5,148,
  	0,0,1219,1221,3,64,32,0,1220,1218,1,0,0,0,1220,1221,1,0,0,0,1221,1223,
  	1,0,0,0,1222,1196,1,0,0,0,1222,1197,1,0,0,0,1223,79,1,0,0,0,1224,1228,
  	5,112,0,0,1225,1226,3,182,91,0,1226,1227,5,2,0,0,1227,1229,1,0,0,0,1228,
  	1225,1,0,0,0,1228,1229,1,0,0,0,1229,1230,1,0,0,0,1230,1237,3,202,101,
  	0,1231,1232,5,6,0,0,1232,1238,3,82,41,0,1233,1234,5,3,0,0,1234,1235,3,
  	82,41,0,1235,1236,5,4,0,0,1236,1238,1,0,0,0,1237,1231,1,0,0,0,1237,1233,
  	1,0,0,0,1237,1238,1,0,0,0,1238,81,1,0,0,0,1239,1243,3,34,17,0,1240,1243,
  	3,178,89,0,1241,1243,5,188,0,0,1242,1239,1,0,0,0,1242,1240,1,0,0,0,1242,
  	1241,1,0,0,0,1243,83,1,0,0,0,1244,1255,5,119,0,0,1245,1256,3,190,95,0,
  	1246,1247,3,182,91,0,1247,1248,5,2,0,0,1248,1250,1,0,0,0,1249,1246,1,
  	0,0,0,1249,1250,1,0,0,0,1250,1253,1,0,0,0,1251,1254,3,184,92,0,1252,1254,
  	3,194,97,0,1253,1251,1,0,0,0,1253,1252,1,0,0,0,1254,1256,1,0,0,0,1255,
  	1245,1,0,0,0,1255,1249,1,0,0,0,1255,1256,1,0,0,0,1256,85,1,0,0,0,1257,
  	1259,3,134,67,0,1258,1257,1,0,0,0,1258,1259,1,0,0,0,1259,1260,1,0,0,0,
  	1260,1266,3,90,45,0,1261,1262,3,106,53,0,1262,1263,3,90,45,0,1263,1265,
  	1,0,0,0,1264,1261,1,0,0,0,1265,1268,1,0,0,0,1266,1264,1,0,0,0,1266,1267,
  	1,0,0,0,1267,1270,1,0,0,0,1268,1266,1,0,0,0,1269,1271,3,136,68,0,1270,
  	1269,1,0,0,0,1270,1271,1,0,0,0,1271,1273,1,0,0,0,1272,1274,3,138,69,0,
  	1273,1272,1,0,0,0,1273,1274,1,0,0,0,1274,87,1,0,0,0,1275,1283,3,98,49,
  	0,1276,1277,3,102,51,0,1277,1279,3,98,49,0,1278,1280,3,104,52,0,1279,
  	1278,1,0,0,0,1279,1280,1,0,0,0,1280,1282,1,0,0,0,1281,1276,1,0,0,0,1282,
  	1285,1,0,0,0,1283,1281,1,0,0,0,1283,1284,1,0,0,0,1284,89,1,0,0,0,1285,
  	1283,1,0,0,0,1286,1288,5,130,0,0,1287,1289,7,16,0,0,1288,1287,1,0,0,0,
  	1288,1289,1,0,0,0,1289,1290,1,0,0,0,1290,1295,3,100,50,0,1291,1292,5,
  	5,0,0,1292,1294,3,100,50,0,1293,1291,1,0,0,0,1294,1297,1,0,0,0,1295,1293,
  	1,0,0,0,1295,1296,1,0,0,0,1296,1310,1,0,0,0,1297,1295,1,0,0,0,1298,1308,
  	5,75,0,0,1299,1304,3,98,49,0,1300,1301,5,5,0,0,1301,1303,3,98,49,0,1302,
  	1300,1,0,0,0,1303,1306,1,0,0,0,1304,1302,1,0,0,0,1304,1305,1,0,0,0,1305,
  	1309,1,0,0,0,1306,1304,1,0,0,0,1307,1309,3,88,44,0,1308,1299,1,0,0,0,
  	1308,1307,1,0,0,0,1309,1311,1,0,0,0,1310,1298,1,0,0,0,1310,1311,1,0,0,
  	0,1311,1314,1,0,0,0,1312,1313,5,148,0,0,1313,1315,3,64,32,0,1314,1312,
  	1,0,0,0,1314,1315,1,0,0,0,1315,1330,1,0,0,0,1316,1317,5,78,0,0,1317,1318,
  	5,40,0,0,1318,1323,3,64,32,0,1319,1320,5,5,0,0,1320,1322,3,64,32,0,1321,
  	1319,1,0,0,0,1322,1325,1,0,0,0,1323,1321,1,0,0,0,1323,1324,1,0,0,0,1324,
  	1328,1,0,0,0,1325,1323,1,0,0,0,1326,1327,5,79,0,0,1327,1329,3,64,32,0,
  	1328,1326,1,0,0,0,1328,1329,1,0,0,0,1329,1331,1,0,0,0,1330,1316,1,0,0,
  	0,1330,1331,1,0,0,0,1331,1346,1,0,0,0,1332,1333,5,174,0,0,1333,1334,3,
  	210,105,0,1334,1335,5,33,0,0,1335,1343,3,120,60,0,1336,1337,5,5,0,0,1337,
  	1338,3,210,105,0,1338,1339,5,33,0,0,1339,1340,3,120,60,0,1340,1342,1,
  	0,0,0,1341,1336,1,0,0,0,1342,1345,1,0,0,0,1343,1341,1,0,0,0,1343,1344,
  	1,0,0,0,1344,1347,1,0,0,0,1345,1343,1,0,0,0,1346,1332,1,0,0,0,1346,1347,
  	1,0,0,0,1347,1350,1,0,0,0,1348,1350,3,72,36,0,1349,1286,1,0,0,0,1349,
  	1348,1,0,0,0,1350,91,1,0,0,0,1351,1352,3,86,43,0,1352,93,1,0,0,0,1353,
  	1355,3,134,67,0,1354,1353,1,0,0,0,1354,1355,1,0,0,0,1355,1356,1,0,0,0,
  	1356,1358,3,90,45,0,1357,1359,3,136,68,0,1358,1357,1,0,0,0,1358,1359,
  	1,0,0,0,1359,1361,1,0,0,0,1360,1362,3,138,69,0,1361,1360,1,0,0,0,1361,
  	1362,1,0,0,0,1362,95,1,0,0,0,1363,1365,3,134,67,0,1364,1363,1,0,0,0,1364,
  	1365,1,0,0,0,1365,1366,1,0,0,0,1366,1376,3,90,45,0,1367,1369,5,139,0,
  	0,1368,1370,5,29,0,0,1369,1368,1,0,0,0,1369,1370,1,0,0,0,1370,1374,1,
  	0,0,0,1371,1374,5,90,0,0,1372,1374,5,68,0,0,1373,1367,1,0,0,0,1373,1371,
  	1,0,0,0,1373,1372,1,0,0,0,1374,1375,1,0,0,0,1375,1377,3,90,45,0,1376,
  	1373,1,0,0,0,1377,1378,1,0,0,0,1378,1376,1,0,0,0,1378,1379,1,0,0,0,1379,
  	1381,1,0,0,0,1380,1382,3,136,68,0,1381,1380,1,0,0,0,1381,1382,1,0,0,0,
  	1382,1384,1,0,0,0,1383,1385,3,138,69,0,1384,1383,1,0,0,0,1384,1385,1,
  	0,0,0,1385,97,1,0,0,0,1386,1387,3,182,91,0,1387,1388,5,2,0,0,1388,1390,
  	1,0,0,0,1389,1386,1,0,0,0,1389,1390,1,0,0,0,1390,1391,1,0,0,0,1391,1396,
  	3,184,92,0,1392,1394,5,33,0,0,1393,1392,1,0,0,0,1393,1394,1,0,0,0,1394,
  	1395,1,0,0,0,1395,1397,3,206,103,0,1396,1393,1,0,0,0,1396,1397,1,0,0,
  	0,1397,1403,1,0,0,0,1398,1399,5,85,0,0,1399,1400,5,40,0,0,1400,1404,3,
  	194,97,0,1401,1402,5,102,0,0,1402,1404,5,85,0,0,1403,1398,1,0,0,0,1403,
  	1401,1,0,0,0,1403,1404,1,0,0,0,1404,1451,1,0,0,0,1405,1406,3,182,91,0,
  	1406,1407,5,2,0,0,1407,1409,1,0,0,0,1408,1405,1,0,0,0,1408,1409,1,0,0,
  	0,1409,1410,1,0,0,0,1410,1411,3,222,111,0,1411,1412,5,3,0,0,1412,1417,
  	3,64,32,0,1413,1414,5,5,0,0,1414,1416,3,64,32,0,1415,1413,1,0,0,0,1416,
  	1419,1,0,0,0,1417,1415,1,0,0,0,1417,1418,1,0,0,0,1418,1420,1,0,0,0,1419,
  	1417,1,0,0,0,1420,1425,5,4,0,0,1421,1423,5,33,0,0,1422,1421,1,0,0,0,1422,
  	1423,1,0,0,0,1423,1424,1,0,0,0,1424,1426,3,206,103,0,1425,1422,1,0,0,
  	0,1425,1426,1,0,0,0,1426,1451,1,0,0,0,1427,1437,5,3,0,0,1428,1433,3,98,
  	49,0,1429,1430,5,5,0,0,1430,1432,3,98,49,0,1431,1429,1,0,0,0,1432,1435,
  	1,0,0,0,1433,1431,1,0,0,0,1433,1434,1,0,0,0,1434,1438,1,0,0,0,1435,1433,
  	1,0,0,0,1436,1438,3,88,44,0,1437,1428,1,0,0,0,1437,1436,1,0,0,0,1438,
  	1439,1,0,0,0,1439,1440,5,4,0,0,1440,1451,1,0,0,0,1441,1442,5,3,0,0,1442,
  	1443,3,86,43,0,1443,1448,5,4,0,0,1444,1446,5,33,0,0,1445,1444,1,0,0,0,
  	1445,1446,1,0,0,0,1446,1447,1,0,0,0,1447,1449,3,206,103,0,1448,1445,1,
  	0,0,0,1448,1449,1,0,0,0,1449,1451,1,0,0,0,1450,1389,1,0,0,0,1450,1408,
  	1,0,0,0,1450,1427,1,0,0,0,1450,1441,1,0,0,0,1451,99,1,0,0,0,1452,1465,
  	5,7,0,0,1453,1454,3,184,92,0,1454,1455,5,2,0,0,1455,1456,5,7,0,0,1456,
  	1465,1,0,0,0,1457,1462,3,64,32,0,1458,1460,5,33,0,0,1459,1458,1,0,0,0,
  	1459,1460,1,0,0,0,1460,1461,1,0,0,0,1461,1463,3,174,87,0,1462,1459,1,
  	0,0,0,1462,1463,1,0,0,0,1463,1465,1,0,0,0,1464,1452,1,0,0,0,1464,1453,
  	1,0,0,0,1464,1457,1,0,0,0,1465,101,1,0,0,0,1466,1480,5,5,0,0,1467,1469,
  	5,100,0,0,1468,1467,1,0,0,0,1468,1469,1,0,0,0,1469,1476,1,0,0,0,1470,
  	1472,5,96,0,0,1471,1473,5,110,0,0,1472,1471,1,0,0,0,1472,1473,1,0,0,0,
  	1473,1477,1,0,0,0,1474,1477,5,87,0,0,1475,1477,5,51,0,0,1476,1470,1,0,
  	0,0,1476,1474,1,0,0,0,1476,1475,1,0,0,0,1476,1477,1,0,0,0,1477,1478,1,
  	0,0,0,1478,1480,5,94,0,0,1479,1466,1,0,0,0,1479,1468,1,0,0,0,1480,103,
  	1,0,0,0,1481,1482,5,107,0,0,1482,1496,3,64,32,0,1483,1484,5,142,0,0,1484,
  	1485,5,3,0,0,1485,1490,3,188,94,0,1486,1487,5,5,0,0,1487,1489,3,188,94,
  	0,1488,1486,1,0,0,0,1489,1492,1,0,0,0,1490,1488,1,0,0,0,1490,1491,1,0,
  	0,0,1491,1493,1,0,0,0,1492,1490,1,0,0,0,1493,1494,5,4,0,0,1494,1496,1,
  	0,0,0,1495,1481,1,0,0,0,1495,1483,1,0,0,0,1496,105,1,0,0,0,1497,1499,
  	5,139,0,0,1498,1500,5,29,0,0,1499,1498,1,0,0,0,1499,1500,1,0,0,0,1500,
  	1504,1,0,0,0,1501,1504,5,90,0,0,1502,1504,5,68,0,0,1503,1497,1,0,0,0,
  	1503,1501,1,0,0,0,1503,1502,1,0,0,0,1504,107,1,0,0,0,1505,1507,3,48,24,
  	0,1506,1505,1,0,0,0,1506,1507,1,0,0,0,1507,1508,1,0,0,0,1508,1511,5,141,
  	0,0,1509,1510,5,108,0,0,1510,1512,7,8,0,0,1511,1509,1,0,0,0,1511,1512,
  	1,0,0,0,1512,1513,1,0,0,0,1513,1514,3,114,57,0,1514,1517,5,131,0,0,1515,
  	1518,3,188,94,0,1516,1518,3,110,55,0,1517,1515,1,0,0,0,1517,1516,1,0,
  	0,0,1518,1519,1,0,0,0,1519,1520,5,6,0,0,1520,1531,3,64,32,0,1521,1524,
  	5,5,0,0,1522,1525,3,188,94,0,1523,1525,3,110,55,0,1524,1522,1,0,0,0,1524,
  	1523,1,0,0,0,1525,1526,1,0,0,0,1526,1527,5,6,0,0,1527,1528,3,64,32,0,
  	1528,1530,1,0,0,0,1529,1521,1,0,0,0,1530,1533,1,0,0,0,1531,1529,1,0,0,
  	0,1531,1532,1,0,0,0,1532,1546,1,0,0,0,1533,1531,1,0,0,0,1534,1544,5,75,
  	0,0,1535,1540,3,98,49,0,1536,1537,5,5,0,0,1537,1539,3,98,49,0,1538,1536,
  	1,0,0,0,1539,1542,1,0,0,0,1540,1538,1,0,0,0,1540,1541,1,0,0,0,1541,1545,
  	1,0,0,0,1542,1540,1,0,0,0,1543,1545,3,88,44,0,1544,1535,1,0,0,0,1544,
  	1543,1,0,0,0,1545,1547,1,0,0,0,1546,1534,1,0,0,0,1546,1547,1,0,0,0,1547,
  	1550,1,0,0,0,1548,1549,5,148,0,0,1549,1551,3,64,32,0,1550,1548,1,0,0,
  	0,1550,1551,1,0,0,0,1551,1553,1,0,0,0,1552,1554,3,76,38,0,1553,1552,1,
  	0,0,0,1553,1554,1,0,0,0,1554,109,1,0,0,0,1555,1556,5,3,0,0,1556,1561,
  	3,188,94,0,1557,1558,5,5,0,0,1558,1560,3,188,94,0,1559,1557,1,0,0,0,1560,
  	1563,1,0,0,0,1561,1559,1,0,0,0,1561,1562,1,0,0,0,1562,1564,1,0,0,0,1563,
  	1561,1,0,0,0,1564,1565,5,4,0,0,1565,111,1,0,0,0,1566,1568,3,48,24,0,1567,
  	1566,1,0,0,0,1567,1568,1,0,0,0,1568,1569,1,0,0,0,1569,1572,5,141,0,0,
  	1570,1571,5,108,0,0,1571,1573,7,8,0,0,1572,1570,1,0,0,0,1572,1573,1,0,
  	0,0,1573,1574,1,0,0,0,1574,1575,3,114,57,0,1575,1578,5,131,0,0,1576,1579,
  	3,188,94,0,1577,1579,3,110,55,0,1578,1576,1,0,0,0,1578,1577,1,0,0,0,1579,
  	1580,1,0,0,0,1580,1581,5,6,0,0,1581,1592,3,64,32,0,1582,1585,5,5,0,0,
  	1583,1586,3,188,94,0,1584,1586,3,110,55,0,1585,1583,1,0,0,0,1585,1584,
  	1,0,0,0,1586,1587,1,0,0,0,1587,1588,5,6,0,0,1588,1589,3,64,32,0,1589,
  	1591,1,0,0,0,1590,1582,1,0,0,0,1591,1594,1,0,0,0,1592,1590,1,0,0,0,1592,
  	1593,1,0,0,0,1593,1597,1,0,0,0,1594,1592,1,0,0,0,1595,1596,5,148,0,0,
  	1596,1598,3,64,32,0,1597,1595,1,0,0,0,1597,1598,1,0,0,0,1598,1600,1,0,
  	0,0,1599,1601,3,76,38,0,1600,1599,1,0,0,0,1600,1601,1,0,0,0,1601,1606,
  	1,0,0,0,1602,1604,3,136,68,0,1603,1602,1,0,0,0,1603,1604,1,0,0,0,1604,
  	1605,1,0,0,0,1605,1607,3,138,69,0,1606,1603,1,0,0,0,1606,1607,1,0,0,0,
  	1607,113,1,0,0,0,1608,1609,3,182,91,0,1609,1610,5,2,0,0,1610,1612,1,0,
  	0,0,1611,1608,1,0,0,0,1611,1612,1,0,0,0,1612,1613,1,0,0,0,1613,1616,3,
  	184,92,0,1614,1615,5,33,0,0,1615,1617,3,212,106,0,1616,1614,1,0,0,0,1616,
  	1617,1,0,0,0,1617,1623,1,0,0,0,1618,1619,5,85,0,0,1619,1620,5,40,0,0,
  	1620,1624,3,194,97,0,1621,1622,5,102,0,0,1622,1624,5,85,0,0,1623,1618,
  	1,0,0,0,1623,1621,1,0,0,0,1623,1624,1,0,0,0,1624,115,1,0,0,0,1625,1627,
  	5,143,0,0,1626,1628,3,182,91,0,1627,1626,1,0,0,0,1627,1628,1,0,0,0,1628,
  	1631,1,0,0,0,1629,1630,5,91,0,0,1630,1632,3,214,107,0,1631,1629,1,0,0,
  	0,1631,1632,1,0,0,0,1632,117,1,0,0,0,1633,1634,5,178,0,0,1634,1635,5,
  	3,0,0,1635,1636,5,148,0,0,1636,1637,3,64,32,0,1637,1638,5,4,0,0,1638,
  	119,1,0,0,0,1639,1641,5,3,0,0,1640,1642,3,216,108,0,1641,1640,1,0,0,0,
  	1641,1642,1,0,0,0,1642,1653,1,0,0,0,1643,1644,5,153,0,0,1644,1645,5,40,
  	0,0,1645,1650,3,64,32,0,1646,1647,5,5,0,0,1647,1649,3,64,32,0,1648,1646,
  	1,0,0,0,1649,1652,1,0,0,0,1650,1648,1,0,0,0,1650,1651,1,0,0,0,1651,1654,
  	1,0,0,0,1652,1650,1,0,0,0,1653,1643,1,0,0,0,1653,1654,1,0,0,0,1654,1655,
  	1,0,0,0,1655,1656,5,109,0,0,1656,1657,5,40,0,0,1657,1662,3,140,70,0,1658,
  	1659,5,5,0,0,1659,1661,3,140,70,0,1660,1658,1,0,0,0,1661,1664,1,0,0,0,
  	1662,1660,1,0,0,0,1662,1663,1,0,0,0,1663,1666,1,0,0,0,1664,1662,1,0,0,
  	0,1665,1667,3,124,62,0,1666,1665,1,0,0,0,1666,1667,1,0,0,0,1667,1668,
  	1,0,0,0,1668,1669,5,4,0,0,1669,121,1,0,0,0,1670,1704,5,152,0,0,1671,1705,
  	3,210,105,0,1672,1674,5,3,0,0,1673,1675,3,216,108,0,1674,1673,1,0,0,0,
  	1674,1675,1,0,0,0,1675,1686,1,0,0,0,1676,1677,5,153,0,0,1677,1678,5,40,
  	0,0,1678,1683,3,64,32,0,1679,1680,5,5,0,0,1680,1682,3,64,32,0,1681,1679,
  	1,0,0,0,1682,1685,1,0,0,0,1683,1681,1,0,0,0,1683,1684,1,0,0,0,1684,1687,
  	1,0,0,0,1685,1683,1,0,0,0,1686,1676,1,0,0,0,1686,1687,1,0,0,0,1687,1698,
  	1,0,0,0,1688,1689,5,109,0,0,1689,1690,5,40,0,0,1690,1695,3,140,70,0,1691,
  	1692,5,5,0,0,1692,1694,3,140,70,0,1693,1691,1,0,0,0,1694,1697,1,0,0,0,
  	1695,1693,1,0,0,0,1695,1696,1,0,0,0,1696,1699,1,0,0,0,1697,1695,1,0,0,
  	0,1698,1688,1,0,0,0,1698,1699,1,0,0,0,1699,1701,1,0,0,0,1700,1702,3,124,
  	62,0,1701,1700,1,0,0,0,1701,1702,1,0,0,0,1702,1703,1,0,0,0,1703,1705,
  	5,4,0,0,1704,1671,1,0,0,0,1704,1672,1,0,0,0,1705,123,1,0,0,0,1706,1716,
  	3,126,63,0,1707,1714,5,180,0,0,1708,1709,5,101,0,0,1709,1715,5,182,0,
  	0,1710,1711,5,157,0,0,1711,1715,5,127,0,0,1712,1715,5,78,0,0,1713,1715,
  	5,181,0,0,1714,1708,1,0,0,0,1714,1710,1,0,0,0,1714,1712,1,0,0,0,1714,
  	1713,1,0,0,0,1715,1717,1,0,0,0,1716,1707,1,0,0,0,1716,1717,1,0,0,0,1717,
  	125,1,0,0,0,1718,1725,7,17,0,0,1719,1726,3,148,74,0,1720,1721,5,39,0,
  	0,1721,1722,3,144,72,0,1722,1723,5,32,0,0,1723,1724,3,146,73,0,1724,1726,
  	1,0,0,0,1725,1719,1,0,0,0,1725,1720,1,0,0,0,1726,127,1,0,0,0,1727,1728,
  	3,218,109,0,1728,1738,5,3,0,0,1729,1734,3,64,32,0,1730,1731,5,5,0,0,1731,
  	1733,3,64,32,0,1732,1730,1,0,0,0,1733,1736,1,0,0,0,1734,1732,1,0,0,0,
  	1734,1735,1,0,0,0,1735,1739,1,0,0,0,1736,1734,1,0,0,0,1737,1739,5,7,0,
  	0,1738,1729,1,0,0,0,1738,1737,1,0,0,0,1739,1740,1,0,0,0,1740,1741,5,4,
  	0,0,1741,129,1,0,0,0,1742,1743,3,220,110,0,1743,1756,5,3,0,0,1744,1746,
  	5,62,0,0,1745,1744,1,0,0,0,1745,1746,1,0,0,0,1746,1747,1,0,0,0,1747,1752,
  	3,64,32,0,1748,1749,5,5,0,0,1749,1751,3,64,32,0,1750,1748,1,0,0,0,1751,
  	1754,1,0,0,0,1752,1750,1,0,0,0,1752,1753,1,0,0,0,1753,1757,1,0,0,0,1754,
  	1752,1,0,0,0,1755,1757,5,7,0,0,1756,1745,1,0,0,0,1756,1755,1,0,0,0,1756,
  	1757,1,0,0,0,1757,1758,1,0,0,0,1758,1760,5,4,0,0,1759,1761,3,118,59,0,
  	1760,1759,1,0,0,0,1760,1761,1,0,0,0,1761,131,1,0,0,0,1762,1763,3,150,
  	75,0,1763,1773,5,3,0,0,1764,1769,3,64,32,0,1765,1766,5,5,0,0,1766,1768,
  	3,64,32,0,1767,1765,1,0,0,0,1768,1771,1,0,0,0,1769,1767,1,0,0,0,1769,
  	1770,1,0,0,0,1770,1774,1,0,0,0,1771,1769,1,0,0,0,1772,1774,5,7,0,0,1773,
  	1764,1,0,0,0,1773,1772,1,0,0,0,1773,1774,1,0,0,0,1774,1775,1,0,0,0,1775,
  	1777,5,4,0,0,1776,1778,3,118,59,0,1777,1776,1,0,0,0,1777,1778,1,0,0,0,
  	1778,1779,1,0,0,0,1779,1782,5,152,0,0,1780,1783,3,120,60,0,1781,1783,
  	3,210,105,0,1782,1780,1,0,0,0,1782,1781,1,0,0,0,1783,133,1,0,0,0,1784,
  	1786,5,149,0,0,1785,1787,5,116,0,0,1786,1785,1,0,0,0,1786,1787,1,0,0,
  	0,1787,1788,1,0,0,0,1788,1793,3,54,27,0,1789,1790,5,5,0,0,1790,1792,3,
  	54,27,0,1791,1789,1,0,0,0,1792,1795,1,0,0,0,1793,1791,1,0,0,0,1793,1794,
  	1,0,0,0,1794,135,1,0,0,0,1795,1793,1,0,0,0,1796,1797,5,109,0,0,1797,1798,
  	5,40,0,0,1798,1803,3,140,70,0,1799,1800,5,5,0,0,1800,1802,3,140,70,0,
  	1801,1799,1,0,0,0,1802,1805,1,0,0,0,1803,1801,1,0,0,0,1803,1804,1,0,0,
  	0,1804,137,1,0,0,0,1805,1803,1,0,0,0,1806,1807,5,98,0,0,1807,1810,3,64,
  	32,0,1808,1809,7,18,0,0,1809,1811,3,64,32,0,1810,1808,1,0,0,0,1810,1811,
  	1,0,0,0,1811,139,1,0,0,0,1812,1815,3,64,32,0,1813,1814,5,45,0,0,1814,
  	1816,3,190,95,0,1815,1813,1,0,0,0,1815,1816,1,0,0,0,1816,1818,1,0,0,0,
  	1817,1819,3,142,71,0,1818,1817,1,0,0,0,1818,1819,1,0,0,0,1819,1822,1,
  	0,0,0,1820,1821,5,175,0,0,1821,1823,7,19,0,0,1822,1820,1,0,0,0,1822,1823,
  	1,0,0,0,1823,141,1,0,0,0,1824,1825,7,20,0,0,1825,143,1,0,0,0,1826,1827,
  	3,64,32,0,1827,1828,5,155,0,0,1828,1837,1,0,0,0,1829,1830,3,64,32,0,1830,
  	1831,5,158,0,0,1831,1837,1,0,0,0,1832,1833,5,157,0,0,1833,1837,5,127,
  	0,0,1834,1835,5,156,0,0,1835,1837,5,155,0,0,1836,1826,1,0,0,0,1836,1829,
  	1,0,0,0,1836,1832,1,0,0,0,1836,1834,1,0,0,0,1837,145,1,0,0,0,1838,1839,
  	3,64,32,0,1839,1840,5,155,0,0,1840,1849,1,0,0,0,1841,1842,3,64,32,0,1842,
  	1843,5,158,0,0,1843,1849,1,0,0,0,1844,1845,5,157,0,0,1845,1849,5,127,
  	0,0,1846,1847,5,156,0,0,1847,1849,5,158,0,0,1848,1838,1,0,0,0,1848,1841,
  	1,0,0,0,1848,1844,1,0,0,0,1848,1846,1,0,0,0,1849,147,1,0,0,0,1850,1851,
  	3,64,32,0,1851,1852,5,155,0,0,1852,1858,1,0,0,0,1853,1854,5,156,0,0,1854,
  	1858,5,155,0,0,1855,1856,5,157,0,0,1856,1858,5,127,0,0,1857,1850,1,0,
  	0,0,1857,1853,1,0,0,0,1857,1855,1,0,0,0,1858,149,1,0,0,0,1859,1860,7,
  	21,0,0,1860,1861,5,3,0,0,1861,1862,3,64,32,0,1862,1863,5,4,0,0,1863,1864,
  	5,152,0,0,1864,1866,5,3,0,0,1865,1867,3,156,78,0,1866,1865,1,0,0,0,1866,
  	1867,1,0,0,0,1867,1868,1,0,0,0,1868,1870,3,160,80,0,1869,1871,3,126,63,
  	0,1870,1869,1,0,0,0,1870,1871,1,0,0,0,1871,1872,1,0,0,0,1872,1873,5,4,
  	0,0,1873,1945,1,0,0,0,1874,1875,7,22,0,0,1875,1876,5,3,0,0,1876,1877,
  	5,4,0,0,1877,1878,5,152,0,0,1878,1880,5,3,0,0,1879,1881,3,156,78,0,1880,
  	1879,1,0,0,0,1880,1881,1,0,0,0,1881,1883,1,0,0,0,1882,1884,3,158,79,0,
  	1883,1882,1,0,0,0,1883,1884,1,0,0,0,1884,1885,1,0,0,0,1885,1945,5,4,0,
  	0,1886,1887,7,23,0,0,1887,1888,5,3,0,0,1888,1889,5,4,0,0,1889,1890,5,
  	152,0,0,1890,1892,5,3,0,0,1891,1893,3,156,78,0,1892,1891,1,0,0,0,1892,
  	1893,1,0,0,0,1893,1894,1,0,0,0,1894,1895,3,160,80,0,1895,1896,5,4,0,0,
  	1896,1945,1,0,0,0,1897,1898,7,24,0,0,1898,1899,5,3,0,0,1899,1901,3,64,
  	32,0,1900,1902,3,152,76,0,1901,1900,1,0,0,0,1901,1902,1,0,0,0,1902,1904,
  	1,0,0,0,1903,1905,3,154,77,0,1904,1903,1,0,0,0,1904,1905,1,0,0,0,1905,
  	1906,1,0,0,0,1906,1907,5,4,0,0,1907,1908,5,152,0,0,1908,1910,5,3,0,0,
  	1909,1911,3,156,78,0,1910,1909,1,0,0,0,1910,1911,1,0,0,0,1911,1912,1,
  	0,0,0,1912,1913,3,160,80,0,1913,1914,5,4,0,0,1914,1945,1,0,0,0,1915,1916,
  	5,164,0,0,1916,1917,5,3,0,0,1917,1918,3,64,32,0,1918,1919,5,5,0,0,1919,
  	1920,3,34,17,0,1920,1921,5,4,0,0,1921,1922,5,152,0,0,1922,1924,5,3,0,
  	0,1923,1925,3,156,78,0,1924,1923,1,0,0,0,1924,1925,1,0,0,0,1925,1926,
  	1,0,0,0,1926,1928,3,160,80,0,1927,1929,3,126,63,0,1928,1927,1,0,0,0,1928,
  	1929,1,0,0,0,1929,1930,1,0,0,0,1930,1931,5,4,0,0,1931,1945,1,0,0,0,1932,
  	1933,5,165,0,0,1933,1934,5,3,0,0,1934,1935,3,64,32,0,1935,1936,5,4,0,
  	0,1936,1937,5,152,0,0,1937,1939,5,3,0,0,1938,1940,3,156,78,0,1939,1938,
  	1,0,0,0,1939,1940,1,0,0,0,1940,1941,1,0,0,0,1941,1942,3,160,80,0,1942,
  	1943,5,4,0,0,1943,1945,1,0,0,0,1944,1859,1,0,0,0,1944,1874,1,0,0,0,1944,
  	1886,1,0,0,0,1944,1897,1,0,0,0,1944,1915,1,0,0,0,1944,1932,1,0,0,0,1945,
  	151,1,0,0,0,1946,1947,5,5,0,0,1947,1948,3,34,17,0,1948,153,1,0,0,0,1949,
  	1950,5,5,0,0,1950,1951,3,34,17,0,1951,155,1,0,0,0,1952,1953,5,153,0,0,
  	1953,1955,5,40,0,0,1954,1956,3,64,32,0,1955,1954,1,0,0,0,1956,1957,1,
  	0,0,0,1957,1955,1,0,0,0,1957,1958,1,0,0,0,1958,157,1,0,0,0,1959,1960,
  	5,109,0,0,1960,1962,5,40,0,0,1961,1963,3,64,32,0,1962,1961,1,0,0,0,1963,
  	1964,1,0,0,0,1964,1962,1,0,0,0,1964,1965,1,0,0,0,1965,159,1,0,0,0,1966,
  	1967,5,109,0,0,1967,1968,5,40,0,0,1968,1969,3,162,81,0,1969,161,1,0,0,
  	0,1970,1972,3,64,32,0,1971,1973,3,142,71,0,1972,1971,1,0,0,0,1972,1973,
  	1,0,0,0,1973,1981,1,0,0,0,1974,1975,5,5,0,0,1975,1977,3,64,32,0,1976,
  	1978,3,142,71,0,1977,1976,1,0,0,0,1977,1978,1,0,0,0,1978,1980,1,0,0,0,
  	1979,1974,1,0,0,0,1980,1983,1,0,0,0,1981,1979,1,0,0,0,1981,1982,1,0,0,
  	0,1982,163,1,0,0,0,1983,1981,1,0,0,0,1984,1985,3,86,43,0,1985,165,1,0,
  	0,0,1986,1987,3,86,43,0,1987,167,1,0,0,0,1988,1989,7,25,0,0,1989,169,
  	1,0,0,0,1990,1991,5,188,0,0,1991,171,1,0,0,0,1992,1995,3,64,32,0,1993,
  	1995,3,28,14,0,1994,1992,1,0,0,0,1994,1993,1,0,0,0,1995,173,1,0,0,0,1996,
  	1997,7,26,0,0,1997,175,1,0,0,0,1998,1999,7,27,0,0,1999,177,1,0,0,0,2000,
  	2001,3,224,112,0,2001,179,1,0,0,0,2002,2003,3,224,112,0,2003,181,1,0,
  	0,0,2004,2005,3,224,112,0,2005,183,1,0,0,0,2006,2007,3,224,112,0,2007,
  	185,1,0,0,0,2008,2009,3,224,112,0,2009,187,1,0,0,0,2010,2011,3,224,112,
  	0,2011,189,1,0,0,0,2012,2013,3,224,112,0,2013,191,1,0,0,0,2014,2015,3,
  	224,112,0,2015,193,1,0,0,0,2016,2017,3,224,112,0,2017,195,1,0,0,0,2018,
  	2019,3,224,112,0,2019,197,1,0,0,0,2020,2021,3,224,112,0,2021,199,1,0,
  	0,0,2022,2023,3,224,112,0,2023,201,1,0,0,0,2024,2025,3,224,112,0,2025,
  	203,1,0,0,0,2026,2027,3,224,112,0,2027,205,1,0,0,0,2028,2029,3,224,112,
  	0,2029,207,1,0,0,0,2030,2031,3,224,112,0,2031,209,1,0,0,0,2032,2033,3,
  	224,112,0,2033,211,1,0,0,0,2034,2035,3,224,112,0,2035,213,1,0,0,0,2036,
  	2037,3,224,112,0,2037,215,1,0,0,0,2038,2039,3,224,112,0,2039,217,1,0,
  	0,0,2040,2041,3,224,112,0,2041,219,1,0,0,0,2042,2043,3,224,112,0,2043,
  	221,1,0,0,0,2044,2045,3,224,112,0,2045,223,1,0,0,0,2046,2054,5,185,0,
  	0,2047,2054,3,176,88,0,2048,2054,5,188,0,0,2049,2050,5,3,0,0,2050,2051,
  	3,224,112,0,2051,2052,5,4,0,0,2052,2054,1,0,0,0,2053,2046,1,0,0,0,2053,
  	2047,1,0,0,0,2053,2048,1,0,0,0,2053,2049,1,0,0,0,2054,225,1,0,0,0,296,
  	229,237,244,249,255,261,263,289,296,303,309,313,318,321,328,331,335,343,
  	347,349,353,357,361,364,371,377,383,388,399,405,409,413,416,420,426,431,
  	440,447,453,457,461,466,472,484,488,493,496,499,502,506,509,523,530,537,
  	539,542,548,553,561,566,581,587,597,602,612,616,618,622,627,629,637,643,
  	648,655,666,669,671,678,682,689,695,701,707,712,721,726,737,742,753,758,
  	762,778,788,793,801,813,818,826,833,836,839,846,849,852,855,859,867,872,
  	882,887,896,903,907,911,914,922,935,938,946,955,959,964,994,1006,1011,
  	1023,1029,1036,1040,1050,1053,1059,1065,1074,1077,1081,1083,1085,1094,
  	1106,1117,1121,1128,1134,1139,1147,1152,1156,1159,1163,1166,1174,1185,
  	1191,1193,1201,1208,1215,1220,1222,1228,1237,1242,1249,1253,1255,1258,
  	1266,1270,1273,1279,1283,1288,1295,1304,1308,1310,1314,1323,1328,1330,
  	1343,1346,1349,1354,1358,1361,1364,1369,1373,1378,1381,1384,1389,1393,
  	1396,1403,1408,1417,1422,1425,1433,1437,1445,1448,1450,1459,1462,1464,
  	1468,1472,1476,1479,1490,1495,1499,1503,1506,1511,1517,1524,1531,1540,
  	1544,1546,1550,1553,1561,1567,1572,1578,1585,1592,1597,1600,1603,1606,
  	1611,1616,1623,1627,1631,1641,1650,1653,1662,1666,1674,1683,1686,1695,
  	1698,1701,1704,1714,1716,1725,1734,1738,1745,1752,1756,1760,1769,1773,
  	1777,1782,1786,1793,1803,1810,1815,1818,1822,1836,1848,1857,1866,1870,
  	1880,1883,1892,1901,1904,1910,1924,1928,1939,1944,1957,1964,1972,1977,
  	1981,1994,2053
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  sqliteparserParserStaticData = std::move(staticData);
}

}

SQLiteParser::SQLiteParser(TokenStream *input) : SQLiteParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

SQLiteParser::SQLiteParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  SQLiteParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *sqliteparserParserStaticData->atn, sqliteparserParserStaticData->decisionToDFA, sqliteparserParserStaticData->sharedContextCache, options);
}

SQLiteParser::~SQLiteParser() {
  delete _interpreter;
}

const atn::ATN& SQLiteParser::getATN() const {
  return *sqliteparserParserStaticData->atn;
}

std::string SQLiteParser::getGrammarFileName() const {
  return "SQLiteParser.g4";
}

const std::vector<std::string>& SQLiteParser::getRuleNames() const {
  return sqliteparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& SQLiteParser::getVocabulary() const {
  return sqliteparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView SQLiteParser::getSerializedATN() const {
  return sqliteparserParserStaticData->serializedATN;
}


//----------------- ParseContext ------------------------------------------------------------------

SQLiteParser::ParseContext::ParseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::ParseContext::EOF() {
  return getToken(SQLiteParser::EOF, 0);
}

std::vector<SQLiteParser::Sql_stmt_listContext *> SQLiteParser::ParseContext::sql_stmt_list() {
  return getRuleContexts<SQLiteParser::Sql_stmt_listContext>();
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::ParseContext::sql_stmt_list(size_t i) {
  return getRuleContext<SQLiteParser::Sql_stmt_listContext>(i);
}


size_t SQLiteParser::ParseContext::getRuleIndex() const {
  return SQLiteParser::RuleParse;
}

void SQLiteParser::ParseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParse(this);
}

void SQLiteParser::ParseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParse(this);
}


std::any SQLiteParser::ParseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitParse(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::ParseContext* SQLiteParser::parse() {
  ParseContext *_localctx = _tracker.createInstance<ParseContext>(_ctx, getState());
  enterRule(_localctx, 0, SQLiteParser::RuleParse);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(229);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -6339801325483589630) != 0) || ((((_la - 66) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 66)) & -7971300971697405919) != 0) || ((((_la - 130) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 130)) & 550913) != 0)) {
      setState(226);
      sql_stmt_list();
      setState(231);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(232);
    match(SQLiteParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmt_listContext ------------------------------------------------------------------

SQLiteParser::Sql_stmt_listContext::Sql_stmt_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Sql_stmtContext *> SQLiteParser::Sql_stmt_listContext::sql_stmt() {
  return getRuleContexts<SQLiteParser::Sql_stmtContext>();
}

SQLiteParser::Sql_stmtContext* SQLiteParser::Sql_stmt_listContext::sql_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Sql_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Sql_stmt_listContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Sql_stmt_listContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}


size_t SQLiteParser::Sql_stmt_listContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt_list;
}

void SQLiteParser::Sql_stmt_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt_list(this);
}

void SQLiteParser::Sql_stmt_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt_list(this);
}


std::any SQLiteParser::Sql_stmt_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmt_listContext* SQLiteParser::sql_stmt_list() {
  Sql_stmt_listContext *_localctx = _tracker.createInstance<Sql_stmt_listContext>(_ctx, getState());
  enterRule(_localctx, 2, SQLiteParser::RuleSql_stmt_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(237);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::SCOL) {
      setState(234);
      match(SQLiteParser::SCOL);
      setState(239);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(240);
    sql_stmt();
    setState(249);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(242); 
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(241);
          match(SQLiteParser::SCOL);
          setState(244); 
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == SQLiteParser::SCOL);
        setState(246);
        sql_stmt(); 
      }
      setState(251);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx);
    }
    setState(255);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(252);
        match(SQLiteParser::SCOL); 
      }
      setState(257);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 4, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Sql_stmtContext ------------------------------------------------------------------

SQLiteParser::Sql_stmtContext::Sql_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::Sql_stmtContext::alter_table_stmt() {
  return getRuleContext<SQLiteParser::Alter_table_stmtContext>(0);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::Sql_stmtContext::analyze_stmt() {
  return getRuleContext<SQLiteParser::Analyze_stmtContext>(0);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::Sql_stmtContext::attach_stmt() {
  return getRuleContext<SQLiteParser::Attach_stmtContext>(0);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::Sql_stmtContext::begin_stmt() {
  return getRuleContext<SQLiteParser::Begin_stmtContext>(0);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::Sql_stmtContext::commit_stmt() {
  return getRuleContext<SQLiteParser::Commit_stmtContext>(0);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::Sql_stmtContext::create_index_stmt() {
  return getRuleContext<SQLiteParser::Create_index_stmtContext>(0);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::Sql_stmtContext::create_table_stmt() {
  return getRuleContext<SQLiteParser::Create_table_stmtContext>(0);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::Sql_stmtContext::create_trigger_stmt() {
  return getRuleContext<SQLiteParser::Create_trigger_stmtContext>(0);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::Sql_stmtContext::create_view_stmt() {
  return getRuleContext<SQLiteParser::Create_view_stmtContext>(0);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::Sql_stmtContext::create_virtual_table_stmt() {
  return getRuleContext<SQLiteParser::Create_virtual_table_stmtContext>(0);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Sql_stmtContext::delete_stmt() {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(0);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::Sql_stmtContext::delete_stmt_limited() {
  return getRuleContext<SQLiteParser::Delete_stmt_limitedContext>(0);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::Sql_stmtContext::detach_stmt() {
  return getRuleContext<SQLiteParser::Detach_stmtContext>(0);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::Sql_stmtContext::drop_stmt() {
  return getRuleContext<SQLiteParser::Drop_stmtContext>(0);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Sql_stmtContext::insert_stmt() {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(0);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::Sql_stmtContext::pragma_stmt() {
  return getRuleContext<SQLiteParser::Pragma_stmtContext>(0);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::Sql_stmtContext::reindex_stmt() {
  return getRuleContext<SQLiteParser::Reindex_stmtContext>(0);
}

SQLiteParser::Release_stmtContext* SQLiteParser::Sql_stmtContext::release_stmt() {
  return getRuleContext<SQLiteParser::Release_stmtContext>(0);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::Sql_stmtContext::rollback_stmt() {
  return getRuleContext<SQLiteParser::Rollback_stmtContext>(0);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::Sql_stmtContext::savepoint_stmt() {
  return getRuleContext<SQLiteParser::Savepoint_stmtContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Sql_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Update_stmtContext* SQLiteParser::Sql_stmtContext::update_stmt() {
  return getRuleContext<SQLiteParser::Update_stmtContext>(0);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::Sql_stmtContext::update_stmt_limited() {
  return getRuleContext<SQLiteParser::Update_stmt_limitedContext>(0);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::Sql_stmtContext::vacuum_stmt() {
  return getRuleContext<SQLiteParser::Vacuum_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::Sql_stmtContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}


size_t SQLiteParser::Sql_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSql_stmt;
}

void SQLiteParser::Sql_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSql_stmt(this);
}

void SQLiteParser::Sql_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSql_stmt(this);
}


std::any SQLiteParser::Sql_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSql_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Sql_stmtContext* SQLiteParser::sql_stmt() {
  Sql_stmtContext *_localctx = _tracker.createInstance<Sql_stmtContext>(_ctx, getState());
  enterRule(_localctx, 4, SQLiteParser::RuleSql_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(263);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXPLAIN_) {
      setState(258);
      match(SQLiteParser::EXPLAIN_);
      setState(261);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::QUERY_) {
        setState(259);
        match(SQLiteParser::QUERY_);
        setState(260);
        match(SQLiteParser::PLAN_);
      }
    }
    setState(289);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx)) {
    case 1: {
      setState(265);
      alter_table_stmt();
      break;
    }

    case 2: {
      setState(266);
      analyze_stmt();
      break;
    }

    case 3: {
      setState(267);
      attach_stmt();
      break;
    }

    case 4: {
      setState(268);
      begin_stmt();
      break;
    }

    case 5: {
      setState(269);
      commit_stmt();
      break;
    }

    case 6: {
      setState(270);
      create_index_stmt();
      break;
    }

    case 7: {
      setState(271);
      create_table_stmt();
      break;
    }

    case 8: {
      setState(272);
      create_trigger_stmt();
      break;
    }

    case 9: {
      setState(273);
      create_view_stmt();
      break;
    }

    case 10: {
      setState(274);
      create_virtual_table_stmt();
      break;
    }

    case 11: {
      setState(275);
      delete_stmt();
      break;
    }

    case 12: {
      setState(276);
      delete_stmt_limited();
      break;
    }

    case 13: {
      setState(277);
      detach_stmt();
      break;
    }

    case 14: {
      setState(278);
      drop_stmt();
      break;
    }

    case 15: {
      setState(279);
      insert_stmt();
      break;
    }

    case 16: {
      setState(280);
      pragma_stmt();
      break;
    }

    case 17: {
      setState(281);
      reindex_stmt();
      break;
    }

    case 18: {
      setState(282);
      release_stmt();
      break;
    }

    case 19: {
      setState(283);
      rollback_stmt();
      break;
    }

    case 20: {
      setState(284);
      savepoint_stmt();
      break;
    }

    case 21: {
      setState(285);
      select_stmt();
      break;
    }

    case 22: {
      setState(286);
      update_stmt();
      break;
    }

    case 23: {
      setState(287);
      update_stmt_limited();
      break;
    }

    case 24: {
      setState(288);
      vacuum_stmt();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Alter_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Alter_table_stmtContext::Alter_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

std::vector<SQLiteParser::Table_nameContext *> SQLiteParser::Alter_table_stmtContext::table_name() {
  return getRuleContexts<SQLiteParser::Table_nameContext>();
}

SQLiteParser::Table_nameContext* SQLiteParser::Alter_table_stmtContext::table_name(size_t i) {
  return getRuleContext<SQLiteParser::Table_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

SQLiteParser::Column_defContext* SQLiteParser::Alter_table_stmtContext::column_def() {
  return getRuleContext<SQLiteParser::Column_defContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Alter_table_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Alter_table_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Alter_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::Alter_table_stmtContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}


size_t SQLiteParser::Alter_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAlter_table_stmt;
}

void SQLiteParser::Alter_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlter_table_stmt(this);
}

void SQLiteParser::Alter_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlter_table_stmt(this);
}


std::any SQLiteParser::Alter_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlter_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Alter_table_stmtContext* SQLiteParser::alter_table_stmt() {
  Alter_table_stmtContext *_localctx = _tracker.createInstance<Alter_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 6, SQLiteParser::RuleAlter_table_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(291);
    match(SQLiteParser::ALTER_);
    setState(292);
    match(SQLiteParser::TABLE_);
    setState(296);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx)) {
    case 1: {
      setState(293);
      schema_name();
      setState(294);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(298);
    table_name();
    setState(321);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::RENAME_: {
        setState(299);
        match(SQLiteParser::RENAME_);
        setState(309);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx)) {
        case 1: {
          setState(300);
          match(SQLiteParser::TO_);
          setState(301);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_table_name = table_name();
          break;
        }

        case 2: {
          setState(303);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
          case 1: {
            setState(302);
            match(SQLiteParser::COLUMN_);
            break;
          }

          default:
            break;
          }
          setState(305);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->old_column_name = column_name();
          setState(306);
          match(SQLiteParser::TO_);
          setState(307);
          antlrcpp::downCast<Alter_table_stmtContext *>(_localctx)->new_column_name = column_name();
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::ADD_: {
        setState(311);
        match(SQLiteParser::ADD_);
        setState(313);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
        case 1: {
          setState(312);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(315);
        column_def();
        break;
      }

      case SQLiteParser::DROP_: {
        setState(316);
        match(SQLiteParser::DROP_);
        setState(318);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 12, _ctx)) {
        case 1: {
          setState(317);
          match(SQLiteParser::COLUMN_);
          break;
        }

        default:
          break;
        }
        setState(320);
        column_name();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Analyze_stmtContext ------------------------------------------------------------------

SQLiteParser::Analyze_stmtContext::Analyze_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Analyze_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::Analyze_stmtContext::table_or_index_name() {
  return getRuleContext<SQLiteParser::Table_or_index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Analyze_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Analyze_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAnalyze_stmt;
}

void SQLiteParser::Analyze_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAnalyze_stmt(this);
}

void SQLiteParser::Analyze_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAnalyze_stmt(this);
}


std::any SQLiteParser::Analyze_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAnalyze_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Analyze_stmtContext* SQLiteParser::analyze_stmt() {
  Analyze_stmtContext *_localctx = _tracker.createInstance<Analyze_stmtContext>(_ctx, getState());
  enterRule(_localctx, 8, SQLiteParser::RuleAnalyze_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(323);
    match(SQLiteParser::ANALYZE_);
    setState(331);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx)) {
    case 1: {
      setState(324);
      schema_name();
      break;
    }

    case 2: {
      setState(328);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 14, _ctx)) {
      case 1: {
        setState(325);
        schema_name();
        setState(326);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(330);
      table_or_index_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Attach_stmtContext ------------------------------------------------------------------

SQLiteParser::Attach_stmtContext::Attach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Attach_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Attach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Attach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Attach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleAttach_stmt;
}

void SQLiteParser::Attach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAttach_stmt(this);
}

void SQLiteParser::Attach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAttach_stmt(this);
}


std::any SQLiteParser::Attach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAttach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Attach_stmtContext* SQLiteParser::attach_stmt() {
  Attach_stmtContext *_localctx = _tracker.createInstance<Attach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 10, SQLiteParser::RuleAttach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(333);
    match(SQLiteParser::ATTACH_);
    setState(335);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx)) {
    case 1: {
      setState(334);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(337);
    expr(0);
    setState(338);
    match(SQLiteParser::AS_);
    setState(339);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Begin_stmtContext ------------------------------------------------------------------

SQLiteParser::Begin_stmtContext::Begin_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::Begin_stmtContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}

SQLiteParser::Transaction_nameContext* SQLiteParser::Begin_stmtContext::transaction_name() {
  return getRuleContext<SQLiteParser::Transaction_nameContext>(0);
}


size_t SQLiteParser::Begin_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleBegin_stmt;
}

void SQLiteParser::Begin_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBegin_stmt(this);
}

void SQLiteParser::Begin_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBegin_stmt(this);
}


std::any SQLiteParser::Begin_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBegin_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Begin_stmtContext* SQLiteParser::begin_stmt() {
  Begin_stmtContext *_localctx = _tracker.createInstance<Begin_stmtContext>(_ctx, getState());
  enterRule(_localctx, 12, SQLiteParser::RuleBegin_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(341);
    match(SQLiteParser::BEGIN_);
    setState(343);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 58) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 58)) & 16779265) != 0)) {
      setState(342);
      _la = _input->LA(1);
      if (!(((((_la - 58) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 58)) & 16779265) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(349);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(345);
      match(SQLiteParser::TRANSACTION_);
      setState(347);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 18, _ctx)) {
      case 1: {
        setState(346);
        transaction_name();
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Commit_stmtContext ------------------------------------------------------------------

SQLiteParser::Commit_stmtContext::Commit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Commit_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}


size_t SQLiteParser::Commit_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCommit_stmt;
}

void SQLiteParser::Commit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommit_stmt(this);
}

void SQLiteParser::Commit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommit_stmt(this);
}


std::any SQLiteParser::Commit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommit_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Commit_stmtContext* SQLiteParser::commit_stmt() {
  Commit_stmtContext *_localctx = _tracker.createInstance<Commit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 14, SQLiteParser::RuleCommit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(351);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::COMMIT_

    || _la == SQLiteParser::END_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(353);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(352);
      match(SQLiteParser::TRANSACTION_);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Rollback_stmtContext ------------------------------------------------------------------

SQLiteParser::Rollback_stmtContext::Rollback_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Rollback_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Rollback_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Rollback_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRollback_stmt;
}

void SQLiteParser::Rollback_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRollback_stmt(this);
}

void SQLiteParser::Rollback_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRollback_stmt(this);
}


std::any SQLiteParser::Rollback_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRollback_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Rollback_stmtContext* SQLiteParser::rollback_stmt() {
  Rollback_stmtContext *_localctx = _tracker.createInstance<Rollback_stmtContext>(_ctx, getState());
  enterRule(_localctx, 16, SQLiteParser::RuleRollback_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(355);
    match(SQLiteParser::ROLLBACK_);
    setState(357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TRANSACTION_) {
      setState(356);
      match(SQLiteParser::TRANSACTION_);
    }
    setState(364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TO_) {
      setState(359);
      match(SQLiteParser::TO_);
      setState(361);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 22, _ctx)) {
      case 1: {
        setState(360);
        match(SQLiteParser::SAVEPOINT_);
        break;
      }

      default:
        break;
      }
      setState(363);
      savepoint_name();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_stmtContext ------------------------------------------------------------------

SQLiteParser::Savepoint_stmtContext::Savepoint_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Savepoint_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Savepoint_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}


size_t SQLiteParser::Savepoint_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_stmt;
}

void SQLiteParser::Savepoint_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_stmt(this);
}

void SQLiteParser::Savepoint_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_stmt(this);
}


std::any SQLiteParser::Savepoint_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_stmtContext* SQLiteParser::savepoint_stmt() {
  Savepoint_stmtContext *_localctx = _tracker.createInstance<Savepoint_stmtContext>(_ctx, getState());
  enterRule(_localctx, 18, SQLiteParser::RuleSavepoint_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(366);
    match(SQLiteParser::SAVEPOINT_);
    setState(367);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Release_stmtContext ------------------------------------------------------------------

SQLiteParser::Release_stmtContext::Release_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::Release_stmtContext::savepoint_name() {
  return getRuleContext<SQLiteParser::Savepoint_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Release_stmtContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}


size_t SQLiteParser::Release_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleRelease_stmt;
}

void SQLiteParser::Release_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRelease_stmt(this);
}

void SQLiteParser::Release_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRelease_stmt(this);
}


std::any SQLiteParser::Release_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRelease_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Release_stmtContext* SQLiteParser::release_stmt() {
  Release_stmtContext *_localctx = _tracker.createInstance<Release_stmtContext>(_ctx, getState());
  enterRule(_localctx, 20, SQLiteParser::RuleRelease_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(369);
    match(SQLiteParser::RELEASE_);
    setState(371);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
    case 1: {
      setState(370);
      match(SQLiteParser::SAVEPOINT_);
      break;
    }

    default:
      break;
    }
    setState(373);
    savepoint_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_index_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_index_stmtContext::Create_index_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Create_index_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_index_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Create_index_stmtContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Create_index_stmtContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_index_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_index_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Create_index_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_index_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}


size_t SQLiteParser::Create_index_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_index_stmt;
}

void SQLiteParser::Create_index_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_index_stmt(this);
}

void SQLiteParser::Create_index_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_index_stmt(this);
}


std::any SQLiteParser::Create_index_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_index_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_index_stmtContext* SQLiteParser::create_index_stmt() {
  Create_index_stmtContext *_localctx = _tracker.createInstance<Create_index_stmtContext>(_ctx, getState());
  enterRule(_localctx, 22, SQLiteParser::RuleCreate_index_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(375);
    match(SQLiteParser::CREATE_);
    setState(377);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::UNIQUE_) {
      setState(376);
      match(SQLiteParser::UNIQUE_);
    }
    setState(379);
    match(SQLiteParser::INDEX_);
    setState(383);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(380);
      match(SQLiteParser::IF_);
      setState(381);
      match(SQLiteParser::NOT_);
      setState(382);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(388);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(385);
      schema_name();
      setState(386);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(390);
    index_name();
    setState(391);
    match(SQLiteParser::ON_);
    setState(392);
    table_name();
    setState(393);
    match(SQLiteParser::OPEN_PAR);
    setState(394);
    indexed_column();
    setState(399);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(395);
      match(SQLiteParser::COMMA);
      setState(396);
      indexed_column();
      setState(401);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(402);
    match(SQLiteParser::CLOSE_PAR);
    setState(405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(403);
      match(SQLiteParser::WHERE_);
      setState(404);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Indexed_columnContext ------------------------------------------------------------------

SQLiteParser::Indexed_columnContext::Indexed_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Indexed_columnContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::ExprContext* SQLiteParser::Indexed_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Indexed_columnContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Indexed_columnContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Indexed_columnContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}


size_t SQLiteParser::Indexed_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleIndexed_column;
}

void SQLiteParser::Indexed_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexed_column(this);
}

void SQLiteParser::Indexed_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexed_column(this);
}


std::any SQLiteParser::Indexed_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndexed_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Indexed_columnContext* SQLiteParser::indexed_column() {
  Indexed_columnContext *_localctx = _tracker.createInstance<Indexed_columnContext>(_ctx, getState());
  enterRule(_localctx, 24, SQLiteParser::RuleIndexed_column);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(409);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      setState(407);
      column_name();
      break;
    }

    case 2: {
      setState(408);
      expr(0);
      break;
    }

    default:
      break;
    }
    setState(413);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(411);
      match(SQLiteParser::COLLATE_);
      setState(412);
      collation_name();
    }
    setState(416);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(415);
      asc_desc();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_table_stmtContext::Create_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_defContext *> SQLiteParser::Create_table_stmtContext::column_def() {
  return getRuleContexts<SQLiteParser::Column_defContext>();
}

SQLiteParser::Column_defContext* SQLiteParser::Create_table_stmtContext::column_def(size_t i) {
  return getRuleContext<SQLiteParser::Column_defContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_table_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<SQLiteParser::Table_constraintContext *> SQLiteParser::Create_table_stmtContext::table_constraint() {
  return getRuleContexts<SQLiteParser::Table_constraintContext>();
}

SQLiteParser::Table_constraintContext* SQLiteParser::Create_table_stmtContext::table_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Table_constraintContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::WITHOUT_() {
  return getToken(SQLiteParser::WITHOUT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_table_stmtContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}


size_t SQLiteParser::Create_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_table_stmt;
}

void SQLiteParser::Create_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_table_stmt(this);
}

void SQLiteParser::Create_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_table_stmt(this);
}


std::any SQLiteParser::Create_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_table_stmtContext* SQLiteParser::create_table_stmt() {
  Create_table_stmtContext *_localctx = _tracker.createInstance<Create_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 26, SQLiteParser::RuleCreate_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(418);
    match(SQLiteParser::CREATE_);
    setState(420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(419);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(422);
    match(SQLiteParser::TABLE_);
    setState(426);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      setState(423);
      match(SQLiteParser::IF_);
      setState(424);
      match(SQLiteParser::NOT_);
      setState(425);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(431);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
    case 1: {
      setState(428);
      schema_name();
      setState(429);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(433);
    table_name();
    setState(457);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR: {
        setState(434);
        match(SQLiteParser::OPEN_PAR);
        setState(435);
        column_def();
        setState(440);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
        while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1 + 1) {
            setState(436);
            match(SQLiteParser::COMMA);
            setState(437);
            column_def(); 
          }
          setState(442);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 36, _ctx);
        }
        setState(447);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(443);
          match(SQLiteParser::COMMA);
          setState(444);
          table_constraint();
          setState(449);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(450);
        match(SQLiteParser::CLOSE_PAR);
        setState(453);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WITHOUT_) {
          setState(451);
          match(SQLiteParser::WITHOUT_);
          setState(452);
          antlrcpp::downCast<Create_table_stmtContext *>(_localctx)->row_ROW_ID = match(SQLiteParser::IDENTIFIER);
        }
        break;
      }

      case SQLiteParser::AS_: {
        setState(455);
        match(SQLiteParser::AS_);
        setState(456);
        select_stmt();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_defContext ------------------------------------------------------------------

SQLiteParser::Column_defContext::Column_defContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_defContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Type_nameContext* SQLiteParser::Column_defContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

std::vector<SQLiteParser::Column_constraintContext *> SQLiteParser::Column_defContext::column_constraint() {
  return getRuleContexts<SQLiteParser::Column_constraintContext>();
}

SQLiteParser::Column_constraintContext* SQLiteParser::Column_defContext::column_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Column_constraintContext>(i);
}


size_t SQLiteParser::Column_defContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_def;
}

void SQLiteParser::Column_defContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_def(this);
}

void SQLiteParser::Column_defContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_def(this);
}


std::any SQLiteParser::Column_defContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_def(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_defContext* SQLiteParser::column_def() {
  Column_defContext *_localctx = _tracker.createInstance<Column_defContext>(_ctx, getState());
  enterRule(_localctx, 28, SQLiteParser::RuleColumn_def);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(459);
    column_name();
    setState(461);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
    case 1: {
      setState(460);
      type_name();
      break;
    }

    default:
      break;
    }
    setState(466);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 72673329139417088) != 0) || ((((_la - 102) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 102)) & 274877941765) != 0) || _la == SQLiteParser::GENERATED_) {
      setState(463);
      column_constraint();
      setState(468);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Type_nameContext ------------------------------------------------------------------

SQLiteParser::Type_nameContext::Type_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Type_nameContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Type_nameContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Signed_numberContext *> SQLiteParser::Type_nameContext::signed_number() {
  return getRuleContexts<SQLiteParser::Signed_numberContext>();
}

SQLiteParser::Signed_numberContext* SQLiteParser::Type_nameContext::signed_number(size_t i) {
  return getRuleContext<SQLiteParser::Signed_numberContext>(i);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Type_nameContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Type_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleType_name;
}

void SQLiteParser::Type_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterType_name(this);
}

void SQLiteParser::Type_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitType_name(this);
}


std::any SQLiteParser::Type_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitType_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Type_nameContext* SQLiteParser::type_name() {
  Type_nameContext *_localctx = _tracker.createInstance<Type_nameContext>(_ctx, getState());
  enterRule(_localctx, 30, SQLiteParser::RuleType_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(470); 
    _errHandler->sync(this);
    alt = 1 + 1;
    do {
      switch (alt) {
        case 1 + 1: {
              setState(469);
              name();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(472); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    } while (alt != 1 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(484);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
    case 1: {
      setState(474);
      match(SQLiteParser::OPEN_PAR);
      setState(475);
      signed_number();
      setState(476);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 2: {
      setState(478);
      match(SQLiteParser::OPEN_PAR);
      setState(479);
      signed_number();
      setState(480);
      match(SQLiteParser::COMMA);
      setState(481);
      signed_number();
      setState(482);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_constraintContext ------------------------------------------------------------------

SQLiteParser::Column_constraintContext::Column_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Column_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Column_constraintContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Column_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Column_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Column_constraintContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::Literal_valueContext* SQLiteParser::Column_constraintContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Column_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Column_constraintContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::Column_constraintContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Column_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_constraint;
}

void SQLiteParser::Column_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_constraint(this);
}

void SQLiteParser::Column_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_constraint(this);
}


std::any SQLiteParser::Column_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_constraintContext* SQLiteParser::column_constraint() {
  Column_constraintContext *_localctx = _tracker.createInstance<Column_constraintContext>(_ctx, getState());
  enterRule(_localctx, 32, SQLiteParser::RuleColumn_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(486);
      match(SQLiteParser::CONSTRAINT_);
      setState(487);
      name();
    }
    setState(539);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_: {
        setState(490);
        match(SQLiteParser::PRIMARY_);
        setState(491);
        match(SQLiteParser::KEY_);
        setState(493);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ASC_

        || _la == SQLiteParser::DESC_) {
          setState(492);
          asc_desc();
        }
        setState(496);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(495);
          conflict_clause();
        }
        setState(499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::AUTOINCREMENT_) {
          setState(498);
          match(SQLiteParser::AUTOINCREMENT_);
        }
        break;
      }

      case SQLiteParser::NOT_:
      case SQLiteParser::NULL_:
      case SQLiteParser::UNIQUE_: {
        setState(506);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::NOT_:
          case SQLiteParser::NULL_: {
            setState(502);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::NOT_) {
              setState(501);
              match(SQLiteParser::NOT_);
            }
            setState(504);
            match(SQLiteParser::NULL_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(505);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(509);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(508);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(511);
        match(SQLiteParser::CHECK_);
        setState(512);
        match(SQLiteParser::OPEN_PAR);
        setState(513);
        expr(0);
        setState(514);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(516);
        match(SQLiteParser::DEFAULT_);
        setState(523);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
        case 1: {
          setState(517);
          signed_number();
          break;
        }

        case 2: {
          setState(518);
          literal_value();
          break;
        }

        case 3: {
          setState(519);
          match(SQLiteParser::OPEN_PAR);
          setState(520);
          expr(0);
          setState(521);
          match(SQLiteParser::CLOSE_PAR);
          break;
        }

        default:
          break;
        }
        break;
      }

      case SQLiteParser::COLLATE_: {
        setState(525);
        match(SQLiteParser::COLLATE_);
        setState(526);
        collation_name();
        break;
      }

      case SQLiteParser::REFERENCES_: {
        setState(527);
        foreign_key_clause();
        break;
      }

      case SQLiteParser::AS_:
      case SQLiteParser::GENERATED_: {
        setState(530);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GENERATED_) {
          setState(528);
          match(SQLiteParser::GENERATED_);
          setState(529);
          match(SQLiteParser::ALWAYS_);
        }
        setState(532);
        match(SQLiteParser::AS_);
        setState(533);
        match(SQLiteParser::OPEN_PAR);
        setState(534);
        expr(0);
        setState(535);
        match(SQLiteParser::CLOSE_PAR);
        setState(537);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::VIRTUAL_

        || _la == SQLiteParser::STORED_) {
          setState(536);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::VIRTUAL_

          || _la == SQLiteParser::STORED_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Signed_numberContext ------------------------------------------------------------------

SQLiteParser::Signed_numberContext::Signed_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::Signed_numberContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}


size_t SQLiteParser::Signed_numberContext::getRuleIndex() const {
  return SQLiteParser::RuleSigned_number;
}

void SQLiteParser::Signed_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSigned_number(this);
}

void SQLiteParser::Signed_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSigned_number(this);
}


std::any SQLiteParser::Signed_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSigned_number(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Signed_numberContext* SQLiteParser::signed_number() {
  Signed_numberContext *_localctx = _tracker.createInstance<Signed_numberContext>(_ctx, getState());
  enterRule(_localctx, 34, SQLiteParser::RuleSigned_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PLUS

    || _la == SQLiteParser::MINUS) {
      setState(541);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::PLUS

      || _la == SQLiteParser::MINUS)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(544);
    match(SQLiteParser::NUMERIC_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_constraintContext ------------------------------------------------------------------

SQLiteParser::Table_constraintContext::Table_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Table_constraintContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Table_constraintContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Table_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Table_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Table_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::Table_constraintContext::foreign_key_clause() {
  return getRuleContext<SQLiteParser::Foreign_key_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

SQLiteParser::NameContext* SQLiteParser::Table_constraintContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Table_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Table_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::Table_constraintContext::conflict_clause() {
  return getRuleContext<SQLiteParser::Conflict_clauseContext>(0);
}


size_t SQLiteParser::Table_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_constraint;
}

void SQLiteParser::Table_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_constraint(this);
}

void SQLiteParser::Table_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_constraint(this);
}


std::any SQLiteParser::Table_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_constraintContext* SQLiteParser::table_constraint() {
  Table_constraintContext *_localctx = _tracker.createInstance<Table_constraintContext>(_ctx, getState());
  enterRule(_localctx, 36, SQLiteParser::RuleTable_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(548);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::CONSTRAINT_) {
      setState(546);
      match(SQLiteParser::CONSTRAINT_);
      setState(547);
      name();
    }
    setState(587);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::UNIQUE_: {
        setState(553);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::PRIMARY_: {
            setState(550);
            match(SQLiteParser::PRIMARY_);
            setState(551);
            match(SQLiteParser::KEY_);
            break;
          }

          case SQLiteParser::UNIQUE_: {
            setState(552);
            match(SQLiteParser::UNIQUE_);
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        setState(555);
        match(SQLiteParser::OPEN_PAR);
        setState(556);
        indexed_column();
        setState(561);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(557);
          match(SQLiteParser::COMMA);
          setState(558);
          indexed_column();
          setState(563);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(564);
        match(SQLiteParser::CLOSE_PAR);
        setState(566);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(565);
          conflict_clause();
        }
        break;
      }

      case SQLiteParser::CHECK_: {
        setState(568);
        match(SQLiteParser::CHECK_);
        setState(569);
        match(SQLiteParser::OPEN_PAR);
        setState(570);
        expr(0);
        setState(571);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::FOREIGN_: {
        setState(573);
        match(SQLiteParser::FOREIGN_);
        setState(574);
        match(SQLiteParser::KEY_);
        setState(575);
        match(SQLiteParser::OPEN_PAR);
        setState(576);
        column_name();
        setState(581);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(577);
          match(SQLiteParser::COMMA);
          setState(578);
          column_name();
          setState(583);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(584);
        match(SQLiteParser::CLOSE_PAR);
        setState(585);
        foreign_key_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_key_clauseContext ------------------------------------------------------------------

SQLiteParser::Foreign_key_clauseContext::Foreign_key_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::Foreign_key_clauseContext::foreign_table() {
  return getRuleContext<SQLiteParser::Foreign_tableContext>(0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Foreign_key_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Foreign_key_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ON_() {
  return getTokens(SQLiteParser::ON_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ON_(size_t i) {
  return getToken(SQLiteParser::ON_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::MATCH_() {
  return getTokens(SQLiteParser::MATCH_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::MATCH_(size_t i) {
  return getToken(SQLiteParser::MATCH_, i);
}

std::vector<SQLiteParser::NameContext *> SQLiteParser::Foreign_key_clauseContext::name() {
  return getRuleContexts<SQLiteParser::NameContext>();
}

SQLiteParser::NameContext* SQLiteParser::Foreign_key_clauseContext::name(size_t i) {
  return getRuleContext<SQLiteParser::NameContext>(i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DELETE_() {
  return getTokens(SQLiteParser::DELETE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DELETE_(size_t i) {
  return getToken(SQLiteParser::DELETE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::UPDATE_() {
  return getTokens(SQLiteParser::UPDATE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::UPDATE_(size_t i) {
  return getToken(SQLiteParser::UPDATE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::SET_() {
  return getTokens(SQLiteParser::SET_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::SET_(size_t i) {
  return getToken(SQLiteParser::SET_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::CASCADE_() {
  return getTokens(SQLiteParser::CASCADE_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::CASCADE_(size_t i) {
  return getToken(SQLiteParser::CASCADE_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::RESTRICT_() {
  return getTokens(SQLiteParser::RESTRICT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::RESTRICT_(size_t i) {
  return getToken(SQLiteParser::RESTRICT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NO_() {
  return getTokens(SQLiteParser::NO_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NO_(size_t i) {
  return getToken(SQLiteParser::NO_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::ACTION_() {
  return getTokens(SQLiteParser::ACTION_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::ACTION_(size_t i) {
  return getToken(SQLiteParser::ACTION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::NULL_() {
  return getTokens(SQLiteParser::NULL_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NULL_(size_t i) {
  return getToken(SQLiteParser::NULL_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Foreign_key_clauseContext::DEFAULT_() {
  return getTokens(SQLiteParser::DEFAULT_);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFAULT_(size_t i) {
  return getToken(SQLiteParser::DEFAULT_, i);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::Foreign_key_clauseContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}


size_t SQLiteParser::Foreign_key_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_key_clause;
}

void SQLiteParser::Foreign_key_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_key_clause(this);
}

void SQLiteParser::Foreign_key_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_key_clause(this);
}


std::any SQLiteParser::Foreign_key_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_key_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_key_clauseContext* SQLiteParser::foreign_key_clause() {
  Foreign_key_clauseContext *_localctx = _tracker.createInstance<Foreign_key_clauseContext>(_ctx, getState());
  enterRule(_localctx, 38, SQLiteParser::RuleForeign_key_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(589);
    match(SQLiteParser::REFERENCES_);
    setState(590);
    foreign_table();
    setState(602);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(591);
      match(SQLiteParser::OPEN_PAR);
      setState(592);
      column_name();
      setState(597);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(593);
        match(SQLiteParser::COMMA);
        setState(594);
        column_name();
        setState(599);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(600);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(618);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::MATCH_

    || _la == SQLiteParser::ON_) {
      setState(616);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::ON_: {
          setState(604);
          match(SQLiteParser::ON_);
          setState(605);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::DELETE_ || _la == SQLiteParser::UPDATE_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(612);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::SET_: {
              setState(606);
              match(SQLiteParser::SET_);
              setState(607);
              _la = _input->LA(1);
              if (!(_la == SQLiteParser::DEFAULT_

              || _la == SQLiteParser::NULL_)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

            case SQLiteParser::CASCADE_: {
              setState(608);
              match(SQLiteParser::CASCADE_);
              break;
            }

            case SQLiteParser::RESTRICT_: {
              setState(609);
              match(SQLiteParser::RESTRICT_);
              break;
            }

            case SQLiteParser::NO_: {
              setState(610);
              match(SQLiteParser::NO_);
              setState(611);
              match(SQLiteParser::ACTION_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case SQLiteParser::MATCH_: {
          setState(614);
          match(SQLiteParser::MATCH_);
          setState(615);
          name();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(620);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
    case 1: {
      setState(622);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::NOT_) {
        setState(621);
        match(SQLiteParser::NOT_);
      }
      setState(624);
      match(SQLiteParser::DEFERRABLE_);
      setState(627);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::INITIALLY_) {
        setState(625);
        match(SQLiteParser::INITIALLY_);
        setState(626);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::DEFERRED_

        || _la == SQLiteParser::IMMEDIATE_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Conflict_clauseContext ------------------------------------------------------------------

SQLiteParser::Conflict_clauseContext::Conflict_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Conflict_clauseContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}


size_t SQLiteParser::Conflict_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleConflict_clause;
}

void SQLiteParser::Conflict_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConflict_clause(this);
}

void SQLiteParser::Conflict_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConflict_clause(this);
}


std::any SQLiteParser::Conflict_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitConflict_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Conflict_clauseContext* SQLiteParser::conflict_clause() {
  Conflict_clauseContext *_localctx = _tracker.createInstance<Conflict_clauseContext>(_ctx, getState());
  enterRule(_localctx, 40, SQLiteParser::RuleConflict_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(631);
    match(SQLiteParser::ON_);
    setState(632);
    match(SQLiteParser::CONFLICT_);
    setState(633);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_trigger_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_trigger_stmtContext::Create_trigger_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::Create_trigger_stmtContext::trigger_name() {
  return getRuleContext<SQLiteParser::Trigger_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_trigger_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_trigger_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::OF_() {
  return getTokens(SQLiteParser::OF_);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::OF_(size_t i) {
  return getToken(SQLiteParser::OF_, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Create_trigger_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::SCOL() {
  return getTokens(SQLiteParser::SCOL);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::SCOL(size_t i) {
  return getToken(SQLiteParser::SCOL, i);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_trigger_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_trigger_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Update_stmtContext *> SQLiteParser::Create_trigger_stmtContext::update_stmt() {
  return getRuleContexts<SQLiteParser::Update_stmtContext>();
}

SQLiteParser::Update_stmtContext* SQLiteParser::Create_trigger_stmtContext::update_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Update_stmtContext>(i);
}

std::vector<SQLiteParser::Insert_stmtContext *> SQLiteParser::Create_trigger_stmtContext::insert_stmt() {
  return getRuleContexts<SQLiteParser::Insert_stmtContext>();
}

SQLiteParser::Insert_stmtContext* SQLiteParser::Create_trigger_stmtContext::insert_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Insert_stmtContext>(i);
}

std::vector<SQLiteParser::Delete_stmtContext *> SQLiteParser::Create_trigger_stmtContext::delete_stmt() {
  return getRuleContexts<SQLiteParser::Delete_stmtContext>();
}

SQLiteParser::Delete_stmtContext* SQLiteParser::Create_trigger_stmtContext::delete_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Delete_stmtContext>(i);
}

std::vector<SQLiteParser::Select_stmtContext *> SQLiteParser::Create_trigger_stmtContext::select_stmt() {
  return getRuleContexts<SQLiteParser::Select_stmtContext>();
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_trigger_stmtContext::select_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Select_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_trigger_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_trigger_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_trigger_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_trigger_stmt;
}

void SQLiteParser::Create_trigger_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_trigger_stmt(this);
}

void SQLiteParser::Create_trigger_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_trigger_stmt(this);
}


std::any SQLiteParser::Create_trigger_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_trigger_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_trigger_stmtContext* SQLiteParser::create_trigger_stmt() {
  Create_trigger_stmtContext *_localctx = _tracker.createInstance<Create_trigger_stmtContext>(_ctx, getState());
  enterRule(_localctx, 42, SQLiteParser::RuleCreate_trigger_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(635);
    match(SQLiteParser::CREATE_);
    setState(637);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(636);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(639);
    match(SQLiteParser::TRIGGER_);
    setState(643);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx)) {
    case 1: {
      setState(640);
      match(SQLiteParser::IF_);
      setState(641);
      match(SQLiteParser::NOT_);
      setState(642);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      setState(645);
      schema_name();
      setState(646);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(650);
    trigger_name();
    setState(655);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::BEFORE_: {
        setState(651);
        match(SQLiteParser::BEFORE_);
        break;
      }

      case SQLiteParser::AFTER_: {
        setState(652);
        match(SQLiteParser::AFTER_);
        break;
      }

      case SQLiteParser::INSTEAD_: {
        setState(653);
        match(SQLiteParser::INSTEAD_);
        setState(654);
        match(SQLiteParser::OF_);
        break;
      }

      case SQLiteParser::DELETE_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::UPDATE_: {
        break;
      }

    default:
      break;
    }
    setState(671);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::DELETE_: {
        setState(657);
        match(SQLiteParser::DELETE_);
        break;
      }

      case SQLiteParser::INSERT_: {
        setState(658);
        match(SQLiteParser::INSERT_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(659);
        match(SQLiteParser::UPDATE_);
        setState(669);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::OF_) {
          setState(660);
          match(SQLiteParser::OF_);
          setState(661);
          column_name();
          setState(666);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(662);
            match(SQLiteParser::COMMA);
            setState(663);
            column_name();
            setState(668);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(673);
    match(SQLiteParser::ON_);
    setState(674);
    table_name();
    setState(678);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FOR_) {
      setState(675);
      match(SQLiteParser::FOR_);
      setState(676);
      match(SQLiteParser::EACH_);
      setState(677);
      match(SQLiteParser::ROW_);
    }
    setState(682);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHEN_) {
      setState(680);
      match(SQLiteParser::WHEN_);
      setState(681);
      expr(0);
    }
    setState(684);
    match(SQLiteParser::BEGIN_);
    setState(693); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(689);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
      case 1: {
        setState(685);
        update_stmt();
        break;
      }

      case 2: {
        setState(686);
        insert_stmt();
        break;
      }

      case 3: {
        setState(687);
        delete_stmt();
        break;
      }

      case 4: {
        setState(688);
        select_stmt();
        break;
      }

      default:
        break;
      }
      setState(691);
      match(SQLiteParser::SCOL);
      setState(695); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::DELETE_ || ((((_la - 88) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 88)) & 2386912217732743169) != 0));
    setState(697);
    match(SQLiteParser::END_);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_view_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_view_stmtContext::Create_view_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

SQLiteParser::View_nameContext* SQLiteParser::Create_view_stmtContext::view_name() {
  return getRuleContext<SQLiteParser::View_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Create_view_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_view_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Create_view_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Create_view_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_view_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_view_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_view_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_view_stmt;
}

void SQLiteParser::Create_view_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_view_stmt(this);
}

void SQLiteParser::Create_view_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_view_stmt(this);
}


std::any SQLiteParser::Create_view_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_view_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_view_stmtContext* SQLiteParser::create_view_stmt() {
  Create_view_stmtContext *_localctx = _tracker.createInstance<Create_view_stmtContext>(_ctx, getState());
  enterRule(_localctx, 44, SQLiteParser::RuleCreate_view_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(699);
    match(SQLiteParser::CREATE_);
    setState(701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::TEMP_

    || _la == SQLiteParser::TEMPORARY_) {
      setState(700);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::TEMP_

      || _la == SQLiteParser::TEMPORARY_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(703);
    match(SQLiteParser::VIEW_);
    setState(707);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 82, _ctx)) {
    case 1: {
      setState(704);
      match(SQLiteParser::IF_);
      setState(705);
      match(SQLiteParser::NOT_);
      setState(706);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(712);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 83, _ctx)) {
    case 1: {
      setState(709);
      schema_name();
      setState(710);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(714);
    view_name();
    setState(726);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(715);
      match(SQLiteParser::OPEN_PAR);
      setState(716);
      column_name();
      setState(721);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(717);
        match(SQLiteParser::COMMA);
        setState(718);
        column_name();
        setState(723);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(724);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(728);
    match(SQLiteParser::AS_);
    setState(729);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Create_virtual_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Create_virtual_table_stmtContext::Create_virtual_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Create_virtual_table_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

SQLiteParser::Module_nameContext* SQLiteParser::Create_virtual_table_stmtContext::module_name() {
  return getRuleContext<SQLiteParser::Module_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Create_virtual_table_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Module_argumentContext *> SQLiteParser::Create_virtual_table_stmtContext::module_argument() {
  return getRuleContexts<SQLiteParser::Module_argumentContext>();
}

SQLiteParser::Module_argumentContext* SQLiteParser::Create_virtual_table_stmtContext::module_argument(size_t i) {
  return getRuleContext<SQLiteParser::Module_argumentContext>(i);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Create_virtual_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Create_virtual_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Create_virtual_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCreate_virtual_table_stmt;
}

void SQLiteParser::Create_virtual_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreate_virtual_table_stmt(this);
}

void SQLiteParser::Create_virtual_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreate_virtual_table_stmt(this);
}


std::any SQLiteParser::Create_virtual_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCreate_virtual_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Create_virtual_table_stmtContext* SQLiteParser::create_virtual_table_stmt() {
  Create_virtual_table_stmtContext *_localctx = _tracker.createInstance<Create_virtual_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 46, SQLiteParser::RuleCreate_virtual_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(731);
    match(SQLiteParser::CREATE_);
    setState(732);
    match(SQLiteParser::VIRTUAL_);
    setState(733);
    match(SQLiteParser::TABLE_);
    setState(737);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(734);
      match(SQLiteParser::IF_);
      setState(735);
      match(SQLiteParser::NOT_);
      setState(736);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(742);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
    case 1: {
      setState(739);
      schema_name();
      setState(740);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(744);
    table_name();
    setState(745);
    match(SQLiteParser::USING_);
    setState(746);
    module_name();
    setState(758);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(747);
      match(SQLiteParser::OPEN_PAR);
      setState(748);
      module_argument();
      setState(753);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(749);
        match(SQLiteParser::COMMA);
        setState(750);
        module_argument();
        setState(755);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(756);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- With_clauseContext ------------------------------------------------------------------

SQLiteParser::With_clauseContext::With_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::With_clauseContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

std::vector<SQLiteParser::Cte_table_nameContext *> SQLiteParser::With_clauseContext::cte_table_name() {
  return getRuleContexts<SQLiteParser::Cte_table_nameContext>();
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::With_clauseContext::cte_table_name(size_t i) {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

std::vector<SQLiteParser::Select_stmtContext *> SQLiteParser::With_clauseContext::select_stmt() {
  return getRuleContexts<SQLiteParser::Select_stmtContext>();
}

SQLiteParser::Select_stmtContext* SQLiteParser::With_clauseContext::select_stmt(size_t i) {
  return getRuleContext<SQLiteParser::Select_stmtContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::With_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::With_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::With_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleWith_clause;
}

void SQLiteParser::With_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWith_clause(this);
}

void SQLiteParser::With_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWith_clause(this);
}


std::any SQLiteParser::With_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWith_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::With_clauseContext* SQLiteParser::with_clause() {
  With_clauseContext *_localctx = _tracker.createInstance<With_clauseContext>(_ctx, getState());
  enterRule(_localctx, 48, SQLiteParser::RuleWith_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(760);
    match(SQLiteParser::WITH_);
    setState(762);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 90, _ctx)) {
    case 1: {
      setState(761);
      match(SQLiteParser::RECURSIVE_);
      break;
    }

    default:
      break;
    }
    setState(764);
    cte_table_name();
    setState(765);
    match(SQLiteParser::AS_);
    setState(766);
    match(SQLiteParser::OPEN_PAR);
    setState(767);
    select_stmt();
    setState(768);
    match(SQLiteParser::CLOSE_PAR);
    setState(778);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(769);
      match(SQLiteParser::COMMA);
      setState(770);
      cte_table_name();
      setState(771);
      match(SQLiteParser::AS_);
      setState(772);
      match(SQLiteParser::OPEN_PAR);
      setState(773);
      select_stmt();
      setState(774);
      match(SQLiteParser::CLOSE_PAR);
      setState(780);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Cte_table_nameContext ------------------------------------------------------------------

SQLiteParser::Cte_table_nameContext::Cte_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Cte_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Cte_table_nameContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Cte_table_nameContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Cte_table_nameContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Cte_table_nameContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Cte_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCte_table_name;
}

void SQLiteParser::Cte_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCte_table_name(this);
}

void SQLiteParser::Cte_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCte_table_name(this);
}


std::any SQLiteParser::Cte_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCte_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::cte_table_name() {
  Cte_table_nameContext *_localctx = _tracker.createInstance<Cte_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 50, SQLiteParser::RuleCte_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(781);
    table_name();
    setState(793);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(782);
      match(SQLiteParser::OPEN_PAR);
      setState(783);
      column_name();
      setState(788);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(784);
        match(SQLiteParser::COMMA);
        setState(785);
        column_name();
        setState(790);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(791);
      match(SQLiteParser::CLOSE_PAR);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_cteContext ------------------------------------------------------------------

SQLiteParser::Recursive_cteContext::Recursive_cteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Cte_table_nameContext* SQLiteParser::Recursive_cteContext::cte_table_name() {
  return getRuleContext<SQLiteParser::Cte_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Initial_selectContext* SQLiteParser::Recursive_cteContext::initial_select() {
  return getRuleContext<SQLiteParser::Initial_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::Recursive_cteContext::recursive_select() {
  return getRuleContext<SQLiteParser::Recursive_selectContext>(0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Recursive_cteContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}


size_t SQLiteParser::Recursive_cteContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_cte;
}

void SQLiteParser::Recursive_cteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_cte(this);
}

void SQLiteParser::Recursive_cteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_cte(this);
}


std::any SQLiteParser::Recursive_cteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_cte(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_cteContext* SQLiteParser::recursive_cte() {
  Recursive_cteContext *_localctx = _tracker.createInstance<Recursive_cteContext>(_ctx, getState());
  enterRule(_localctx, 52, SQLiteParser::RuleRecursive_cte);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(795);
    cte_table_name();
    setState(796);
    match(SQLiteParser::AS_);
    setState(797);
    match(SQLiteParser::OPEN_PAR);
    setState(798);
    initial_select();
    setState(799);
    match(SQLiteParser::UNION_);
    setState(801);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ALL_) {
      setState(800);
      match(SQLiteParser::ALL_);
    }
    setState(803);
    recursive_select();
    setState(804);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_expressionContext ------------------------------------------------------------------

SQLiteParser::Common_table_expressionContext::Common_table_expressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Common_table_expressionContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Common_table_expressionContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Common_table_expressionContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Common_table_expressionContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_expressionContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Common_table_expressionContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Common_table_expressionContext::getRuleIndex() const {
  return SQLiteParser::RuleCommon_table_expression;
}

void SQLiteParser::Common_table_expressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_expression(this);
}

void SQLiteParser::Common_table_expressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_expression(this);
}


std::any SQLiteParser::Common_table_expressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_expression(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::common_table_expression() {
  Common_table_expressionContext *_localctx = _tracker.createInstance<Common_table_expressionContext>(_ctx, getState());
  enterRule(_localctx, 54, SQLiteParser::RuleCommon_table_expression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(806);
    table_name();
    setState(818);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(807);
      match(SQLiteParser::OPEN_PAR);
      setState(808);
      column_name();
      setState(813);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(809);
        match(SQLiteParser::COMMA);
        setState(810);
        column_name();
        setState(815);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(816);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(820);
    match(SQLiteParser::AS_);
    setState(821);
    match(SQLiteParser::OPEN_PAR);
    setState(822);
    select_stmt();
    setState(823);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmtContext ------------------------------------------------------------------

SQLiteParser::Delete_stmtContext::Delete_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmtContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}


size_t SQLiteParser::Delete_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt;
}

void SQLiteParser::Delete_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt(this);
}

void SQLiteParser::Delete_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt(this);
}


std::any SQLiteParser::Delete_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmtContext* SQLiteParser::delete_stmt() {
  Delete_stmtContext *_localctx = _tracker.createInstance<Delete_stmtContext>(_ctx, getState());
  enterRule(_localctx, 56, SQLiteParser::RuleDelete_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(826);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(825);
      with_clause();
    }
    setState(828);
    match(SQLiteParser::DELETE_);
    setState(829);
    match(SQLiteParser::FROM_);
    setState(830);
    qualified_table_name();
    setState(833);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(831);
      match(SQLiteParser::WHERE_);
      setState(832);
      expr(0);
    }
    setState(836);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(835);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Delete_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Delete_stmt_limitedContext::Delete_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Delete_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Delete_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Delete_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Delete_stmt_limitedContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Delete_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Delete_stmt_limitedContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Delete_stmt_limitedContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}


size_t SQLiteParser::Delete_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleDelete_stmt_limited;
}

void SQLiteParser::Delete_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDelete_stmt_limited(this);
}

void SQLiteParser::Delete_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDelete_stmt_limited(this);
}


std::any SQLiteParser::Delete_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDelete_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Delete_stmt_limitedContext* SQLiteParser::delete_stmt_limited() {
  Delete_stmt_limitedContext *_localctx = _tracker.createInstance<Delete_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 58, SQLiteParser::RuleDelete_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(839);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(838);
      with_clause();
    }
    setState(841);
    match(SQLiteParser::DELETE_);
    setState(842);
    match(SQLiteParser::FROM_);
    setState(843);
    qualified_table_name();
    setState(846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(844);
      match(SQLiteParser::WHERE_);
      setState(845);
      expr(0);
    }
    setState(849);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(848);
      returning_clause();
    }
    setState(855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_

    || _la == SQLiteParser::ORDER_) {
      setState(852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(851);
        order_by_stmt();
      }
      setState(854);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Detach_stmtContext ------------------------------------------------------------------

SQLiteParser::Detach_stmtContext::Detach_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Detach_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Detach_stmtContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}


size_t SQLiteParser::Detach_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDetach_stmt;
}

void SQLiteParser::Detach_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDetach_stmt(this);
}

void SQLiteParser::Detach_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDetach_stmt(this);
}


std::any SQLiteParser::Detach_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDetach_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Detach_stmtContext* SQLiteParser::detach_stmt() {
  Detach_stmtContext *_localctx = _tracker.createInstance<Detach_stmtContext>(_ctx, getState());
  enterRule(_localctx, 60, SQLiteParser::RuleDetach_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(857);
    match(SQLiteParser::DETACH_);
    setState(859);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 105, _ctx)) {
    case 1: {
      setState(858);
      match(SQLiteParser::DATABASE_);
      break;
    }

    default:
      break;
    }
    setState(861);
    schema_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Drop_stmtContext ------------------------------------------------------------------

SQLiteParser::Drop_stmtContext::Drop_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

SQLiteParser::Any_nameContext* SQLiteParser::Drop_stmtContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Drop_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Drop_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Drop_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleDrop_stmt;
}

void SQLiteParser::Drop_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDrop_stmt(this);
}

void SQLiteParser::Drop_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDrop_stmt(this);
}


std::any SQLiteParser::Drop_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDrop_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Drop_stmtContext* SQLiteParser::drop_stmt() {
  Drop_stmtContext *_localctx = _tracker.createInstance<Drop_stmtContext>(_ctx, getState());
  enterRule(_localctx, 62, SQLiteParser::RuleDrop_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(863);
    match(SQLiteParser::DROP_);
    setState(864);
    antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _input->LT(1);
    _la = _input->LA(1);
    if (!(((((_la - 84) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 84)) & 2324138882699886593) != 0))) {
      antlrcpp::downCast<Drop_stmtContext *>(_localctx)->object = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(867);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
    case 1: {
      setState(865);
      match(SQLiteParser::IF_);
      setState(866);
      match(SQLiteParser::EXISTS_);
      break;
    }

    default:
      break;
    }
    setState(872);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
    case 1: {
      setState(869);
      schema_name();
      setState(870);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(874);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

SQLiteParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SQLiteParser::ExprContext::getRuleIndex() const {
  return SQLiteParser::RuleExpr;
}

void SQLiteParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- QualifiedColunExprContext ------------------------------------------------------------------

SQLiteParser::Column_nameContext* SQLiteParser::QualifiedColunExprContext::column_name() {
  return getRuleContext<SQLiteParser::Column_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::QualifiedColunExprContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::QualifiedColunExprContext::DOT() {
  return getTokens(SQLiteParser::DOT);
}

tree::TerminalNode* SQLiteParser::QualifiedColunExprContext::DOT(size_t i) {
  return getToken(SQLiteParser::DOT, i);
}

SQLiteParser::Schema_nameContext* SQLiteParser::QualifiedColunExprContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

SQLiteParser::QualifiedColunExprContext::QualifiedColunExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::QualifiedColunExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedColunExpr(this);
}
void SQLiteParser::QualifiedColunExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedColunExpr(this);
}

std::any SQLiteParser::QualifiedColunExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitQualifiedColunExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AddSubExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::AddSubExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::AddSubExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::AddSubExprContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::AddSubExprContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}

SQLiteParser::AddSubExprContext::AddSubExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::AddSubExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAddSubExpr(this);
}
void SQLiteParser::AddSubExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAddSubExpr(this);
}

std::any SQLiteParser::AddSubExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAddSubExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CastExprContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::CastExprContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::CastExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::ExprContext* SQLiteParser::CastExprContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::CastExprContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Type_nameContext* SQLiteParser::CastExprContext::type_name() {
  return getRuleContext<SQLiteParser::Type_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::CastExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::CastExprContext::CastExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::CastExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastExpr(this);
}
void SQLiteParser::CastExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastExpr(this);
}

std::any SQLiteParser::CastExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCastExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RaiseExprContext ------------------------------------------------------------------

SQLiteParser::Raise_functionContext* SQLiteParser::RaiseExprContext::raise_function() {
  return getRuleContext<SQLiteParser::Raise_functionContext>(0);
}

SQLiteParser::RaiseExprContext::RaiseExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::RaiseExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaiseExpr(this);
}
void SQLiteParser::RaiseExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaiseExpr(this);
}

std::any SQLiteParser::RaiseExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRaiseExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- InExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::InExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::InExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::InExprContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::InExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::InExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::InExprContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::InExprContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::InExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::InExprContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::InExprContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::InExprContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::InExprContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::InExprContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::InExprContext::InExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::InExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInExpr(this);
}
void SQLiteParser::InExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInExpr(this);
}

std::any SQLiteParser::InExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- OrExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::OrExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::OrExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::OrExprContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

SQLiteParser::OrExprContext::OrExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::OrExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrExpr(this);
}
void SQLiteParser::OrExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrExpr(this);
}

std::any SQLiteParser::OrExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MulDivModExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::MulDivModExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::MulDivModExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::MulDivModExprContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

tree::TerminalNode* SQLiteParser::MulDivModExprContext::DIV() {
  return getToken(SQLiteParser::DIV, 0);
}

tree::TerminalNode* SQLiteParser::MulDivModExprContext::MOD() {
  return getToken(SQLiteParser::MOD, 0);
}

SQLiteParser::MulDivModExprContext::MulDivModExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::MulDivModExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMulDivModExpr(this);
}
void SQLiteParser::MulDivModExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMulDivModExpr(this);
}

std::any SQLiteParser::MulDivModExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitMulDivModExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExistsExprContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::ExistsExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::ExistsExprContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::ExistsExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::ExistsExprContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::ExistsExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

SQLiteParser::ExistsExprContext::ExistsExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::ExistsExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExistsExpr(this);
}
void SQLiteParser::ExistsExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExistsExpr(this);
}

std::any SQLiteParser::ExistsExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitExistsExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ParenExprContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::ParenExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::ParenExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::ParenExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::ParenExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::ParenExprContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::ParenExprContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::ParenExprContext::ParenExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::ParenExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParenExpr(this);
}
void SQLiteParser::ParenExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParenExpr(this);
}

std::any SQLiteParser::ParenExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitParenExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BetweenExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::BetweenExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::BetweenExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::BetweenExprContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::BetweenExprContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::BetweenExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

SQLiteParser::BetweenExprContext::BetweenExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::BetweenExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBetweenExpr(this);
}
void SQLiteParser::BetweenExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBetweenExpr(this);
}

std::any SQLiteParser::BetweenExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBetweenExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BitwiseExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::BitwiseExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::BitwiseExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::BitwiseExprContext::LT2() {
  return getToken(SQLiteParser::LT2, 0);
}

tree::TerminalNode* SQLiteParser::BitwiseExprContext::GT2() {
  return getToken(SQLiteParser::GT2, 0);
}

tree::TerminalNode* SQLiteParser::BitwiseExprContext::AMP() {
  return getToken(SQLiteParser::AMP, 0);
}

tree::TerminalNode* SQLiteParser::BitwiseExprContext::PIPE() {
  return getToken(SQLiteParser::PIPE, 0);
}

SQLiteParser::BitwiseExprContext::BitwiseExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::BitwiseExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitwiseExpr(this);
}
void SQLiteParser::BitwiseExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitwiseExpr(this);
}

std::any SQLiteParser::BitwiseExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBitwiseExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- UnaryExprContext ------------------------------------------------------------------

SQLiteParser::Unary_operatorContext* SQLiteParser::UnaryExprContext::unary_operator() {
  return getRuleContext<SQLiteParser::Unary_operatorContext>(0);
}

SQLiteParser::ExprContext* SQLiteParser::UnaryExprContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::UnaryExprContext::UnaryExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::UnaryExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnaryExpr(this);
}
void SQLiteParser::UnaryExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnaryExpr(this);
}

std::any SQLiteParser::UnaryExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUnaryExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LiteralExprContext ------------------------------------------------------------------

SQLiteParser::Literal_valueContext* SQLiteParser::LiteralExprContext::literal_value() {
  return getRuleContext<SQLiteParser::Literal_valueContext>(0);
}

SQLiteParser::LiteralExprContext::LiteralExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::LiteralExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralExpr(this);
}
void SQLiteParser::LiteralExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralExpr(this);
}

std::any SQLiteParser::LiteralExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLiteralExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NullCheckExprContext ------------------------------------------------------------------

SQLiteParser::ExprContext* SQLiteParser::NullCheckExprContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::NullCheckExprContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::NullCheckExprContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::NullCheckExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::NullCheckExprContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

SQLiteParser::NullCheckExprContext::NullCheckExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::NullCheckExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullCheckExpr(this);
}
void SQLiteParser::NullCheckExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullCheckExpr(this);
}

std::any SQLiteParser::NullCheckExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitNullCheckExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- FunctionCallExprContext ------------------------------------------------------------------

SQLiteParser::Function_nameContext* SQLiteParser::FunctionCallExprContext::function_name() {
  return getRuleContext<SQLiteParser::Function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::FunctionCallExprContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::FunctionCallExprContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::FunctionCallExprContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::FunctionCallExprContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

SQLiteParser::Over_clauseContext* SQLiteParser::FunctionCallExprContext::over_clause() {
  return getRuleContext<SQLiteParser::Over_clauseContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::FunctionCallExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::FunctionCallExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::FunctionCallExprContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::FunctionCallExprContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::FunctionCallExprContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::FunctionCallExprContext::FunctionCallExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::FunctionCallExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCallExpr(this);
}
void SQLiteParser::FunctionCallExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCallExpr(this);
}

std::any SQLiteParser::FunctionCallExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFunctionCallExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- Pipe2ExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Pipe2ExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Pipe2ExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Pipe2ExprContext::PIPE2() {
  return getToken(SQLiteParser::PIPE2, 0);
}

SQLiteParser::Pipe2ExprContext::Pipe2ExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::Pipe2ExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPipe2Expr(this);
}
void SQLiteParser::Pipe2ExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPipe2Expr(this);
}

std::any SQLiteParser::Pipe2ExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPipe2Expr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LikeExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::LikeExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::LikeExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::LikeExprContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

SQLiteParser::LikeExprContext::LikeExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::LikeExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeExpr(this);
}
void SQLiteParser::LikeExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeExpr(this);
}

std::any SQLiteParser::LikeExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLikeExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BindParamExprContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::BindParamExprContext::BIND_PARAMETER() {
  return getToken(SQLiteParser::BIND_PARAMETER, 0);
}

SQLiteParser::BindParamExprContext::BindParamExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::BindParamExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBindParamExpr(this);
}
void SQLiteParser::BindParamExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBindParamExpr(this);
}

std::any SQLiteParser::BindParamExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBindParamExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CaseExprContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::CaseExprContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::CaseExprContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::CaseExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::CaseExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::CaseExprContext::WHEN_() {
  return getTokens(SQLiteParser::WHEN_);
}

tree::TerminalNode* SQLiteParser::CaseExprContext::WHEN_(size_t i) {
  return getToken(SQLiteParser::WHEN_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::CaseExprContext::THEN_() {
  return getTokens(SQLiteParser::THEN_);
}

tree::TerminalNode* SQLiteParser::CaseExprContext::THEN_(size_t i) {
  return getToken(SQLiteParser::THEN_, i);
}

tree::TerminalNode* SQLiteParser::CaseExprContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

SQLiteParser::CaseExprContext::CaseExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::CaseExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseExpr(this);
}
void SQLiteParser::CaseExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseExpr(this);
}

std::any SQLiteParser::CaseExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCaseExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- IsExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::IsExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::IsExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::IsExprContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::IsExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

SQLiteParser::IsExprContext::IsExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::IsExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsExpr(this);
}
void SQLiteParser::IsExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsExpr(this);
}

std::any SQLiteParser::IsExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIsExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EqualityExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::EqualityExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::EqualityExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::EQ() {
  return getToken(SQLiteParser::EQ, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::NOT_EQ1() {
  return getToken(SQLiteParser::NOT_EQ1, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::NOT_EQ2() {
  return getToken(SQLiteParser::NOT_EQ2, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::EqualityExprContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

SQLiteParser::EqualityExprContext::EqualityExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::EqualityExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqualityExpr(this);
}
void SQLiteParser::EqualityExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqualityExpr(this);
}

std::any SQLiteParser::EqualityExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitEqualityExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CollateExprContext ------------------------------------------------------------------

SQLiteParser::ExprContext* SQLiteParser::CollateExprContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::CollateExprContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::CollateExprContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::CollateExprContext::CollateExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::CollateExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollateExpr(this);
}
void SQLiteParser::CollateExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollateExpr(this);
}

std::any SQLiteParser::CollateExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCollateExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- CompareExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::CompareExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::CompareExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::CompareExprContext::LT() {
  return getToken(SQLiteParser::LT, 0);
}

tree::TerminalNode* SQLiteParser::CompareExprContext::LT_EQ() {
  return getToken(SQLiteParser::LT_EQ, 0);
}

tree::TerminalNode* SQLiteParser::CompareExprContext::GT() {
  return getToken(SQLiteParser::GT, 0);
}

tree::TerminalNode* SQLiteParser::CompareExprContext::GT_EQ() {
  return getToken(SQLiteParser::GT_EQ, 0);
}

SQLiteParser::CompareExprContext::CompareExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::CompareExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompareExpr(this);
}
void SQLiteParser::CompareExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompareExpr(this);
}

std::any SQLiteParser::CompareExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompareExpr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AndExprContext ------------------------------------------------------------------

std::vector<SQLiteParser::ExprContext *> SQLiteParser::AndExprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::AndExprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::AndExprContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

SQLiteParser::AndExprContext::AndExprContext(ExprContext *ctx) { copyFrom(ctx); }

void SQLiteParser::AndExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAndExpr(this);
}
void SQLiteParser::AndExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAndExpr(this);
}

std::any SQLiteParser::AndExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAndExpr(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::ExprContext* SQLiteParser::expr() {
   return expr(0);
}

SQLiteParser::ExprContext* SQLiteParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  SQLiteParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  SQLiteParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 64;
  enterRecursionRule(_localctx, 64, SQLiteParser::RuleExpr, precedence);

    size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(964);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<LiteralExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(877);
      literal_value();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<BindParamExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(878);
      match(SQLiteParser::BIND_PARAMETER);
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<QualifiedColunExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(887);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
      case 1: {
        setState(882);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
        case 1: {
          setState(879);
          schema_name();
          setState(880);
          match(SQLiteParser::DOT);
          break;
        }

        default:
          break;
        }
        setState(884);
        table_name();
        setState(885);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(889);
      column_name();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<UnaryExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(890);
      unary_operator();
      setState(891);
      expr(21);
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<FunctionCallExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(893);
      function_name();
      setState(894);
      match(SQLiteParser::OPEN_PAR);
      setState(907);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::OPEN_PAR:
        case SQLiteParser::PLUS:
        case SQLiteParser::MINUS:
        case SQLiteParser::TILDE:
        case SQLiteParser::ABORT_:
        case SQLiteParser::ACTION_:
        case SQLiteParser::ADD_:
        case SQLiteParser::AFTER_:
        case SQLiteParser::ALL_:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::AND_:
        case SQLiteParser::AS_:
        case SQLiteParser::ASC_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::AUTOINCREMENT_:
        case SQLiteParser::BEFORE_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::BETWEEN_:
        case SQLiteParser::BY_:
        case SQLiteParser::CASCADE_:
        case SQLiteParser::CASE_:
        case SQLiteParser::CAST_:
        case SQLiteParser::CHECK_:
        case SQLiteParser::COLLATE_:
        case SQLiteParser::COLUMN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CONFLICT_:
        case SQLiteParser::CONSTRAINT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::CURRENT_DATE_:
        case SQLiteParser::CURRENT_TIME_:
        case SQLiteParser::CURRENT_TIMESTAMP_:
        case SQLiteParser::DATABASE_:
        case SQLiteParser::DEFAULT_:
        case SQLiteParser::DEFERRABLE_:
        case SQLiteParser::DEFERRED_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DESC_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DISTINCT_:
        case SQLiteParser::DROP_:
        case SQLiteParser::EACH_:
        case SQLiteParser::ELSE_:
        case SQLiteParser::END_:
        case SQLiteParser::ESCAPE_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXCLUSIVE_:
        case SQLiteParser::EXISTS_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::FAIL_:
        case SQLiteParser::FOR_:
        case SQLiteParser::FOREIGN_:
        case SQLiteParser::FROM_:
        case SQLiteParser::FULL_:
        case SQLiteParser::GLOB_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::HAVING_:
        case SQLiteParser::IF_:
        case SQLiteParser::IGNORE_:
        case SQLiteParser::IMMEDIATE_:
        case SQLiteParser::IN_:
        case SQLiteParser::INDEX_:
        case SQLiteParser::INDEXED_:
        case SQLiteParser::INITIALLY_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INSTEAD_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::INTO_:
        case SQLiteParser::IS_:
        case SQLiteParser::ISNULL_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::KEY_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIKE_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::MATCH_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::NO_:
        case SQLiteParser::NOT_:
        case SQLiteParser::NOTNULL_:
        case SQLiteParser::NULL_:
        case SQLiteParser::OF_:
        case SQLiteParser::OFFSET_:
        case SQLiteParser::ON_:
        case SQLiteParser::OR_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::OUTER_:
        case SQLiteParser::PLAN_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::PRIMARY_:
        case SQLiteParser::QUERY_:
        case SQLiteParser::RAISE_:
        case SQLiteParser::RECURSIVE_:
        case SQLiteParser::REFERENCES_:
        case SQLiteParser::REGEXP_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::RENAME_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RESTRICT_:
        case SQLiteParser::RIGHT_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::ROW_:
        case SQLiteParser::ROWS_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::SET_:
        case SQLiteParser::TABLE_:
        case SQLiteParser::TEMP_:
        case SQLiteParser::TEMPORARY_:
        case SQLiteParser::THEN_:
        case SQLiteParser::TO_:
        case SQLiteParser::TRANSACTION_:
        case SQLiteParser::TRIGGER_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UNIQUE_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::VIEW_:
        case SQLiteParser::VIRTUAL_:
        case SQLiteParser::WHEN_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WITHOUT_:
        case SQLiteParser::FIRST_VALUE_:
        case SQLiteParser::OVER_:
        case SQLiteParser::PARTITION_:
        case SQLiteParser::RANGE_:
        case SQLiteParser::PRECEDING_:
        case SQLiteParser::UNBOUNDED_:
        case SQLiteParser::CURRENT_:
        case SQLiteParser::FOLLOWING_:
        case SQLiteParser::CUME_DIST_:
        case SQLiteParser::DENSE_RANK_:
        case SQLiteParser::LAG_:
        case SQLiteParser::LAST_VALUE_:
        case SQLiteParser::LEAD_:
        case SQLiteParser::NTH_VALUE_:
        case SQLiteParser::NTILE_:
        case SQLiteParser::PERCENT_RANK_:
        case SQLiteParser::RANK_:
        case SQLiteParser::ROW_NUMBER_:
        case SQLiteParser::GENERATED_:
        case SQLiteParser::ALWAYS_:
        case SQLiteParser::STORED_:
        case SQLiteParser::TRUE_:
        case SQLiteParser::FALSE_:
        case SQLiteParser::WINDOW_:
        case SQLiteParser::NULLS_:
        case SQLiteParser::FIRST_:
        case SQLiteParser::LAST_:
        case SQLiteParser::FILTER_:
        case SQLiteParser::GROUPS_:
        case SQLiteParser::EXCLUDE_:
        case SQLiteParser::IDENTIFIER:
        case SQLiteParser::NUMERIC_LITERAL:
        case SQLiteParser::BIND_PARAMETER:
        case SQLiteParser::STRING_LITERAL:
        case SQLiteParser::BLOB_LITERAL: {
          setState(896);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
          case 1: {
            setState(895);
            match(SQLiteParser::DISTINCT_);
            break;
          }

          default:
            break;
          }
          setState(898);
          expr(0);
          setState(903);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(899);
            match(SQLiteParser::COMMA);
            setState(900);
            expr(0);
            setState(905);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          break;
        }

        case SQLiteParser::STAR: {
          setState(906);
          match(SQLiteParser::STAR);
          break;
        }

        case SQLiteParser::CLOSE_PAR: {
          break;
        }

      default:
        break;
      }
      setState(909);
      match(SQLiteParser::CLOSE_PAR);
      setState(911);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(910);
        filter_clause();
        break;
      }

      default:
        break;
      }
      setState(914);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(913);
        over_clause();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<ParenExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(916);
      match(SQLiteParser::OPEN_PAR);
      setState(917);
      expr(0);
      setState(922);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(918);
        match(SQLiteParser::COMMA);
        setState(919);
        expr(0);
        setState(924);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(925);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<CastExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(927);
      match(SQLiteParser::CAST_);
      setState(928);
      match(SQLiteParser::OPEN_PAR);
      setState(929);
      expr(0);
      setState(930);
      match(SQLiteParser::AS_);
      setState(931);
      type_name();
      setState(932);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<ExistsExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(938);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::EXISTS_

      || _la == SQLiteParser::NOT_) {
        setState(935);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NOT_) {
          setState(934);
          match(SQLiteParser::NOT_);
        }
        setState(937);
        match(SQLiteParser::EXISTS_);
      }
      setState(940);
      match(SQLiteParser::OPEN_PAR);
      setState(941);
      select_stmt();
      setState(942);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<CaseExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(944);
      match(SQLiteParser::CASE_);
      setState(946);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
      case 1: {
        setState(945);
        expr(0);
        break;
      }

      default:
        break;
      }
      setState(953); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(948);
        match(SQLiteParser::WHEN_);
        setState(949);
        expr(0);
        setState(950);
        match(SQLiteParser::THEN_);
        setState(951);
        expr(0);
        setState(955); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == SQLiteParser::WHEN_);
      setState(959);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ELSE_) {
        setState(957);
        match(SQLiteParser::ELSE_);
        setState(958);
        expr(0);
      }
      setState(961);
      match(SQLiteParser::END_);
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<RaiseExprContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(963);
      raise_function();
      break;
    }

    default:
      break;
    }
    _ctx->stop = _input->LT(-1);
    setState(1085);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(1083);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 136, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<Pipe2ExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(966);

          if (!(precpred(_ctx, 20))) throw FailedPredicateException(this, "precpred(_ctx, 20)");
          setState(967);
          match(SQLiteParser::PIPE2);
          setState(968);
          expr(21);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<MulDivModExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(969);

          if (!(precpred(_ctx, 19))) throw FailedPredicateException(this, "precpred(_ctx, 19)");
          setState(970);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 12416) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(971);
          expr(20);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<AddSubExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(972);

          if (!(precpred(_ctx, 18))) throw FailedPredicateException(this, "precpred(_ctx, 18)");
          setState(973);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::PLUS

          || _la == SQLiteParser::MINUS)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(974);
          expr(19);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<BitwiseExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(975);

          if (!(precpred(_ctx, 17))) throw FailedPredicateException(this, "precpred(_ctx, 17)");
          setState(976);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 245760) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(977);
          expr(18);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<CompareExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(978);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(979);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & 3932160) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(980);
          expr(17);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<EqualityExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(981);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(994);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
          case 1: {
            setState(982);
            match(SQLiteParser::ASSIGN);
            break;
          }

          case 2: {
            setState(983);
            match(SQLiteParser::EQ);
            break;
          }

          case 3: {
            setState(984);
            match(SQLiteParser::NOT_EQ1);
            break;
          }

          case 4: {
            setState(985);
            match(SQLiteParser::NOT_EQ2);
            break;
          }

          case 5: {
            setState(986);
            match(SQLiteParser::IS_);
            break;
          }

          case 6: {
            setState(987);
            match(SQLiteParser::IS_);
            setState(988);
            match(SQLiteParser::NOT_);
            break;
          }

          case 7: {
            setState(989);
            match(SQLiteParser::IN_);
            break;
          }

          case 8: {
            setState(990);
            match(SQLiteParser::LIKE_);
            break;
          }

          case 9: {
            setState(991);
            match(SQLiteParser::GLOB_);
            break;
          }

          case 10: {
            setState(992);
            match(SQLiteParser::MATCH_);
            break;
          }

          case 11: {
            setState(993);
            match(SQLiteParser::REGEXP_);
            break;
          }

          default:
            break;
          }
          setState(996);
          expr(16);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<AndExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(997);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(998);
          match(SQLiteParser::AND_);
          setState(999);
          expr(15);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<OrExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1000);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(1001);
          match(SQLiteParser::OR_);
          setState(1002);
          expr(14);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<IsExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1003);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(1004);
          match(SQLiteParser::IS_);
          setState(1006);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
          case 1: {
            setState(1005);
            match(SQLiteParser::NOT_);
            break;
          }

          default:
            break;
          }
          setState(1008);
          expr(7);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<BetweenExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1009);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(1011);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1010);
            match(SQLiteParser::NOT_);
          }
          setState(1013);
          match(SQLiteParser::BETWEEN_);
          setState(1014);
          expr(0);
          setState(1015);
          match(SQLiteParser::AND_);
          setState(1016);
          expr(6);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<CollateExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1018);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(1019);
          match(SQLiteParser::COLLATE_);
          setState(1020);
          collation_name();
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<LikeExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1021);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(1023);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1022);
            match(SQLiteParser::NOT_);
          }
          setState(1025);
          _la = _input->LA(1);
          if (!(((((_la - 77) & ~ 0x3fULL) == 0) &&
            ((1ULL << (_la - 77)) & 2199028498433) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(1026);
          expr(0);
          setState(1029);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 126, _ctx)) {
          case 1: {
            setState(1027);
            match(SQLiteParser::ESCAPE_);
            setState(1028);
            expr(0);
            break;
          }

          default:
            break;
          }
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<NullCheckExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1031);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(1036);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case SQLiteParser::ISNULL_: {
              setState(1032);
              match(SQLiteParser::ISNULL_);
              break;
            }

            case SQLiteParser::NOTNULL_: {
              setState(1033);
              match(SQLiteParser::NOTNULL_);
              break;
            }

            case SQLiteParser::NOT_: {
              setState(1034);
              match(SQLiteParser::NOT_);
              setState(1035);
              match(SQLiteParser::NULL_);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<InExprContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(1038);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(1040);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::NOT_) {
            setState(1039);
            match(SQLiteParser::NOT_);
          }
          setState(1042);
          match(SQLiteParser::IN_);
          setState(1081);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 135, _ctx)) {
          case 1: {
            setState(1043);
            match(SQLiteParser::OPEN_PAR);
            setState(1053);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
            case 1: {
              setState(1044);
              select_stmt();
              break;
            }

            case 2: {
              setState(1045);
              expr(0);
              setState(1050);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(1046);
                match(SQLiteParser::COMMA);
                setState(1047);
                expr(0);
                setState(1052);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
              break;
            }

            default:
              break;
            }
            setState(1055);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          case 2: {
            setState(1059);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 131, _ctx)) {
            case 1: {
              setState(1056);
              schema_name();
              setState(1057);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(1061);
            table_name();
            break;
          }

          case 3: {
            setState(1065);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
            case 1: {
              setState(1062);
              schema_name();
              setState(1063);
              match(SQLiteParser::DOT);
              break;
            }

            default:
              break;
            }
            setState(1067);
            table_function_name();
            setState(1068);
            match(SQLiteParser::OPEN_PAR);
            setState(1077);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if ((((_la & ~ 0x3fULL) == 0) &&
              ((1ULL << _la) & -33552632) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
              ((1ULL << (_la - 128)) & 4476578029606273023) != 0)) {
              setState(1069);
              expr(0);
              setState(1074);
              _errHandler->sync(this);
              _la = _input->LA(1);
              while (_la == SQLiteParser::COMMA) {
                setState(1070);
                match(SQLiteParser::COMMA);
                setState(1071);
                expr(0);
                setState(1076);
                _errHandler->sync(this);
                _la = _input->LA(1);
              }
            }
            setState(1079);
            match(SQLiteParser::CLOSE_PAR);
            break;
          }

          default:
            break;
          }
          break;
        }

        default:
          break;
        } 
      }
      setState(1087);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 137, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- Raise_functionContext ------------------------------------------------------------------

SQLiteParser::Raise_functionContext::Raise_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Error_messageContext* SQLiteParser::Raise_functionContext::error_message() {
  return getRuleContext<SQLiteParser::Error_messageContext>(0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Raise_functionContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}


size_t SQLiteParser::Raise_functionContext::getRuleIndex() const {
  return SQLiteParser::RuleRaise_function;
}

void SQLiteParser::Raise_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRaise_function(this);
}

void SQLiteParser::Raise_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRaise_function(this);
}


std::any SQLiteParser::Raise_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRaise_function(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Raise_functionContext* SQLiteParser::raise_function() {
  Raise_functionContext *_localctx = _tracker.createInstance<Raise_functionContext>(_ctx, getState());
  enterRule(_localctx, 66, SQLiteParser::RuleRaise_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1088);
    match(SQLiteParser::RAISE_);
    setState(1089);
    match(SQLiteParser::OPEN_PAR);
    setState(1094);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IGNORE_: {
        setState(1090);
        match(SQLiteParser::IGNORE_);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::ROLLBACK_: {
        setState(1091);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::ABORT_ || _la == SQLiteParser::FAIL_

        || _la == SQLiteParser::ROLLBACK_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1092);
        match(SQLiteParser::COMMA);
        setState(1093);
        error_message();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1096);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Literal_valueContext ------------------------------------------------------------------

SQLiteParser::Literal_valueContext::Literal_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NUMERIC_LITERAL() {
  return getToken(SQLiteParser::NUMERIC_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::BLOB_LITERAL() {
  return getToken(SQLiteParser::BLOB_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::Literal_valueContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}


size_t SQLiteParser::Literal_valueContext::getRuleIndex() const {
  return SQLiteParser::RuleLiteral_value;
}

void SQLiteParser::Literal_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral_value(this);
}

void SQLiteParser::Literal_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral_value(this);
}


std::any SQLiteParser::Literal_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLiteral_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Literal_valueContext* SQLiteParser::literal_value() {
  Literal_valueContext *_localctx = _tracker.createInstance<Literal_valueContext>(_ctx, getState());
  enterRule(_localctx, 68, SQLiteParser::RuleLiteral_value);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1098);
    _la = _input->LA(1);
    if (!(((((_la - 52) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 52)) & 4503599627370503) != 0) || ((((_la - 172) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 172)) & 212995) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Value_rowContext ------------------------------------------------------------------

SQLiteParser::Value_rowContext::Value_rowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Value_rowContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Value_rowContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Value_rowContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Value_rowContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Value_rowContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Value_rowContext::getRuleIndex() const {
  return SQLiteParser::RuleValue_row;
}

void SQLiteParser::Value_rowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValue_row(this);
}

void SQLiteParser::Value_rowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValue_row(this);
}


std::any SQLiteParser::Value_rowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValue_row(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Value_rowContext* SQLiteParser::value_row() {
  Value_rowContext *_localctx = _tracker.createInstance<Value_rowContext>(_ctx, getState());
  enterRule(_localctx, 70, SQLiteParser::RuleValue_row);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1100);
    match(SQLiteParser::OPEN_PAR);
    setState(1101);
    expr(0);
    setState(1106);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1102);
      match(SQLiteParser::COMMA);
      setState(1103);
      expr(0);
      setState(1108);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1109);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Values_clauseContext ------------------------------------------------------------------

SQLiteParser::Values_clauseContext::Values_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

std::vector<SQLiteParser::Value_rowContext *> SQLiteParser::Values_clauseContext::value_row() {
  return getRuleContexts<SQLiteParser::Value_rowContext>();
}

SQLiteParser::Value_rowContext* SQLiteParser::Values_clauseContext::value_row(size_t i) {
  return getRuleContext<SQLiteParser::Value_rowContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Values_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Values_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Values_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleValues_clause;
}

void SQLiteParser::Values_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues_clause(this);
}

void SQLiteParser::Values_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues_clause(this);
}


std::any SQLiteParser::Values_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitValues_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Values_clauseContext* SQLiteParser::values_clause() {
  Values_clauseContext *_localctx = _tracker.createInstance<Values_clauseContext>(_ctx, getState());
  enterRule(_localctx, 72, SQLiteParser::RuleValues_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1111);
    match(SQLiteParser::VALUES_);
    setState(1112);
    value_row();
    setState(1117);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1113);
      match(SQLiteParser::COMMA);
      setState(1114);
      value_row();
      setState(1119);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Insert_stmtContext ------------------------------------------------------------------

SQLiteParser::Insert_stmtContext::Insert_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Insert_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

SQLiteParser::With_clauseContext* SQLiteParser::Insert_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Insert_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::Insert_stmtContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Insert_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Insert_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Insert_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Insert_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Insert_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Insert_stmtContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::Insert_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::Insert_stmtContext::upsert_clause() {
  return getRuleContext<SQLiteParser::Upsert_clauseContext>(0);
}


size_t SQLiteParser::Insert_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleInsert_stmt;
}

void SQLiteParser::Insert_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsert_stmt(this);
}

void SQLiteParser::Insert_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsert_stmt(this);
}


std::any SQLiteParser::Insert_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInsert_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Insert_stmtContext* SQLiteParser::insert_stmt() {
  Insert_stmtContext *_localctx = _tracker.createInstance<Insert_stmtContext>(_ctx, getState());
  enterRule(_localctx, 74, SQLiteParser::RuleInsert_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1121);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1120);
      with_clause();
    }
    setState(1128);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
    case 1: {
      setState(1123);
      match(SQLiteParser::INSERT_);
      break;
    }

    case 2: {
      setState(1124);
      match(SQLiteParser::REPLACE_);
      break;
    }

    case 3: {
      setState(1125);
      match(SQLiteParser::INSERT_);
      setState(1126);
      match(SQLiteParser::OR_);
      setState(1127);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1130);
    match(SQLiteParser::INTO_);
    setState(1134);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
    case 1: {
      setState(1131);
      schema_name();
      setState(1132);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1136);
    table_name();
    setState(1139);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1137);
      match(SQLiteParser::AS_);
      setState(1138);
      table_alias();
    }
    setState(1152);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1141);
      match(SQLiteParser::OPEN_PAR);
      setState(1142);
      column_name();
      setState(1147);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1143);
        match(SQLiteParser::COMMA);
        setState(1144);
        column_name();
        setState(1149);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1150);
      match(SQLiteParser::CLOSE_PAR);
    }
    setState(1163);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WITH_: {
        setState(1156);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 147, _ctx)) {
        case 1: {
          setState(1154);
          values_clause();
          break;
        }

        case 2: {
          setState(1155);
          select_stmt();
          break;
        }

        default:
          break;
        }
        setState(1159);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ON_) {
          setState(1158);
          upsert_clause();
        }
        break;
      }

      case SQLiteParser::DEFAULT_: {
        setState(1161);
        match(SQLiteParser::DEFAULT_);
        setState(1162);
        match(SQLiteParser::VALUES_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1166);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1165);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Returning_clauseContext ------------------------------------------------------------------

SQLiteParser::Returning_clauseContext::Returning_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::RETURNING_() {
  return getToken(SQLiteParser::RETURNING_, 0);
}

std::vector<SQLiteParser::Result_columnContext *> SQLiteParser::Returning_clauseContext::result_column() {
  return getRuleContexts<SQLiteParser::Result_columnContext>();
}

SQLiteParser::Result_columnContext* SQLiteParser::Returning_clauseContext::result_column(size_t i) {
  return getRuleContext<SQLiteParser::Result_columnContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Returning_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Returning_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Returning_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleReturning_clause;
}

void SQLiteParser::Returning_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturning_clause(this);
}

void SQLiteParser::Returning_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturning_clause(this);
}


std::any SQLiteParser::Returning_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReturning_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::returning_clause() {
  Returning_clauseContext *_localctx = _tracker.createInstance<Returning_clauseContext>(_ctx, getState());
  enterRule(_localctx, 76, SQLiteParser::RuleReturning_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1168);
    match(SQLiteParser::RETURNING_);
    setState(1169);
    result_column();
    setState(1174);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1170);
      match(SQLiteParser::COMMA);
      setState(1171);
      result_column();
      setState(1176);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Upsert_clauseContext ------------------------------------------------------------------

SQLiteParser::Upsert_clauseContext::Upsert_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::DO_() {
  return getToken(SQLiteParser::DO_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::NOTHING_() {
  return getToken(SQLiteParser::NOTHING_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Indexed_columnContext *> SQLiteParser::Upsert_clauseContext::indexed_column() {
  return getRuleContexts<SQLiteParser::Indexed_columnContext>();
}

SQLiteParser::Indexed_columnContext* SQLiteParser::Upsert_clauseContext::indexed_column(size_t i) {
  return getRuleContext<SQLiteParser::Indexed_columnContext>(i);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Upsert_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Upsert_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Upsert_clauseContext::WHERE_() {
  return getTokens(SQLiteParser::WHERE_);
}

tree::TerminalNode* SQLiteParser::Upsert_clauseContext::WHERE_(size_t i) {
  return getToken(SQLiteParser::WHERE_, i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Upsert_clauseContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Upsert_clauseContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Upsert_clauseContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Upsert_clauseContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}


size_t SQLiteParser::Upsert_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleUpsert_clause;
}

void SQLiteParser::Upsert_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpsert_clause(this);
}

void SQLiteParser::Upsert_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpsert_clause(this);
}


std::any SQLiteParser::Upsert_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpsert_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Upsert_clauseContext* SQLiteParser::upsert_clause() {
  Upsert_clauseContext *_localctx = _tracker.createInstance<Upsert_clauseContext>(_ctx, getState());
  enterRule(_localctx, 78, SQLiteParser::RuleUpsert_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1177);
    match(SQLiteParser::ON_);
    setState(1178);
    match(SQLiteParser::CONFLICT_);
    setState(1193);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::OPEN_PAR) {
      setState(1179);
      match(SQLiteParser::OPEN_PAR);
      setState(1180);
      indexed_column();
      setState(1185);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1181);
        match(SQLiteParser::COMMA);
        setState(1182);
        indexed_column();
        setState(1187);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1188);
      match(SQLiteParser::CLOSE_PAR);
      setState(1191);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::WHERE_) {
        setState(1189);
        match(SQLiteParser::WHERE_);
        setState(1190);
        expr(0);
      }
    }
    setState(1195);
    match(SQLiteParser::DO_);
    setState(1222);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::NOTHING_: {
        setState(1196);
        match(SQLiteParser::NOTHING_);
        break;
      }

      case SQLiteParser::UPDATE_: {
        setState(1197);
        match(SQLiteParser::UPDATE_);
        setState(1198);
        match(SQLiteParser::SET_);

        setState(1201);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
        case 1: {
          setState(1199);
          column_name();
          break;
        }

        case 2: {
          setState(1200);
          column_name_list();
          break;
        }

        default:
          break;
        }
        setState(1203);
        match(SQLiteParser::ASSIGN);
        setState(1204);
        expr(0);
        setState(1215);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1205);
          match(SQLiteParser::COMMA);
          setState(1208);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
          case 1: {
            setState(1206);
            column_name();
            break;
          }

          case 2: {
            setState(1207);
            column_name_list();
            break;
          }

          default:
            break;
          }
          setState(1210);
          match(SQLiteParser::ASSIGN);
          setState(1211);
          expr(0);
          setState(1217);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1220);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1218);
          match(SQLiteParser::WHERE_);
          setState(1219);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_stmtContext ------------------------------------------------------------------

SQLiteParser::Pragma_stmtContext::Pragma_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::Pragma_stmtContext::pragma_name() {
  return getRuleContext<SQLiteParser::Pragma_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Pragma_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::ASSIGN() {
  return getToken(SQLiteParser::ASSIGN, 0);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::Pragma_stmtContext::pragma_value() {
  return getRuleContext<SQLiteParser::Pragma_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Pragma_stmtContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Pragma_stmtContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_stmt;
}

void SQLiteParser::Pragma_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_stmt(this);
}

void SQLiteParser::Pragma_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_stmt(this);
}


std::any SQLiteParser::Pragma_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_stmtContext* SQLiteParser::pragma_stmt() {
  Pragma_stmtContext *_localctx = _tracker.createInstance<Pragma_stmtContext>(_ctx, getState());
  enterRule(_localctx, 80, SQLiteParser::RulePragma_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1224);
    match(SQLiteParser::PRAGMA_);
    setState(1228);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
    case 1: {
      setState(1225);
      schema_name();
      setState(1226);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1230);
    pragma_name();
    setState(1237);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ASSIGN: {
        setState(1231);
        match(SQLiteParser::ASSIGN);
        setState(1232);
        pragma_value();
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        setState(1233);
        match(SQLiteParser::OPEN_PAR);
        setState(1234);
        pragma_value();
        setState(1235);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DROP_:
      case SQLiteParser::END_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WITH_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_valueContext ------------------------------------------------------------------

SQLiteParser::Pragma_valueContext::Pragma_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Signed_numberContext* SQLiteParser::Pragma_valueContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

SQLiteParser::NameContext* SQLiteParser::Pragma_valueContext::name() {
  return getRuleContext<SQLiteParser::NameContext>(0);
}

tree::TerminalNode* SQLiteParser::Pragma_valueContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Pragma_valueContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_value;
}

void SQLiteParser::Pragma_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_value(this);
}

void SQLiteParser::Pragma_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_value(this);
}


std::any SQLiteParser::Pragma_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_valueContext* SQLiteParser::pragma_value() {
  Pragma_valueContext *_localctx = _tracker.createInstance<Pragma_valueContext>(_ctx, getState());
  enterRule(_localctx, 82, SQLiteParser::RulePragma_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1242);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1239);
      signed_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1240);
      name();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1241);
      match(SQLiteParser::STRING_LITERAL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Reindex_stmtContext ------------------------------------------------------------------

SQLiteParser::Reindex_stmtContext::Reindex_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Reindex_stmtContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Reindex_stmtContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Reindex_stmtContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Reindex_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Reindex_stmtContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}


size_t SQLiteParser::Reindex_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleReindex_stmt;
}

void SQLiteParser::Reindex_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReindex_stmt(this);
}

void SQLiteParser::Reindex_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReindex_stmt(this);
}


std::any SQLiteParser::Reindex_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitReindex_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Reindex_stmtContext* SQLiteParser::reindex_stmt() {
  Reindex_stmtContext *_localctx = _tracker.createInstance<Reindex_stmtContext>(_ctx, getState());
  enterRule(_localctx, 84, SQLiteParser::RuleReindex_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1244);
    match(SQLiteParser::REINDEX_);
    setState(1255);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(1245);
      collation_name();
      break;
    }

    case 2: {
      setState(1249);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
      case 1: {
        setState(1246);
        schema_name();
        setState(1247);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1253);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
      case 1: {
        setState(1251);
        table_name();
        break;
      }

      case 2: {
        setState(1252);
        index_name();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_stmtContext ------------------------------------------------------------------

SQLiteParser::Select_stmtContext::Select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

std::vector<SQLiteParser::Compound_operatorContext *> SQLiteParser::Select_stmtContext::compound_operator() {
  return getRuleContexts<SQLiteParser::Compound_operatorContext>();
}

SQLiteParser::Compound_operatorContext* SQLiteParser::Select_stmtContext::compound_operator(size_t i) {
  return getRuleContext<SQLiteParser::Compound_operatorContext>(i);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}


size_t SQLiteParser::Select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_stmt;
}

void SQLiteParser::Select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_stmt(this);
}

void SQLiteParser::Select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_stmt(this);
}


std::any SQLiteParser::Select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_stmtContext* SQLiteParser::select_stmt() {
  Select_stmtContext *_localctx = _tracker.createInstance<Select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 86, SQLiteParser::RuleSelect_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1258);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1257);
      common_table_stmt();
    }
    setState(1260);
    select_core();
    setState(1266);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1261);
        compound_operator();
        setState(1262);
        select_core(); 
      }
      setState(1268);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx);
    }
    setState(1270);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1269);
      order_by_stmt();
    }
    setState(1273);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1272);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_clauseContext ------------------------------------------------------------------

SQLiteParser::Join_clauseContext::Join_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Join_clauseContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Join_clauseContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

std::vector<SQLiteParser::Join_operatorContext *> SQLiteParser::Join_clauseContext::join_operator() {
  return getRuleContexts<SQLiteParser::Join_operatorContext>();
}

SQLiteParser::Join_operatorContext* SQLiteParser::Join_clauseContext::join_operator(size_t i) {
  return getRuleContext<SQLiteParser::Join_operatorContext>(i);
}

std::vector<SQLiteParser::Join_constraintContext *> SQLiteParser::Join_clauseContext::join_constraint() {
  return getRuleContexts<SQLiteParser::Join_constraintContext>();
}

SQLiteParser::Join_constraintContext* SQLiteParser::Join_clauseContext::join_constraint(size_t i) {
  return getRuleContext<SQLiteParser::Join_constraintContext>(i);
}


size_t SQLiteParser::Join_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_clause;
}

void SQLiteParser::Join_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_clause(this);
}

void SQLiteParser::Join_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_clause(this);
}


std::any SQLiteParser::Join_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_clauseContext* SQLiteParser::join_clause() {
  Join_clauseContext *_localctx = _tracker.createInstance<Join_clauseContext>(_ctx, getState());
  enterRule(_localctx, 88, SQLiteParser::RuleJoin_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1275);
    table_or_subquery();
    setState(1283);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA

    || _la == SQLiteParser::CROSS_ || ((((_la - 87) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 87)) & 8833) != 0)) {
      setState(1276);
      join_operator();
      setState(1277);
      table_or_subquery();
      setState(1279);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
      case 1: {
        setState(1278);
        join_constraint();
        break;
      }

      default:
        break;
      }
      setState(1285);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Select_coreContext ------------------------------------------------------------------

SQLiteParser::Select_coreContext::Select_coreContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Select_coreContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

std::vector<SQLiteParser::Result_columnContext *> SQLiteParser::Select_coreContext::result_column() {
  return getRuleContexts<SQLiteParser::Result_columnContext>();
}

SQLiteParser::Result_columnContext* SQLiteParser::Select_coreContext::result_column(size_t i) {
  return getRuleContext<SQLiteParser::Result_columnContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

std::vector<SQLiteParser::Window_nameContext *> SQLiteParser::Select_coreContext::window_name() {
  return getRuleContexts<SQLiteParser::Window_nameContext>();
}

SQLiteParser::Window_nameContext* SQLiteParser::Select_coreContext::window_name(size_t i) {
  return getRuleContext<SQLiteParser::Window_nameContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Select_coreContext::AS_() {
  return getTokens(SQLiteParser::AS_);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::AS_(size_t i) {
  return getToken(SQLiteParser::AS_, i);
}

std::vector<SQLiteParser::Window_defnContext *> SQLiteParser::Select_coreContext::window_defn() {
  return getRuleContexts<SQLiteParser::Window_defnContext>();
}

SQLiteParser::Window_defnContext* SQLiteParser::Select_coreContext::window_defn(size_t i) {
  return getRuleContext<SQLiteParser::Window_defnContext>(i);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Select_coreContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Select_coreContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Select_coreContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Select_coreContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Select_coreContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Select_coreContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

SQLiteParser::Values_clauseContext* SQLiteParser::Select_coreContext::values_clause() {
  return getRuleContext<SQLiteParser::Values_clauseContext>(0);
}


size_t SQLiteParser::Select_coreContext::getRuleIndex() const {
  return SQLiteParser::RuleSelect_core;
}

void SQLiteParser::Select_coreContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelect_core(this);
}

void SQLiteParser::Select_coreContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelect_core(this);
}


std::any SQLiteParser::Select_coreContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSelect_core(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Select_coreContext* SQLiteParser::select_core() {
  Select_coreContext *_localctx = _tracker.createInstance<Select_coreContext>(_ctx, getState());
  enterRule(_localctx, 90, SQLiteParser::RuleSelect_core);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1349);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::SELECT_: {
        enterOuterAlt(_localctx, 1);
        setState(1286);
        match(SQLiteParser::SELECT_);
        setState(1288);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
        case 1: {
          setState(1287);
          _la = _input->LA(1);
          if (!(_la == SQLiteParser::ALL_

          || _la == SQLiteParser::DISTINCT_)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          break;
        }
        setState(1290);
        result_column();
        setState(1295);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1291);
          match(SQLiteParser::COMMA);
          setState(1292);
          result_column();
          setState(1297);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1310);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::FROM_) {
          setState(1298);
          match(SQLiteParser::FROM_);
          setState(1308);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
          case 1: {
            setState(1299);
            table_or_subquery();
            setState(1304);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == SQLiteParser::COMMA) {
              setState(1300);
              match(SQLiteParser::COMMA);
              setState(1301);
              table_or_subquery();
              setState(1306);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

          case 2: {
            setState(1307);
            join_clause();
            break;
          }

          default:
            break;
          }
        }
        setState(1314);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WHERE_) {
          setState(1312);
          match(SQLiteParser::WHERE_);
          setState(1313);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->whereExpr = expr(0);
        }
        setState(1330);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::GROUP_) {
          setState(1316);
          match(SQLiteParser::GROUP_);
          setState(1317);
          match(SQLiteParser::BY_);
          setState(1318);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
          antlrcpp::downCast<Select_coreContext *>(_localctx)->groupByExpr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
          setState(1323);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1319);
            match(SQLiteParser::COMMA);
            setState(1320);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext = expr(0);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->groupByExpr.push_back(antlrcpp::downCast<Select_coreContext *>(_localctx)->exprContext);
            setState(1325);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
          setState(1328);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::HAVING_) {
            setState(1326);
            match(SQLiteParser::HAVING_);
            setState(1327);
            antlrcpp::downCast<Select_coreContext *>(_localctx)->havingExpr = expr(0);
          }
        }
        setState(1346);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::WINDOW_) {
          setState(1332);
          match(SQLiteParser::WINDOW_);
          setState(1333);
          window_name();
          setState(1334);
          match(SQLiteParser::AS_);
          setState(1335);
          window_defn();
          setState(1343);
          _errHandler->sync(this);
          _la = _input->LA(1);
          while (_la == SQLiteParser::COMMA) {
            setState(1336);
            match(SQLiteParser::COMMA);
            setState(1337);
            window_name();
            setState(1338);
            match(SQLiteParser::AS_);
            setState(1339);
            window_defn();
            setState(1345);
            _errHandler->sync(this);
            _la = _input->LA(1);
          }
        }
        break;
      }

      case SQLiteParser::VALUES_: {
        enterOuterAlt(_localctx, 2);
        setState(1348);
        values_clause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Factored_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Factored_select_stmtContext::Factored_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Factored_select_stmtContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Factored_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleFactored_select_stmt;
}

void SQLiteParser::Factored_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactored_select_stmt(this);
}

void SQLiteParser::Factored_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactored_select_stmt(this);
}


std::any SQLiteParser::Factored_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFactored_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Factored_select_stmtContext* SQLiteParser::factored_select_stmt() {
  Factored_select_stmtContext *_localctx = _tracker.createInstance<Factored_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 92, SQLiteParser::RuleFactored_select_stmt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1351);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Simple_select_stmtContext::Simple_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_coreContext* SQLiteParser::Simple_select_stmtContext::select_core() {
  return getRuleContext<SQLiteParser::Select_coreContext>(0);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Simple_select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Simple_select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Simple_select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}


size_t SQLiteParser::Simple_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_select_stmt;
}

void SQLiteParser::Simple_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_select_stmt(this);
}

void SQLiteParser::Simple_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_select_stmt(this);
}


std::any SQLiteParser::Simple_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_select_stmtContext* SQLiteParser::simple_select_stmt() {
  Simple_select_stmtContext *_localctx = _tracker.createInstance<Simple_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 94, SQLiteParser::RuleSimple_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1354);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1353);
      common_table_stmt();
    }
    setState(1356);
    select_core();
    setState(1358);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1357);
      order_by_stmt();
    }
    setState(1361);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1360);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_select_stmtContext ------------------------------------------------------------------

SQLiteParser::Compound_select_stmtContext::Compound_select_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::Select_coreContext *> SQLiteParser::Compound_select_stmtContext::select_core() {
  return getRuleContexts<SQLiteParser::Select_coreContext>();
}

SQLiteParser::Select_coreContext* SQLiteParser::Compound_select_stmtContext::select_core(size_t i) {
  return getRuleContext<SQLiteParser::Select_coreContext>(i);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::Compound_select_stmtContext::common_table_stmt() {
  return getRuleContext<SQLiteParser::Common_table_stmtContext>(0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Compound_select_stmtContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Compound_select_stmtContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::UNION_() {
  return getTokens(SQLiteParser::UNION_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::UNION_(size_t i) {
  return getToken(SQLiteParser::UNION_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::INTERSECT_() {
  return getTokens(SQLiteParser::INTERSECT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::INTERSECT_(size_t i) {
  return getToken(SQLiteParser::INTERSECT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::EXCEPT_() {
  return getTokens(SQLiteParser::EXCEPT_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::EXCEPT_(size_t i) {
  return getToken(SQLiteParser::EXCEPT_, i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Compound_select_stmtContext::ALL_() {
  return getTokens(SQLiteParser::ALL_);
}

tree::TerminalNode* SQLiteParser::Compound_select_stmtContext::ALL_(size_t i) {
  return getToken(SQLiteParser::ALL_, i);
}


size_t SQLiteParser::Compound_select_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_select_stmt;
}

void SQLiteParser::Compound_select_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_select_stmt(this);
}

void SQLiteParser::Compound_select_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_select_stmt(this);
}


std::any SQLiteParser::Compound_select_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_select_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_select_stmtContext* SQLiteParser::compound_select_stmt() {
  Compound_select_stmtContext *_localctx = _tracker.createInstance<Compound_select_stmtContext>(_ctx, getState());
  enterRule(_localctx, 96, SQLiteParser::RuleCompound_select_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1364);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1363);
      common_table_stmt();
    }
    setState(1366);
    select_core();
    setState(1376); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1373);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::UNION_: {
          setState(1367);
          match(SQLiteParser::UNION_);
          setState(1369);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == SQLiteParser::ALL_) {
            setState(1368);
            match(SQLiteParser::ALL_);
          }
          break;
        }

        case SQLiteParser::INTERSECT_: {
          setState(1371);
          match(SQLiteParser::INTERSECT_);
          break;
        }

        case SQLiteParser::EXCEPT_: {
          setState(1372);
          match(SQLiteParser::EXCEPT_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(1375);
      select_core();
      setState(1378); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == SQLiteParser::EXCEPT_

    || _la == SQLiteParser::INTERSECT_ || _la == SQLiteParser::UNION_);
    setState(1381);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ORDER_) {
      setState(1380);
      order_by_stmt();
    }
    setState(1384);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_) {
      setState(1383);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_subqueryContext ------------------------------------------------------------------

SQLiteParser::Table_or_subqueryContext::Table_or_subqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t SQLiteParser::Table_or_subqueryContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_subquery;
}

void SQLiteParser::Table_or_subqueryContext::copyFrom(Table_or_subqueryContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubqueryContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::SubqueryContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Select_stmtContext* SQLiteParser::SubqueryContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::SubqueryContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::SubqueryContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::SubqueryContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::SubqueryContext::SubqueryContext(Table_or_subqueryContext *ctx) { copyFrom(ctx); }

void SQLiteParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}
void SQLiteParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

std::any SQLiteParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableFunctionContext ------------------------------------------------------------------

SQLiteParser::Table_function_nameContext* SQLiteParser::TableFunctionContext::table_function_name() {
  return getRuleContext<SQLiteParser::Table_function_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::TableFunctionContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::TableFunctionContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::TableFunctionContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::TableFunctionContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::TableFunctionContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::TableFunctionContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::TableFunctionContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::TableFunctionContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::Table_aliasContext* SQLiteParser::TableFunctionContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::TableFunctionContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::TableFunctionContext::TableFunctionContext(Table_or_subqueryContext *ctx) { copyFrom(ctx); }

void SQLiteParser::TableFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFunction(this);
}
void SQLiteParser::TableFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFunction(this);
}

std::any SQLiteParser::TableFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTableFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableAliasIndexContext ------------------------------------------------------------------

SQLiteParser::Table_nameContext* SQLiteParser::TableAliasIndexContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::TableAliasIndexContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::TableAliasIndexContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::Table_aliasContext* SQLiteParser::TableAliasIndexContext::table_alias() {
  return getRuleContext<SQLiteParser::Table_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::TableAliasIndexContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::TableAliasIndexContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::TableAliasIndexContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::TableAliasIndexContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::TableAliasIndexContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::TableAliasIndexContext::TableAliasIndexContext(Table_or_subqueryContext *ctx) { copyFrom(ctx); }

void SQLiteParser::TableAliasIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAliasIndex(this);
}
void SQLiteParser::TableAliasIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAliasIndex(this);
}

std::any SQLiteParser::TableAliasIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTableAliasIndex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TableOrJoinContext ------------------------------------------------------------------

tree::TerminalNode* SQLiteParser::TableOrJoinContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::TableOrJoinContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::TableOrJoinContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::TableOrJoinContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::TableOrJoinContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::TableOrJoinContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::TableOrJoinContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

SQLiteParser::TableOrJoinContext::TableOrJoinContext(Table_or_subqueryContext *ctx) { copyFrom(ctx); }

void SQLiteParser::TableOrJoinContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableOrJoin(this);
}
void SQLiteParser::TableOrJoinContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableOrJoin(this);
}

std::any SQLiteParser::TableOrJoinContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTableOrJoin(this);
  else
    return visitor->visitChildren(this);
}
SQLiteParser::Table_or_subqueryContext* SQLiteParser::table_or_subquery() {
  Table_or_subqueryContext *_localctx = _tracker.createInstance<Table_or_subqueryContext>(_ctx, getState());
  enterRule(_localctx, 98, SQLiteParser::RuleTable_or_subquery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1450);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SQLiteParser::TableAliasIndexContext>(_localctx);
      enterOuterAlt(_localctx, 1);
      setState(1389);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
      case 1: {
        setState(1386);
        schema_name();
        setState(1387);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1391);
      table_name();
      setState(1396);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
      case 1: {
        setState(1393);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
        case 1: {
          setState(1392);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1395);
        table_alias();
        break;
      }

      default:
        break;
      }
      setState(1403);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::INDEXED_: {
          setState(1398);
          match(SQLiteParser::INDEXED_);
          setState(1399);
          match(SQLiteParser::BY_);
          setState(1400);
          index_name();
          break;
        }

        case SQLiteParser::NOT_: {
          setState(1401);
          match(SQLiteParser::NOT_);
          setState(1402);
          match(SQLiteParser::INDEXED_);
          break;
        }

        case SQLiteParser::EOF:
        case SQLiteParser::SCOL:
        case SQLiteParser::CLOSE_PAR:
        case SQLiteParser::COMMA:
        case SQLiteParser::ALTER_:
        case SQLiteParser::ANALYZE_:
        case SQLiteParser::ATTACH_:
        case SQLiteParser::BEGIN_:
        case SQLiteParser::COMMIT_:
        case SQLiteParser::CREATE_:
        case SQLiteParser::CROSS_:
        case SQLiteParser::DELETE_:
        case SQLiteParser::DETACH_:
        case SQLiteParser::DROP_:
        case SQLiteParser::END_:
        case SQLiteParser::EXCEPT_:
        case SQLiteParser::EXPLAIN_:
        case SQLiteParser::GROUP_:
        case SQLiteParser::INNER_:
        case SQLiteParser::INSERT_:
        case SQLiteParser::INTERSECT_:
        case SQLiteParser::JOIN_:
        case SQLiteParser::LEFT_:
        case SQLiteParser::LIMIT_:
        case SQLiteParser::NATURAL_:
        case SQLiteParser::ON_:
        case SQLiteParser::ORDER_:
        case SQLiteParser::PRAGMA_:
        case SQLiteParser::REINDEX_:
        case SQLiteParser::RELEASE_:
        case SQLiteParser::REPLACE_:
        case SQLiteParser::RETURNING_:
        case SQLiteParser::ROLLBACK_:
        case SQLiteParser::SAVEPOINT_:
        case SQLiteParser::SELECT_:
        case SQLiteParser::UNION_:
        case SQLiteParser::UPDATE_:
        case SQLiteParser::USING_:
        case SQLiteParser::VACUUM_:
        case SQLiteParser::VALUES_:
        case SQLiteParser::WHERE_:
        case SQLiteParser::WITH_:
        case SQLiteParser::WINDOW_: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SQLiteParser::TableFunctionContext>(_localctx);
      enterOuterAlt(_localctx, 2);
      setState(1408);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
      case 1: {
        setState(1405);
        schema_name();
        setState(1406);
        match(SQLiteParser::DOT);
        break;
      }

      default:
        break;
      }
      setState(1410);
      table_function_name();
      setState(1411);
      match(SQLiteParser::OPEN_PAR);
      setState(1412);
      expr(0);
      setState(1417);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1413);
        match(SQLiteParser::COMMA);
        setState(1414);
        expr(0);
        setState(1419);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(1420);
      match(SQLiteParser::CLOSE_PAR);
      setState(1425);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
      case 1: {
        setState(1422);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
        case 1: {
          setState(1421);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1424);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SQLiteParser::TableOrJoinContext>(_localctx);
      enterOuterAlt(_localctx, 3);
      setState(1427);
      match(SQLiteParser::OPEN_PAR);
      setState(1437);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
      case 1: {
        setState(1428);
        table_or_subquery();
        setState(1433);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1429);
          match(SQLiteParser::COMMA);
          setState(1430);
          table_or_subquery();
          setState(1435);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1436);
        join_clause();
        break;
      }

      default:
        break;
      }
      setState(1439);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<SQLiteParser::SubqueryContext>(_localctx);
      enterOuterAlt(_localctx, 4);
      setState(1441);
      match(SQLiteParser::OPEN_PAR);
      setState(1442);
      select_stmt();
      setState(1443);
      match(SQLiteParser::CLOSE_PAR);
      setState(1448);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 204, _ctx)) {
      case 1: {
        setState(1445);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
        case 1: {
          setState(1444);
          match(SQLiteParser::AS_);
          break;
        }

        default:
          break;
        }
        setState(1447);
        table_alias();
        break;
      }

      default:
        break;
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Result_columnContext ------------------------------------------------------------------

SQLiteParser::Result_columnContext::Result_columnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Result_columnContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Table_nameContext* SQLiteParser::Result_columnContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Result_columnContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Column_aliasContext* SQLiteParser::Result_columnContext::column_alias() {
  return getRuleContext<SQLiteParser::Column_aliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Result_columnContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}


size_t SQLiteParser::Result_columnContext::getRuleIndex() const {
  return SQLiteParser::RuleResult_column;
}

void SQLiteParser::Result_columnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResult_column(this);
}

void SQLiteParser::Result_columnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResult_column(this);
}


std::any SQLiteParser::Result_columnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitResult_column(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Result_columnContext* SQLiteParser::result_column() {
  Result_columnContext *_localctx = _tracker.createInstance<Result_columnContext>(_ctx, getState());
  enterRule(_localctx, 100, SQLiteParser::RuleResult_column);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1464);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 208, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1452);
      match(SQLiteParser::STAR);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1453);
      table_name();
      setState(1454);
      match(SQLiteParser::DOT);
      setState(1455);
      match(SQLiteParser::STAR);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1457);
      expr(0);
      setState(1462);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::AS_ || _la == SQLiteParser::IDENTIFIER

      || _la == SQLiteParser::STRING_LITERAL) {
        setState(1459);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::AS_) {
          setState(1458);
          match(SQLiteParser::AS_);
        }
        setState(1461);
        column_alias();
      }
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_operatorContext ------------------------------------------------------------------

SQLiteParser::Join_operatorContext::Join_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::Join_operatorContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}


size_t SQLiteParser::Join_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_operator;
}

void SQLiteParser::Join_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_operator(this);
}

void SQLiteParser::Join_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_operator(this);
}


std::any SQLiteParser::Join_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_operatorContext* SQLiteParser::join_operator() {
  Join_operatorContext *_localctx = _tracker.createInstance<Join_operatorContext>(_ctx, getState());
  enterRule(_localctx, 102, SQLiteParser::RuleJoin_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1479);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::COMMA: {
        enterOuterAlt(_localctx, 1);
        setState(1466);
        match(SQLiteParser::COMMA);
        break;
      }

      case SQLiteParser::CROSS_:
      case SQLiteParser::INNER_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::NATURAL_: {
        enterOuterAlt(_localctx, 2);
        setState(1468);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::NATURAL_) {
          setState(1467);
          match(SQLiteParser::NATURAL_);
        }
        setState(1476);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case SQLiteParser::LEFT_: {
            setState(1470);
            match(SQLiteParser::LEFT_);
            setState(1472);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == SQLiteParser::OUTER_) {
              setState(1471);
              match(SQLiteParser::OUTER_);
            }
            break;
          }

          case SQLiteParser::INNER_: {
            setState(1474);
            match(SQLiteParser::INNER_);
            break;
          }

          case SQLiteParser::CROSS_: {
            setState(1475);
            match(SQLiteParser::CROSS_);
            break;
          }

          case SQLiteParser::JOIN_: {
            break;
          }

        default:
          break;
        }
        setState(1478);
        match(SQLiteParser::JOIN_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Join_constraintContext ------------------------------------------------------------------

SQLiteParser::Join_constraintContext::Join_constraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Join_constraintContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Join_constraintContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Join_constraintContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Join_constraintContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Join_constraintContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Join_constraintContext::getRuleIndex() const {
  return SQLiteParser::RuleJoin_constraint;
}

void SQLiteParser::Join_constraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoin_constraint(this);
}

void SQLiteParser::Join_constraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoin_constraint(this);
}


std::any SQLiteParser::Join_constraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitJoin_constraint(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Join_constraintContext* SQLiteParser::join_constraint() {
  Join_constraintContext *_localctx = _tracker.createInstance<Join_constraintContext>(_ctx, getState());
  enterRule(_localctx, 104, SQLiteParser::RuleJoin_constraint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1495);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::ON_: {
        enterOuterAlt(_localctx, 1);
        setState(1481);
        match(SQLiteParser::ON_);
        setState(1482);
        expr(0);
        break;
      }

      case SQLiteParser::USING_: {
        enterOuterAlt(_localctx, 2);
        setState(1483);
        match(SQLiteParser::USING_);
        setState(1484);
        match(SQLiteParser::OPEN_PAR);
        setState(1485);
        column_name();
        setState(1490);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1486);
          match(SQLiteParser::COMMA);
          setState(1487);
          column_name();
          setState(1492);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(1493);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Compound_operatorContext ------------------------------------------------------------------

SQLiteParser::Compound_operatorContext::Compound_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::Compound_operatorContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}


size_t SQLiteParser::Compound_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleCompound_operator;
}

void SQLiteParser::Compound_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompound_operator(this);
}

void SQLiteParser::Compound_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompound_operator(this);
}


std::any SQLiteParser::Compound_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCompound_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Compound_operatorContext* SQLiteParser::compound_operator() {
  Compound_operatorContext *_localctx = _tracker.createInstance<Compound_operatorContext>(_ctx, getState());
  enterRule(_localctx, 106, SQLiteParser::RuleCompound_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1503);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::UNION_: {
        enterOuterAlt(_localctx, 1);
        setState(1497);
        match(SQLiteParser::UNION_);
        setState(1499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ALL_) {
          setState(1498);
          match(SQLiteParser::ALL_);
        }
        break;
      }

      case SQLiteParser::INTERSECT_: {
        enterOuterAlt(_localctx, 2);
        setState(1501);
        match(SQLiteParser::INTERSECT_);
        break;
      }

      case SQLiteParser::EXCEPT_: {
        enterOuterAlt(_localctx, 3);
        setState(1502);
        match(SQLiteParser::EXCEPT_);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmtContext ------------------------------------------------------------------

SQLiteParser::Update_stmtContext::Update_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmtContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmtContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmtContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmtContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmtContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmtContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmtContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmtContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmtContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmtContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

std::vector<SQLiteParser::Table_or_subqueryContext *> SQLiteParser::Update_stmtContext::table_or_subquery() {
  return getRuleContexts<SQLiteParser::Table_or_subqueryContext>();
}

SQLiteParser::Table_or_subqueryContext* SQLiteParser::Update_stmtContext::table_or_subquery(size_t i) {
  return getRuleContext<SQLiteParser::Table_or_subqueryContext>(i);
}

SQLiteParser::Join_clauseContext* SQLiteParser::Update_stmtContext::join_clause() {
  return getRuleContext<SQLiteParser::Join_clauseContext>(0);
}


size_t SQLiteParser::Update_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt;
}

void SQLiteParser::Update_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt(this);
}

void SQLiteParser::Update_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt(this);
}


std::any SQLiteParser::Update_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmtContext* SQLiteParser::update_stmt() {
  Update_stmtContext *_localctx = _tracker.createInstance<Update_stmtContext>(_ctx, getState());
  enterRule(_localctx, 108, SQLiteParser::RuleUpdate_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1506);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1505);
      with_clause();
    }
    setState(1508);
    match(SQLiteParser::UPDATE_);
    setState(1511);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(1509);
      match(SQLiteParser::OR_);
      setState(1510);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1513);
    qualified_table_name();
    setState(1514);
    match(SQLiteParser::SET_);
    setState(1517);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 219, _ctx)) {
    case 1: {
      setState(1515);
      column_name();
      break;
    }

    case 2: {
      setState(1516);
      column_name_list();
      break;
    }

    default:
      break;
    }
    setState(1519);
    match(SQLiteParser::ASSIGN);
    setState(1520);
    expr(0);
    setState(1531);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1521);
      match(SQLiteParser::COMMA);
      setState(1524);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 220, _ctx)) {
      case 1: {
        setState(1522);
        column_name();
        break;
      }

      case 2: {
        setState(1523);
        column_name_list();
        break;
      }

      default:
        break;
      }
      setState(1526);
      match(SQLiteParser::ASSIGN);
      setState(1527);
      expr(0);
      setState(1533);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FROM_) {
      setState(1534);
      match(SQLiteParser::FROM_);
      setState(1544);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx)) {
      case 1: {
        setState(1535);
        table_or_subquery();
        setState(1540);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1536);
          match(SQLiteParser::COMMA);
          setState(1537);
          table_or_subquery();
          setState(1542);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(1543);
        join_clause();
        break;
      }

      default:
        break;
      }
    }
    setState(1550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1548);
      match(SQLiteParser::WHERE_);
      setState(1549);
      expr(0);
    }
    setState(1553);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1552);
      returning_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_name_listContext ------------------------------------------------------------------

SQLiteParser::Column_name_listContext::Column_name_listContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Column_name_listContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Column_name_listContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Column_name_listContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Column_name_listContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Column_name_listContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name_list;
}

void SQLiteParser::Column_name_listContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name_list(this);
}

void SQLiteParser::Column_name_listContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name_list(this);
}


std::any SQLiteParser::Column_name_listContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name_list(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_name_listContext* SQLiteParser::column_name_list() {
  Column_name_listContext *_localctx = _tracker.createInstance<Column_name_listContext>(_ctx, getState());
  enterRule(_localctx, 110, SQLiteParser::RuleColumn_name_list);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1555);
    match(SQLiteParser::OPEN_PAR);
    setState(1556);
    column_name();
    setState(1561);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1557);
      match(SQLiteParser::COMMA);
      setState(1558);
      column_name();
      setState(1563);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1564);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Update_stmt_limitedContext ------------------------------------------------------------------

SQLiteParser::Update_stmt_limitedContext::Update_stmt_limitedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::Update_stmt_limitedContext::qualified_table_name() {
  return getRuleContext<SQLiteParser::Qualified_table_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::ASSIGN() {
  return getTokens(SQLiteParser::ASSIGN);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ASSIGN(size_t i) {
  return getToken(SQLiteParser::ASSIGN, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Update_stmt_limitedContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Update_stmt_limitedContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Column_nameContext *> SQLiteParser::Update_stmt_limitedContext::column_name() {
  return getRuleContexts<SQLiteParser::Column_nameContext>();
}

SQLiteParser::Column_nameContext* SQLiteParser::Update_stmt_limitedContext::column_name(size_t i) {
  return getRuleContext<SQLiteParser::Column_nameContext>(i);
}

std::vector<SQLiteParser::Column_name_listContext *> SQLiteParser::Update_stmt_limitedContext::column_name_list() {
  return getRuleContexts<SQLiteParser::Column_name_listContext>();
}

SQLiteParser::Column_name_listContext* SQLiteParser::Update_stmt_limitedContext::column_name_list(size_t i) {
  return getRuleContext<SQLiteParser::Column_name_listContext>(i);
}

SQLiteParser::With_clauseContext* SQLiteParser::Update_stmt_limitedContext::with_clause() {
  return getRuleContext<SQLiteParser::With_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Update_stmt_limitedContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::Returning_clauseContext* SQLiteParser::Update_stmt_limitedContext::returning_clause() {
  return getRuleContext<SQLiteParser::Returning_clauseContext>(0);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::Update_stmt_limitedContext::limit_stmt() {
  return getRuleContext<SQLiteParser::Limit_stmtContext>(0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::Update_stmt_limitedContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::Update_stmt_limitedContext::order_by_stmt() {
  return getRuleContext<SQLiteParser::Order_by_stmtContext>(0);
}


size_t SQLiteParser::Update_stmt_limitedContext::getRuleIndex() const {
  return SQLiteParser::RuleUpdate_stmt_limited;
}

void SQLiteParser::Update_stmt_limitedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdate_stmt_limited(this);
}

void SQLiteParser::Update_stmt_limitedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdate_stmt_limited(this);
}


std::any SQLiteParser::Update_stmt_limitedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUpdate_stmt_limited(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Update_stmt_limitedContext* SQLiteParser::update_stmt_limited() {
  Update_stmt_limitedContext *_localctx = _tracker.createInstance<Update_stmt_limitedContext>(_ctx, getState());
  enterRule(_localctx, 112, SQLiteParser::RuleUpdate_stmt_limited);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1567);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WITH_) {
      setState(1566);
      with_clause();
    }
    setState(1569);
    match(SQLiteParser::UPDATE_);
    setState(1572);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 229, _ctx)) {
    case 1: {
      setState(1570);
      match(SQLiteParser::OR_);
      setState(1571);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::ABORT_ || ((((_la - 72) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 72)) & 19140298416325121) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    default:
      break;
    }
    setState(1574);
    qualified_table_name();
    setState(1575);
    match(SQLiteParser::SET_);
    setState(1578);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
    case 1: {
      setState(1576);
      column_name();
      break;
    }

    case 2: {
      setState(1577);
      column_name_list();
      break;
    }

    default:
      break;
    }
    setState(1580);
    match(SQLiteParser::ASSIGN);
    setState(1581);
    expr(0);
    setState(1592);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1582);
      match(SQLiteParser::COMMA);
      setState(1585);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
      case 1: {
        setState(1583);
        column_name();
        break;
      }

      case 2: {
        setState(1584);
        column_name_list();
        break;
      }

      default:
        break;
      }
      setState(1587);
      match(SQLiteParser::ASSIGN);
      setState(1588);
      expr(0);
      setState(1594);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1597);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::WHERE_) {
      setState(1595);
      match(SQLiteParser::WHERE_);
      setState(1596);
      expr(0);
    }
    setState(1600);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::RETURNING_) {
      setState(1599);
      returning_clause();
    }
    setState(1606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::LIMIT_

    || _la == SQLiteParser::ORDER_) {
      setState(1603);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(1602);
        order_by_stmt();
      }
      setState(1605);
      limit_stmt();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Qualified_table_nameContext ------------------------------------------------------------------

SQLiteParser::Qualified_table_nameContext::Qualified_table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Table_nameContext* SQLiteParser::Qualified_table_nameContext::table_name() {
  return getRuleContext<SQLiteParser::Table_nameContext>(0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Qualified_table_nameContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::DOT() {
  return getToken(SQLiteParser::DOT, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

SQLiteParser::AliasContext* SQLiteParser::Qualified_table_nameContext::alias() {
  return getRuleContext<SQLiteParser::AliasContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Index_nameContext* SQLiteParser::Qualified_table_nameContext::index_name() {
  return getRuleContext<SQLiteParser::Index_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Qualified_table_nameContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Qualified_table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleQualified_table_name;
}

void SQLiteParser::Qualified_table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualified_table_name(this);
}

void SQLiteParser::Qualified_table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualified_table_name(this);
}


std::any SQLiteParser::Qualified_table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitQualified_table_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Qualified_table_nameContext* SQLiteParser::qualified_table_name() {
  Qualified_table_nameContext *_localctx = _tracker.createInstance<Qualified_table_nameContext>(_ctx, getState());
  enterRule(_localctx, 114, SQLiteParser::RuleQualified_table_name);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1611);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
    case 1: {
      setState(1608);
      schema_name();
      setState(1609);
      match(SQLiteParser::DOT);
      break;
    }

    default:
      break;
    }
    setState(1613);
    table_name();
    setState(1616);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::AS_) {
      setState(1614);
      match(SQLiteParser::AS_);
      setState(1615);
      alias();
    }
    setState(1623);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::INDEXED_: {
        setState(1618);
        match(SQLiteParser::INDEXED_);
        setState(1619);
        match(SQLiteParser::BY_);
        setState(1620);
        index_name();
        break;
      }

      case SQLiteParser::NOT_: {
        setState(1621);
        match(SQLiteParser::NOT_);
        setState(1622);
        match(SQLiteParser::INDEXED_);
        break;
      }

      case SQLiteParser::EOF:
      case SQLiteParser::SCOL:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DROP_:
      case SQLiteParser::END_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RETURNING_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Vacuum_stmtContext ------------------------------------------------------------------

SQLiteParser::Vacuum_stmtContext::Vacuum_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

SQLiteParser::Schema_nameContext* SQLiteParser::Vacuum_stmtContext::schema_name() {
  return getRuleContext<SQLiteParser::Schema_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Vacuum_stmtContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

SQLiteParser::FilenameContext* SQLiteParser::Vacuum_stmtContext::filename() {
  return getRuleContext<SQLiteParser::FilenameContext>(0);
}


size_t SQLiteParser::Vacuum_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleVacuum_stmt;
}

void SQLiteParser::Vacuum_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVacuum_stmt(this);
}

void SQLiteParser::Vacuum_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVacuum_stmt(this);
}


std::any SQLiteParser::Vacuum_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitVacuum_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Vacuum_stmtContext* SQLiteParser::vacuum_stmt() {
  Vacuum_stmtContext *_localctx = _tracker.createInstance<Vacuum_stmtContext>(_ctx, getState());
  enterRule(_localctx, 116, SQLiteParser::RuleVacuum_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1625);
    match(SQLiteParser::VACUUM_);
    setState(1627);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      setState(1626);
      schema_name();
      break;
    }

    default:
      break;
    }
    setState(1631);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::INTO_) {
      setState(1629);
      match(SQLiteParser::INTO_);
      setState(1630);
      filename();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Filter_clauseContext ------------------------------------------------------------------

SQLiteParser::Filter_clauseContext::Filter_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

SQLiteParser::ExprContext* SQLiteParser::Filter_clauseContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Filter_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Filter_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFilter_clause;
}

void SQLiteParser::Filter_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilter_clause(this);
}

void SQLiteParser::Filter_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilter_clause(this);
}


std::any SQLiteParser::Filter_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilter_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::filter_clause() {
  Filter_clauseContext *_localctx = _tracker.createInstance<Filter_clauseContext>(_ctx, getState());
  enterRule(_localctx, 118, SQLiteParser::RuleFilter_clause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1633);
    match(SQLiteParser::FILTER_);
    setState(1634);
    match(SQLiteParser::OPEN_PAR);
    setState(1635);
    match(SQLiteParser::WHERE_);
    setState(1636);
    expr(0);
    setState(1637);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_defnContext ------------------------------------------------------------------

SQLiteParser::Window_defnContext::Window_defnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Window_defnContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_defnContext::BY_() {
  return getTokens(SQLiteParser::BY_);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::BY_(size_t i) {
  return getToken(SQLiteParser::BY_, i);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Window_defnContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Window_defnContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Window_defnContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_defnContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_defnContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

SQLiteParser::Frame_specContext* SQLiteParser::Window_defnContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_defnContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_defnContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_defnContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_defn;
}

void SQLiteParser::Window_defnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_defn(this);
}

void SQLiteParser::Window_defnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_defn(this);
}


std::any SQLiteParser::Window_defnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_defn(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_defnContext* SQLiteParser::window_defn() {
  Window_defnContext *_localctx = _tracker.createInstance<Window_defnContext>(_ctx, getState());
  enterRule(_localctx, 120, SQLiteParser::RuleWindow_defn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1639);
    match(SQLiteParser::OPEN_PAR);
    setState(1641);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
    case 1: {
      setState(1640);
      base_window_name();
      break;
    }

    default:
      break;
    }
    setState(1653);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::PARTITION_) {
      setState(1643);
      match(SQLiteParser::PARTITION_);
      setState(1644);
      match(SQLiteParser::BY_);
      setState(1645);
      expr(0);
      setState(1650);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == SQLiteParser::COMMA) {
        setState(1646);
        match(SQLiteParser::COMMA);
        setState(1647);
        expr(0);
        setState(1652);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

    setState(1655);
    match(SQLiteParser::ORDER_);
    setState(1656);
    match(SQLiteParser::BY_);
    setState(1657);
    ordering_term();
    setState(1662);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1658);
      match(SQLiteParser::COMMA);
      setState(1659);
      ordering_term();
      setState(1664);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(1666);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
      setState(1665);
      frame_spec();
    }
    setState(1668);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Over_clauseContext ------------------------------------------------------------------

SQLiteParser::Over_clauseContext::Over_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Over_clauseContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::Over_clauseContext::base_window_name() {
  return getRuleContext<SQLiteParser::Base_window_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Over_clauseContext::BY_() {
  return getTokens(SQLiteParser::BY_);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::BY_(size_t i) {
  return getToken(SQLiteParser::BY_, i);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Over_clauseContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Over_clauseContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Over_clauseContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Over_clauseContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

SQLiteParser::Frame_specContext* SQLiteParser::Over_clauseContext::frame_spec() {
  return getRuleContext<SQLiteParser::Frame_specContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Over_clauseContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Over_clauseContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Over_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleOver_clause;
}

void SQLiteParser::Over_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOver_clause(this);
}

void SQLiteParser::Over_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOver_clause(this);
}


std::any SQLiteParser::Over_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOver_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Over_clauseContext* SQLiteParser::over_clause() {
  Over_clauseContext *_localctx = _tracker.createInstance<Over_clauseContext>(_ctx, getState());
  enterRule(_localctx, 122, SQLiteParser::RuleOver_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1670);
    match(SQLiteParser::OVER_);
    setState(1704);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      setState(1671);
      window_name();
      break;
    }

    case 2: {
      setState(1672);
      match(SQLiteParser::OPEN_PAR);
      setState(1674);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
      case 1: {
        setState(1673);
        base_window_name();
        break;
      }

      default:
        break;
      }
      setState(1686);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::PARTITION_) {
        setState(1676);
        match(SQLiteParser::PARTITION_);
        setState(1677);
        match(SQLiteParser::BY_);
        setState(1678);
        expr(0);
        setState(1683);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1679);
          match(SQLiteParser::COMMA);
          setState(1680);
          expr(0);
          setState(1685);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1698);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ORDER_) {
        setState(1688);
        match(SQLiteParser::ORDER_);
        setState(1689);
        match(SQLiteParser::BY_);
        setState(1690);
        ordering_term();
        setState(1695);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1691);
          match(SQLiteParser::COMMA);
          setState(1692);
          ordering_term();
          setState(1697);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(1701);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 128) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
        setState(1700);
        frame_spec();
      }
      setState(1703);
      match(SQLiteParser::CLOSE_PAR);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_specContext ------------------------------------------------------------------

SQLiteParser::Frame_specContext::Frame_specContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Frame_clauseContext* SQLiteParser::Frame_specContext::frame_clause() {
  return getRuleContext<SQLiteParser::Frame_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::OTHERS_() {
  return getToken(SQLiteParser::OTHERS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_specContext::TIES_() {
  return getToken(SQLiteParser::TIES_, 0);
}


size_t SQLiteParser::Frame_specContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_spec;
}

void SQLiteParser::Frame_specContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_spec(this);
}

void SQLiteParser::Frame_specContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_spec(this);
}


std::any SQLiteParser::Frame_specContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_spec(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_specContext* SQLiteParser::frame_spec() {
  Frame_specContext *_localctx = _tracker.createInstance<Frame_specContext>(_ctx, getState());
  enterRule(_localctx, 124, SQLiteParser::RuleFrame_spec);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1706);
    frame_clause();
    setState(1716);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::EXCLUDE_) {
      setState(1707);
      match(SQLiteParser::EXCLUDE_);
      setState(1714);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case SQLiteParser::NO_: {
          setState(1708);
          match(SQLiteParser::NO_);
          setState(1709);
          match(SQLiteParser::OTHERS_);
          break;
        }

        case SQLiteParser::CURRENT_: {
          setState(1710);
          match(SQLiteParser::CURRENT_);
          setState(1711);
          match(SQLiteParser::ROW_);
          break;
        }

        case SQLiteParser::GROUP_: {
          setState(1712);
          match(SQLiteParser::GROUP_);
          break;
        }

        case SQLiteParser::TIES_: {
          setState(1713);
          match(SQLiteParser::TIES_);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_clauseContext ------------------------------------------------------------------

SQLiteParser::Frame_clauseContext::Frame_clauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

SQLiteParser::Frame_singleContext* SQLiteParser::Frame_clauseContext::frame_single() {
  return getRuleContext<SQLiteParser::Frame_singleContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

SQLiteParser::Frame_leftContext* SQLiteParser::Frame_clauseContext::frame_left() {
  return getRuleContext<SQLiteParser::Frame_leftContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_clauseContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

SQLiteParser::Frame_rightContext* SQLiteParser::Frame_clauseContext::frame_right() {
  return getRuleContext<SQLiteParser::Frame_rightContext>(0);
}


size_t SQLiteParser::Frame_clauseContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_clause;
}

void SQLiteParser::Frame_clauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_clause(this);
}

void SQLiteParser::Frame_clauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_clause(this);
}


std::any SQLiteParser::Frame_clauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_clause(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_clauseContext* SQLiteParser::frame_clause() {
  Frame_clauseContext *_localctx = _tracker.createInstance<Frame_clauseContext>(_ctx, getState());
  enterRule(_localctx, 126, SQLiteParser::RuleFrame_clause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1718);
    _la = _input->LA(1);
    if (!(((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 2251799880794113) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1725);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
    case 1: {
      setState(1719);
      frame_single();
      break;
    }

    case 2: {
      setState(1720);
      match(SQLiteParser::BETWEEN_);
      setState(1721);
      frame_left();
      setState(1722);
      match(SQLiteParser::AND_);
      setState(1723);
      frame_right();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Simple_function_invocationContext::Simple_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Simple_funcContext* SQLiteParser::Simple_function_invocationContext::simple_func() {
  return getRuleContext<SQLiteParser::Simple_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Simple_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Simple_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Simple_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Simple_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Simple_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_function_invocation;
}

void SQLiteParser::Simple_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_function_invocation(this);
}

void SQLiteParser::Simple_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_function_invocation(this);
}


std::any SQLiteParser::Simple_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_function_invocationContext* SQLiteParser::simple_function_invocation() {
  Simple_function_invocationContext *_localctx = _tracker.createInstance<Simple_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 128, SQLiteParser::RuleSimple_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1727);
    simple_func();
    setState(1728);
    match(SQLiteParser::OPEN_PAR);
    setState(1738);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1729);
        expr(0);
        setState(1734);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1730);
          match(SQLiteParser::COMMA);
          setState(1731);
          expr(0);
          setState(1736);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1737);
        match(SQLiteParser::STAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(1740);
    match(SQLiteParser::CLOSE_PAR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Aggregate_function_invocationContext::Aggregate_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::Aggregate_function_invocationContext::aggregate_func() {
  return getRuleContext<SQLiteParser::Aggregate_funcContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Aggregate_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Aggregate_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Aggregate_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Aggregate_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Aggregate_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Aggregate_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_function_invocation;
}

void SQLiteParser::Aggregate_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_function_invocation(this);
}

void SQLiteParser::Aggregate_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_function_invocation(this);
}


std::any SQLiteParser::Aggregate_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_function_invocationContext* SQLiteParser::aggregate_function_invocation() {
  Aggregate_function_invocationContext *_localctx = _tracker.createInstance<Aggregate_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 130, SQLiteParser::RuleAggregate_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1742);
    aggregate_func();
    setState(1743);
    match(SQLiteParser::OPEN_PAR);
    setState(1756);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1745);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 259, _ctx)) {
        case 1: {
          setState(1744);
          match(SQLiteParser::DISTINCT_);
          break;
        }

        default:
          break;
        }
        setState(1747);
        expr(0);
        setState(1752);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1748);
          match(SQLiteParser::COMMA);
          setState(1749);
          expr(0);
          setState(1754);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1755);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1758);
    match(SQLiteParser::CLOSE_PAR);
    setState(1760);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1759);
      filter_clause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_function_invocationContext ------------------------------------------------------------------

SQLiteParser::Window_function_invocationContext::Window_function_invocationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Window_functionContext* SQLiteParser::Window_function_invocationContext::window_function() {
  return getRuleContext<SQLiteParser::Window_functionContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Window_defnContext* SQLiteParser::Window_function_invocationContext::window_defn() {
  return getRuleContext<SQLiteParser::Window_defnContext>(0);
}

SQLiteParser::Window_nameContext* SQLiteParser::Window_function_invocationContext::window_name() {
  return getRuleContext<SQLiteParser::Window_nameContext>(0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Window_function_invocationContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Window_function_invocationContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::STAR() {
  return getToken(SQLiteParser::STAR, 0);
}

SQLiteParser::Filter_clauseContext* SQLiteParser::Window_function_invocationContext::filter_clause() {
  return getRuleContext<SQLiteParser::Filter_clauseContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_function_invocationContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Window_function_invocationContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Window_function_invocationContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_function_invocation;
}

void SQLiteParser::Window_function_invocationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_function_invocation(this);
}

void SQLiteParser::Window_function_invocationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_function_invocation(this);
}


std::any SQLiteParser::Window_function_invocationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_function_invocation(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_function_invocationContext* SQLiteParser::window_function_invocation() {
  Window_function_invocationContext *_localctx = _tracker.createInstance<Window_function_invocationContext>(_ctx, getState());
  enterRule(_localctx, 132, SQLiteParser::RuleWindow_function_invocation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1762);
    window_function();
    setState(1763);
    match(SQLiteParser::OPEN_PAR);
    setState(1773);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::OPEN_PAR:
      case SQLiteParser::PLUS:
      case SQLiteParser::MINUS:
      case SQLiteParser::TILDE:
      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_:
      case SQLiteParser::IDENTIFIER:
      case SQLiteParser::NUMERIC_LITERAL:
      case SQLiteParser::BIND_PARAMETER:
      case SQLiteParser::STRING_LITERAL:
      case SQLiteParser::BLOB_LITERAL: {
        setState(1764);
        expr(0);
        setState(1769);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == SQLiteParser::COMMA) {
          setState(1765);
          match(SQLiteParser::COMMA);
          setState(1766);
          expr(0);
          setState(1771);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case SQLiteParser::STAR: {
        setState(1772);
        match(SQLiteParser::STAR);
        break;
      }

      case SQLiteParser::CLOSE_PAR: {
        break;
      }

    default:
      break;
    }
    setState(1775);
    match(SQLiteParser::CLOSE_PAR);
    setState(1777);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::FILTER_) {
      setState(1776);
      filter_clause();
    }
    setState(1779);
    match(SQLiteParser::OVER_);
    setState(1782);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 266, _ctx)) {
    case 1: {
      setState(1780);
      window_defn();
      break;
    }

    case 2: {
      setState(1781);
      window_name();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Common_table_stmtContext ------------------------------------------------------------------

SQLiteParser::Common_table_stmtContext::Common_table_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

std::vector<SQLiteParser::Common_table_expressionContext *> SQLiteParser::Common_table_stmtContext::common_table_expression() {
  return getRuleContexts<SQLiteParser::Common_table_expressionContext>();
}

SQLiteParser::Common_table_expressionContext* SQLiteParser::Common_table_stmtContext::common_table_expression(size_t i) {
  return getRuleContext<SQLiteParser::Common_table_expressionContext>(i);
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Common_table_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Common_table_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Common_table_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleCommon_table_stmt;
}

void SQLiteParser::Common_table_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommon_table_stmt(this);
}

void SQLiteParser::Common_table_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommon_table_stmt(this);
}


std::any SQLiteParser::Common_table_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCommon_table_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Common_table_stmtContext* SQLiteParser::common_table_stmt() {
  Common_table_stmtContext *_localctx = _tracker.createInstance<Common_table_stmtContext>(_ctx, getState());
  enterRule(_localctx, 134, SQLiteParser::RuleCommon_table_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1784);
    match(SQLiteParser::WITH_);
    setState(1786);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 267, _ctx)) {
    case 1: {
      setState(1785);
      match(SQLiteParser::RECURSIVE_);
      break;
    }

    default:
      break;
    }
    setState(1788);
    common_table_expression();
    setState(1793);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1789);
      match(SQLiteParser::COMMA);
      setState(1790);
      common_table_expression();
      setState(1795);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_stmtContext ------------------------------------------------------------------

SQLiteParser::Order_by_stmtContext::Order_by_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::Ordering_termContext *> SQLiteParser::Order_by_stmtContext::ordering_term() {
  return getRuleContexts<SQLiteParser::Ordering_termContext>();
}

SQLiteParser::Ordering_termContext* SQLiteParser::Order_by_stmtContext::ordering_term(size_t i) {
  return getRuleContext<SQLiteParser::Ordering_termContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Order_by_stmtContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Order_by_stmtContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Order_by_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_stmt;
}

void SQLiteParser::Order_by_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_stmt(this);
}

void SQLiteParser::Order_by_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_stmt(this);
}


std::any SQLiteParser::Order_by_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_stmtContext* SQLiteParser::order_by_stmt() {
  Order_by_stmtContext *_localctx = _tracker.createInstance<Order_by_stmtContext>(_ctx, getState());
  enterRule(_localctx, 136, SQLiteParser::RuleOrder_by_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1796);
    match(SQLiteParser::ORDER_);
    setState(1797);
    match(SQLiteParser::BY_);
    setState(1798);
    ordering_term();
    setState(1803);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1799);
      match(SQLiteParser::COMMA);
      setState(1800);
      ordering_term();
      setState(1805);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Limit_stmtContext ------------------------------------------------------------------

SQLiteParser::Limit_stmtContext::Limit_stmtContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Limit_stmtContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Limit_stmtContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::Limit_stmtContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}


size_t SQLiteParser::Limit_stmtContext::getRuleIndex() const {
  return SQLiteParser::RuleLimit_stmt;
}

void SQLiteParser::Limit_stmtContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimit_stmt(this);
}

void SQLiteParser::Limit_stmtContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimit_stmt(this);
}


std::any SQLiteParser::Limit_stmtContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitLimit_stmt(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Limit_stmtContext* SQLiteParser::limit_stmt() {
  Limit_stmtContext *_localctx = _tracker.createInstance<Limit_stmtContext>(_ctx, getState());
  enterRule(_localctx, 138, SQLiteParser::RuleLimit_stmt);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1806);
    match(SQLiteParser::LIMIT_);
    setState(1807);
    expr(0);
    setState(1810);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_) {
      setState(1808);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::COMMA || _la == SQLiteParser::OFFSET_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1809);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ordering_termContext ------------------------------------------------------------------

SQLiteParser::Ordering_termContext::Ordering_termContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Ordering_termContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

SQLiteParser::Collation_nameContext* SQLiteParser::Ordering_termContext::collation_name() {
  return getRuleContext<SQLiteParser::Collation_nameContext>(0);
}

SQLiteParser::Asc_descContext* SQLiteParser::Ordering_termContext::asc_desc() {
  return getRuleContext<SQLiteParser::Asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::Ordering_termContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}


size_t SQLiteParser::Ordering_termContext::getRuleIndex() const {
  return SQLiteParser::RuleOrdering_term;
}

void SQLiteParser::Ordering_termContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrdering_term(this);
}

void SQLiteParser::Ordering_termContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrdering_term(this);
}


std::any SQLiteParser::Ordering_termContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrdering_term(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Ordering_termContext* SQLiteParser::ordering_term() {
  Ordering_termContext *_localctx = _tracker.createInstance<Ordering_termContext>(_ctx, getState());
  enterRule(_localctx, 140, SQLiteParser::RuleOrdering_term);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1812);
    expr(0);
    setState(1815);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::COLLATE_) {
      setState(1813);
      match(SQLiteParser::COLLATE_);
      setState(1814);
      collation_name();
    }
    setState(1818);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(1817);
      asc_desc();
    }
    setState(1822);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::NULLS_) {
      setState(1820);
      match(SQLiteParser::NULLS_);
      setState(1821);
      _la = _input->LA(1);
      if (!(_la == SQLiteParser::FIRST_

      || _la == SQLiteParser::LAST_)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Asc_descContext ------------------------------------------------------------------

SQLiteParser::Asc_descContext::Asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Asc_descContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::Asc_descContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}


size_t SQLiteParser::Asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleAsc_desc;
}

void SQLiteParser::Asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsc_desc(this);
}

void SQLiteParser::Asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsc_desc(this);
}


std::any SQLiteParser::Asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAsc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Asc_descContext* SQLiteParser::asc_desc() {
  Asc_descContext *_localctx = _tracker.createInstance<Asc_descContext>(_ctx, getState());
  enterRule(_localctx, 142, SQLiteParser::RuleAsc_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1824);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_leftContext ------------------------------------------------------------------

SQLiteParser::Frame_leftContext::Frame_leftContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_leftContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_leftContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_leftContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_left;
}

void SQLiteParser::Frame_leftContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_left(this);
}

void SQLiteParser::Frame_leftContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_left(this);
}


std::any SQLiteParser::Frame_leftContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_left(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_leftContext* SQLiteParser::frame_left() {
  Frame_leftContext *_localctx = _tracker.createInstance<Frame_leftContext>(_ctx, getState());
  enterRule(_localctx, 144, SQLiteParser::RuleFrame_left);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1836);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1826);
      expr(0);
      setState(1827);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1829);
      expr(0);
      setState(1830);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1832);
      match(SQLiteParser::CURRENT_);
      setState(1833);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1834);
      match(SQLiteParser::UNBOUNDED_);
      setState(1835);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_rightContext ------------------------------------------------------------------

SQLiteParser::Frame_rightContext::Frame_rightContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_rightContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_rightContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}


size_t SQLiteParser::Frame_rightContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_right;
}

void SQLiteParser::Frame_rightContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_right(this);
}

void SQLiteParser::Frame_rightContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_right(this);
}


std::any SQLiteParser::Frame_rightContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_right(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_rightContext* SQLiteParser::frame_right() {
  Frame_rightContext *_localctx = _tracker.createInstance<Frame_rightContext>(_ctx, getState());
  enterRule(_localctx, 146, SQLiteParser::RuleFrame_right);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1848);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1838);
      expr(0);
      setState(1839);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1841);
      expr(0);
      setState(1842);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1844);
      match(SQLiteParser::CURRENT_);
      setState(1845);
      match(SQLiteParser::ROW_);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1846);
      match(SQLiteParser::UNBOUNDED_);
      setState(1847);
      match(SQLiteParser::FOLLOWING_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Frame_singleContext ------------------------------------------------------------------

SQLiteParser::Frame_singleContext::Frame_singleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Frame_singleContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::Frame_singleContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}


size_t SQLiteParser::Frame_singleContext::getRuleIndex() const {
  return SQLiteParser::RuleFrame_single;
}

void SQLiteParser::Frame_singleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFrame_single(this);
}

void SQLiteParser::Frame_singleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFrame_single(this);
}


std::any SQLiteParser::Frame_singleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFrame_single(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Frame_singleContext* SQLiteParser::frame_single() {
  Frame_singleContext *_localctx = _tracker.createInstance<Frame_singleContext>(_ctx, getState());
  enterRule(_localctx, 148, SQLiteParser::RuleFrame_single);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1857);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1850);
      expr(0);
      setState(1851);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1853);
      match(SQLiteParser::UNBOUNDED_);
      setState(1854);
      match(SQLiteParser::PRECEDING_);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1855);
      match(SQLiteParser::CURRENT_);
      setState(1856);
      match(SQLiteParser::ROW_);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_functionContext ------------------------------------------------------------------

SQLiteParser::Window_functionContext::Window_functionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_functionContext::OPEN_PAR() {
  return getTokens(SQLiteParser::OPEN_PAR);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::OPEN_PAR(size_t i) {
  return getToken(SQLiteParser::OPEN_PAR, i);
}

SQLiteParser::ExprContext* SQLiteParser::Window_functionContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> SQLiteParser::Window_functionContext::CLOSE_PAR() {
  return getTokens(SQLiteParser::CLOSE_PAR);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::CLOSE_PAR(size_t i) {
  return getToken(SQLiteParser::CLOSE_PAR, i);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

SQLiteParser::Order_by_expr_asc_descContext* SQLiteParser::Window_functionContext::order_by_expr_asc_desc() {
  return getRuleContext<SQLiteParser::Order_by_expr_asc_descContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::FIRST_VALUE_() {
  return getToken(SQLiteParser::FIRST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LAST_VALUE_() {
  return getToken(SQLiteParser::LAST_VALUE_, 0);
}

SQLiteParser::Partition_byContext* SQLiteParser::Window_functionContext::partition_by() {
  return getRuleContext<SQLiteParser::Partition_byContext>(0);
}

SQLiteParser::Frame_clauseContext* SQLiteParser::Window_functionContext::frame_clause() {
  return getRuleContext<SQLiteParser::Frame_clauseContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::CUME_DIST_() {
  return getToken(SQLiteParser::CUME_DIST_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::PERCENT_RANK_() {
  return getToken(SQLiteParser::PERCENT_RANK_, 0);
}

SQLiteParser::Order_by_exprContext* SQLiteParser::Window_functionContext::order_by_expr() {
  return getRuleContext<SQLiteParser::Order_by_exprContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::DENSE_RANK_() {
  return getToken(SQLiteParser::DENSE_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::RANK_() {
  return getToken(SQLiteParser::RANK_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::ROW_NUMBER_() {
  return getToken(SQLiteParser::ROW_NUMBER_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LAG_() {
  return getToken(SQLiteParser::LAG_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::LEAD_() {
  return getToken(SQLiteParser::LEAD_, 0);
}

SQLiteParser::OffsetContext* SQLiteParser::Window_functionContext::offset() {
  return getRuleContext<SQLiteParser::OffsetContext>(0);
}

SQLiteParser::Default_valueContext* SQLiteParser::Window_functionContext::default_value() {
  return getRuleContext<SQLiteParser::Default_valueContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::NTH_VALUE_() {
  return getToken(SQLiteParser::NTH_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Window_functionContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}

tree::TerminalNode* SQLiteParser::Window_functionContext::NTILE_() {
  return getToken(SQLiteParser::NTILE_, 0);
}


size_t SQLiteParser::Window_functionContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_function;
}

void SQLiteParser::Window_functionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_function(this);
}

void SQLiteParser::Window_functionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_function(this);
}


std::any SQLiteParser::Window_functionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_function(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_functionContext* SQLiteParser::window_function() {
  Window_functionContext *_localctx = _tracker.createInstance<Window_functionContext>(_ctx, getState());
  enterRule(_localctx, 150, SQLiteParser::RuleWindow_function);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1944);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::LAST_VALUE_: {
        enterOuterAlt(_localctx, 1);
        setState(1859);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::FIRST_VALUE_

        || _la == SQLiteParser::LAST_VALUE_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1860);
        match(SQLiteParser::OPEN_PAR);
        setState(1861);
        expr(0);
        setState(1862);
        match(SQLiteParser::CLOSE_PAR);
        setState(1863);
        match(SQLiteParser::OVER_);
        setState(1864);
        match(SQLiteParser::OPEN_PAR);
        setState(1866);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1865);
          partition_by();
        }
        setState(1868);
        order_by_expr_asc_desc();
        setState(1870);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
          setState(1869);
          frame_clause();
        }
        setState(1872);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::PERCENT_RANK_: {
        enterOuterAlt(_localctx, 2);
        setState(1874);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::CUME_DIST_

        || _la == SQLiteParser::PERCENT_RANK_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1875);
        match(SQLiteParser::OPEN_PAR);
        setState(1876);
        match(SQLiteParser::CLOSE_PAR);
        setState(1877);
        match(SQLiteParser::OVER_);
        setState(1878);
        match(SQLiteParser::OPEN_PAR);
        setState(1880);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1879);
          partition_by();
        }
        setState(1883);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::ORDER_) {
          setState(1882);
          order_by_expr();
        }
        setState(1885);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_: {
        enterOuterAlt(_localctx, 3);
        setState(1886);
        _la = _input->LA(1);
        if (!(((((_la - 160) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 160)) & 385) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1887);
        match(SQLiteParser::OPEN_PAR);
        setState(1888);
        match(SQLiteParser::CLOSE_PAR);
        setState(1889);
        match(SQLiteParser::OVER_);
        setState(1890);
        match(SQLiteParser::OPEN_PAR);
        setState(1892);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1891);
          partition_by();
        }
        setState(1894);
        order_by_expr_asc_desc();
        setState(1895);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::LAG_:
      case SQLiteParser::LEAD_: {
        enterOuterAlt(_localctx, 4);
        setState(1897);
        _la = _input->LA(1);
        if (!(_la == SQLiteParser::LAG_

        || _la == SQLiteParser::LEAD_)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(1898);
        match(SQLiteParser::OPEN_PAR);
        setState(1899);
        expr(0);
        setState(1901);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
        case 1: {
          setState(1900);
          offset();
          break;
        }

        default:
          break;
        }
        setState(1904);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::COMMA) {
          setState(1903);
          default_value();
        }
        setState(1906);
        match(SQLiteParser::CLOSE_PAR);
        setState(1907);
        match(SQLiteParser::OVER_);
        setState(1908);
        match(SQLiteParser::OPEN_PAR);
        setState(1910);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1909);
          partition_by();
        }
        setState(1912);
        order_by_expr_asc_desc();
        setState(1913);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::NTH_VALUE_: {
        enterOuterAlt(_localctx, 5);
        setState(1915);
        match(SQLiteParser::NTH_VALUE_);
        setState(1916);
        match(SQLiteParser::OPEN_PAR);
        setState(1917);
        expr(0);
        setState(1918);
        match(SQLiteParser::COMMA);
        setState(1919);
        signed_number();
        setState(1920);
        match(SQLiteParser::CLOSE_PAR);
        setState(1921);
        match(SQLiteParser::OVER_);
        setState(1922);
        match(SQLiteParser::OPEN_PAR);
        setState(1924);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1923);
          partition_by();
        }
        setState(1926);
        order_by_expr_asc_desc();
        setState(1928);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 128) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 128)) & 2251799880794113) != 0)) {
          setState(1927);
          frame_clause();
        }
        setState(1930);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

      case SQLiteParser::NTILE_: {
        enterOuterAlt(_localctx, 6);
        setState(1932);
        match(SQLiteParser::NTILE_);
        setState(1933);
        match(SQLiteParser::OPEN_PAR);
        setState(1934);
        expr(0);
        setState(1935);
        match(SQLiteParser::CLOSE_PAR);
        setState(1936);
        match(SQLiteParser::OVER_);
        setState(1937);
        match(SQLiteParser::OPEN_PAR);
        setState(1939);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == SQLiteParser::PARTITION_) {
          setState(1938);
          partition_by();
        }
        setState(1941);
        order_by_expr_asc_desc();
        setState(1942);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OffsetContext ------------------------------------------------------------------

SQLiteParser::OffsetContext::OffsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::OffsetContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::OffsetContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}


size_t SQLiteParser::OffsetContext::getRuleIndex() const {
  return SQLiteParser::RuleOffset;
}

void SQLiteParser::OffsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOffset(this);
}

void SQLiteParser::OffsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOffset(this);
}


std::any SQLiteParser::OffsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOffset(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::OffsetContext* SQLiteParser::offset() {
  OffsetContext *_localctx = _tracker.createInstance<OffsetContext>(_ctx, getState());
  enterRule(_localctx, 152, SQLiteParser::RuleOffset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1946);
    match(SQLiteParser::COMMA);
    setState(1947);
    signed_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Default_valueContext ------------------------------------------------------------------

SQLiteParser::Default_valueContext::Default_valueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Default_valueContext::COMMA() {
  return getToken(SQLiteParser::COMMA, 0);
}

SQLiteParser::Signed_numberContext* SQLiteParser::Default_valueContext::signed_number() {
  return getRuleContext<SQLiteParser::Signed_numberContext>(0);
}


size_t SQLiteParser::Default_valueContext::getRuleIndex() const {
  return SQLiteParser::RuleDefault_value;
}

void SQLiteParser::Default_valueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefault_value(this);
}

void SQLiteParser::Default_valueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefault_value(this);
}


std::any SQLiteParser::Default_valueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitDefault_value(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Default_valueContext* SQLiteParser::default_value() {
  Default_valueContext *_localctx = _tracker.createInstance<Default_valueContext>(_ctx, getState());
  enterRule(_localctx, 154, SQLiteParser::RuleDefault_value);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1949);
    match(SQLiteParser::COMMA);
    setState(1950);
    signed_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Partition_byContext ------------------------------------------------------------------

SQLiteParser::Partition_byContext::Partition_byContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Partition_byContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::Partition_byContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Partition_byContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Partition_byContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}


size_t SQLiteParser::Partition_byContext::getRuleIndex() const {
  return SQLiteParser::RulePartition_by;
}

void SQLiteParser::Partition_byContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartition_by(this);
}

void SQLiteParser::Partition_byContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartition_by(this);
}


std::any SQLiteParser::Partition_byContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPartition_by(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Partition_byContext* SQLiteParser::partition_by() {
  Partition_byContext *_localctx = _tracker.createInstance<Partition_byContext>(_ctx, getState());
  enterRule(_localctx, 156, SQLiteParser::RulePartition_by);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1952);
    match(SQLiteParser::PARTITION_);
    setState(1953);
    match(SQLiteParser::BY_);
    setState(1955); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(1954);
              expr(0);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(1957); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_exprContext ------------------------------------------------------------------

SQLiteParser::Order_by_exprContext::Order_by_exprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_exprContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_exprContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Order_by_exprContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Order_by_exprContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}


size_t SQLiteParser::Order_by_exprContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_expr;
}

void SQLiteParser::Order_by_exprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expr(this);
}

void SQLiteParser::Order_by_exprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expr(this);
}


std::any SQLiteParser::Order_by_exprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_expr(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_exprContext* SQLiteParser::order_by_expr() {
  Order_by_exprContext *_localctx = _tracker.createInstance<Order_by_exprContext>(_ctx, getState());
  enterRule(_localctx, 158, SQLiteParser::RuleOrder_by_expr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1959);
    match(SQLiteParser::ORDER_);
    setState(1960);
    match(SQLiteParser::BY_);
    setState(1962); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(1961);
      expr(0);
      setState(1964); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -33552632) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 4476578029606273023) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Order_by_expr_asc_descContext ------------------------------------------------------------------

SQLiteParser::Order_by_expr_asc_descContext::Order_by_expr_asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Order_by_expr_asc_descContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::Order_by_expr_asc_descContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

SQLiteParser::Expr_asc_descContext* SQLiteParser::Order_by_expr_asc_descContext::expr_asc_desc() {
  return getRuleContext<SQLiteParser::Expr_asc_descContext>(0);
}


size_t SQLiteParser::Order_by_expr_asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleOrder_by_expr_asc_desc;
}

void SQLiteParser::Order_by_expr_asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrder_by_expr_asc_desc(this);
}

void SQLiteParser::Order_by_expr_asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrder_by_expr_asc_desc(this);
}


std::any SQLiteParser::Order_by_expr_asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitOrder_by_expr_asc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Order_by_expr_asc_descContext* SQLiteParser::order_by_expr_asc_desc() {
  Order_by_expr_asc_descContext *_localctx = _tracker.createInstance<Order_by_expr_asc_descContext>(_ctx, getState());
  enterRule(_localctx, 160, SQLiteParser::RuleOrder_by_expr_asc_desc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1966);
    match(SQLiteParser::ORDER_);
    setState(1967);
    match(SQLiteParser::BY_);
    setState(1968);
    expr_asc_desc();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Expr_asc_descContext ------------------------------------------------------------------

SQLiteParser::Expr_asc_descContext::Expr_asc_descContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<SQLiteParser::ExprContext *> SQLiteParser::Expr_asc_descContext::expr() {
  return getRuleContexts<SQLiteParser::ExprContext>();
}

SQLiteParser::ExprContext* SQLiteParser::Expr_asc_descContext::expr(size_t i) {
  return getRuleContext<SQLiteParser::ExprContext>(i);
}

std::vector<SQLiteParser::Asc_descContext *> SQLiteParser::Expr_asc_descContext::asc_desc() {
  return getRuleContexts<SQLiteParser::Asc_descContext>();
}

SQLiteParser::Asc_descContext* SQLiteParser::Expr_asc_descContext::asc_desc(size_t i) {
  return getRuleContext<SQLiteParser::Asc_descContext>(i);
}

std::vector<tree::TerminalNode *> SQLiteParser::Expr_asc_descContext::COMMA() {
  return getTokens(SQLiteParser::COMMA);
}

tree::TerminalNode* SQLiteParser::Expr_asc_descContext::COMMA(size_t i) {
  return getToken(SQLiteParser::COMMA, i);
}


size_t SQLiteParser::Expr_asc_descContext::getRuleIndex() const {
  return SQLiteParser::RuleExpr_asc_desc;
}

void SQLiteParser::Expr_asc_descContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExpr_asc_desc(this);
}

void SQLiteParser::Expr_asc_descContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExpr_asc_desc(this);
}


std::any SQLiteParser::Expr_asc_descContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitExpr_asc_desc(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Expr_asc_descContext* SQLiteParser::expr_asc_desc() {
  Expr_asc_descContext *_localctx = _tracker.createInstance<Expr_asc_descContext>(_ctx, getState());
  enterRule(_localctx, 162, SQLiteParser::RuleExpr_asc_desc);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1970);
    expr(0);
    setState(1972);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == SQLiteParser::ASC_

    || _la == SQLiteParser::DESC_) {
      setState(1971);
      asc_desc();
    }
    setState(1981);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == SQLiteParser::COMMA) {
      setState(1974);
      match(SQLiteParser::COMMA);
      setState(1975);
      expr(0);
      setState(1977);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == SQLiteParser::ASC_

      || _la == SQLiteParser::DESC_) {
        setState(1976);
        asc_desc();
      }
      setState(1983);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Initial_selectContext ------------------------------------------------------------------

SQLiteParser::Initial_selectContext::Initial_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Initial_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Initial_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleInitial_select;
}

void SQLiteParser::Initial_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitial_select(this);
}

void SQLiteParser::Initial_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitial_select(this);
}


std::any SQLiteParser::Initial_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitInitial_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Initial_selectContext* SQLiteParser::initial_select() {
  Initial_selectContext *_localctx = _tracker.createInstance<Initial_selectContext>(_ctx, getState());
  enterRule(_localctx, 164, SQLiteParser::RuleInitial_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1984);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Recursive_selectContext ------------------------------------------------------------------

SQLiteParser::Recursive_selectContext::Recursive_selectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Select_stmtContext* SQLiteParser::Recursive_selectContext::select_stmt() {
  return getRuleContext<SQLiteParser::Select_stmtContext>(0);
}


size_t SQLiteParser::Recursive_selectContext::getRuleIndex() const {
  return SQLiteParser::RuleRecursive_select;
}

void SQLiteParser::Recursive_selectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRecursive_select(this);
}

void SQLiteParser::Recursive_selectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRecursive_select(this);
}


std::any SQLiteParser::Recursive_selectContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitRecursive_select(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Recursive_selectContext* SQLiteParser::recursive_select() {
  Recursive_selectContext *_localctx = _tracker.createInstance<Recursive_selectContext>(_ctx, getState());
  enterRule(_localctx, 166, SQLiteParser::RuleRecursive_select);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1986);
    select_stmt();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Unary_operatorContext ------------------------------------------------------------------

SQLiteParser::Unary_operatorContext::Unary_operatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::MINUS() {
  return getToken(SQLiteParser::MINUS, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::PLUS() {
  return getToken(SQLiteParser::PLUS, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::TILDE() {
  return getToken(SQLiteParser::TILDE, 0);
}

tree::TerminalNode* SQLiteParser::Unary_operatorContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}


size_t SQLiteParser::Unary_operatorContext::getRuleIndex() const {
  return SQLiteParser::RuleUnary_operator;
}

void SQLiteParser::Unary_operatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnary_operator(this);
}

void SQLiteParser::Unary_operatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnary_operator(this);
}


std::any SQLiteParser::Unary_operatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitUnary_operator(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Unary_operatorContext* SQLiteParser::unary_operator() {
  Unary_operatorContext *_localctx = _tracker.createInstance<Unary_operatorContext>(_ctx, getState());
  enterRule(_localctx, 168, SQLiteParser::RuleUnary_operator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1988);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 1792) != 0) || _la == SQLiteParser::NOT_)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Error_messageContext ------------------------------------------------------------------

SQLiteParser::Error_messageContext::Error_messageContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Error_messageContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Error_messageContext::getRuleIndex() const {
  return SQLiteParser::RuleError_message;
}

void SQLiteParser::Error_messageContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterError_message(this);
}

void SQLiteParser::Error_messageContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitError_message(this);
}


std::any SQLiteParser::Error_messageContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitError_message(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Error_messageContext* SQLiteParser::error_message() {
  Error_messageContext *_localctx = _tracker.createInstance<Error_messageContext>(_ctx, getState());
  enterRule(_localctx, 170, SQLiteParser::RuleError_message);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1990);
    match(SQLiteParser::STRING_LITERAL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_argumentContext ------------------------------------------------------------------

SQLiteParser::Module_argumentContext::Module_argumentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::ExprContext* SQLiteParser::Module_argumentContext::expr() {
  return getRuleContext<SQLiteParser::ExprContext>(0);
}

SQLiteParser::Column_defContext* SQLiteParser::Module_argumentContext::column_def() {
  return getRuleContext<SQLiteParser::Column_defContext>(0);
}


size_t SQLiteParser::Module_argumentContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_argument;
}

void SQLiteParser::Module_argumentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_argument(this);
}

void SQLiteParser::Module_argumentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_argument(this);
}


std::any SQLiteParser::Module_argumentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_argument(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_argumentContext* SQLiteParser::module_argument() {
  Module_argumentContext *_localctx = _tracker.createInstance<Module_argumentContext>(_ctx, getState());
  enterRule(_localctx, 172, SQLiteParser::RuleModule_argument);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1994);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1992);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1993);
      column_def();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_aliasContext ------------------------------------------------------------------

SQLiteParser::Column_aliasContext::Column_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Column_aliasContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}

tree::TerminalNode* SQLiteParser::Column_aliasContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}


size_t SQLiteParser::Column_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_alias;
}

void SQLiteParser::Column_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_alias(this);
}

void SQLiteParser::Column_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_alias(this);
}


std::any SQLiteParser::Column_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_aliasContext* SQLiteParser::column_alias() {
  Column_aliasContext *_localctx = _tracker.createInstance<Column_aliasContext>(_ctx, getState());
  enterRule(_localctx, 174, SQLiteParser::RuleColumn_alias);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1996);
    _la = _input->LA(1);
    if (!(_la == SQLiteParser::IDENTIFIER

    || _la == SQLiteParser::STRING_LITERAL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeywordContext ------------------------------------------------------------------

SQLiteParser::KeywordContext::KeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::KeywordContext::ABORT_() {
  return getToken(SQLiteParser::ABORT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ACTION_() {
  return getToken(SQLiteParser::ACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ADD_() {
  return getToken(SQLiteParser::ADD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AFTER_() {
  return getToken(SQLiteParser::AFTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALL_() {
  return getToken(SQLiteParser::ALL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALTER_() {
  return getToken(SQLiteParser::ALTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ANALYZE_() {
  return getToken(SQLiteParser::ANALYZE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AND_() {
  return getToken(SQLiteParser::AND_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AS_() {
  return getToken(SQLiteParser::AS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ASC_() {
  return getToken(SQLiteParser::ASC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ATTACH_() {
  return getToken(SQLiteParser::ATTACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::AUTOINCREMENT_() {
  return getToken(SQLiteParser::AUTOINCREMENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEFORE_() {
  return getToken(SQLiteParser::BEFORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BEGIN_() {
  return getToken(SQLiteParser::BEGIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BETWEEN_() {
  return getToken(SQLiteParser::BETWEEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::BY_() {
  return getToken(SQLiteParser::BY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASCADE_() {
  return getToken(SQLiteParser::CASCADE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CASE_() {
  return getToken(SQLiteParser::CASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CAST_() {
  return getToken(SQLiteParser::CAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CHECK_() {
  return getToken(SQLiteParser::CHECK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLLATE_() {
  return getToken(SQLiteParser::COLLATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COLUMN_() {
  return getToken(SQLiteParser::COLUMN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::COMMIT_() {
  return getToken(SQLiteParser::COMMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONFLICT_() {
  return getToken(SQLiteParser::CONFLICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CONSTRAINT_() {
  return getToken(SQLiteParser::CONSTRAINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CREATE_() {
  return getToken(SQLiteParser::CREATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CROSS_() {
  return getToken(SQLiteParser::CROSS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_DATE_() {
  return getToken(SQLiteParser::CURRENT_DATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIME_() {
  return getToken(SQLiteParser::CURRENT_TIME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_TIMESTAMP_() {
  return getToken(SQLiteParser::CURRENT_TIMESTAMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DATABASE_() {
  return getToken(SQLiteParser::DATABASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFAULT_() {
  return getToken(SQLiteParser::DEFAULT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRABLE_() {
  return getToken(SQLiteParser::DEFERRABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DEFERRED_() {
  return getToken(SQLiteParser::DEFERRED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DELETE_() {
  return getToken(SQLiteParser::DELETE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DESC_() {
  return getToken(SQLiteParser::DESC_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DETACH_() {
  return getToken(SQLiteParser::DETACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DISTINCT_() {
  return getToken(SQLiteParser::DISTINCT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DROP_() {
  return getToken(SQLiteParser::DROP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EACH_() {
  return getToken(SQLiteParser::EACH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ELSE_() {
  return getToken(SQLiteParser::ELSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::END_() {
  return getToken(SQLiteParser::END_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ESCAPE_() {
  return getToken(SQLiteParser::ESCAPE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCEPT_() {
  return getToken(SQLiteParser::EXCEPT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUSIVE_() {
  return getToken(SQLiteParser::EXCLUSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXISTS_() {
  return getToken(SQLiteParser::EXISTS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXPLAIN_() {
  return getToken(SQLiteParser::EXPLAIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FAIL_() {
  return getToken(SQLiteParser::FAIL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOR_() {
  return getToken(SQLiteParser::FOR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOREIGN_() {
  return getToken(SQLiteParser::FOREIGN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FROM_() {
  return getToken(SQLiteParser::FROM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FULL_() {
  return getToken(SQLiteParser::FULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GLOB_() {
  return getToken(SQLiteParser::GLOB_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUP_() {
  return getToken(SQLiteParser::GROUP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::HAVING_() {
  return getToken(SQLiteParser::HAVING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IF_() {
  return getToken(SQLiteParser::IF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IGNORE_() {
  return getToken(SQLiteParser::IGNORE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IMMEDIATE_() {
  return getToken(SQLiteParser::IMMEDIATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IN_() {
  return getToken(SQLiteParser::IN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEX_() {
  return getToken(SQLiteParser::INDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INDEXED_() {
  return getToken(SQLiteParser::INDEXED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INITIALLY_() {
  return getToken(SQLiteParser::INITIALLY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INNER_() {
  return getToken(SQLiteParser::INNER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSERT_() {
  return getToken(SQLiteParser::INSERT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INSTEAD_() {
  return getToken(SQLiteParser::INSTEAD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTERSECT_() {
  return getToken(SQLiteParser::INTERSECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::INTO_() {
  return getToken(SQLiteParser::INTO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::IS_() {
  return getToken(SQLiteParser::IS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ISNULL_() {
  return getToken(SQLiteParser::ISNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::JOIN_() {
  return getToken(SQLiteParser::JOIN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::KEY_() {
  return getToken(SQLiteParser::KEY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LEFT_() {
  return getToken(SQLiteParser::LEFT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIKE_() {
  return getToken(SQLiteParser::LIKE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LIMIT_() {
  return getToken(SQLiteParser::LIMIT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::MATCH_() {
  return getToken(SQLiteParser::MATCH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NATURAL_() {
  return getToken(SQLiteParser::NATURAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NO_() {
  return getToken(SQLiteParser::NO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOT_() {
  return getToken(SQLiteParser::NOT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NOTNULL_() {
  return getToken(SQLiteParser::NOTNULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULL_() {
  return getToken(SQLiteParser::NULL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OF_() {
  return getToken(SQLiteParser::OF_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OFFSET_() {
  return getToken(SQLiteParser::OFFSET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ON_() {
  return getToken(SQLiteParser::ON_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OR_() {
  return getToken(SQLiteParser::OR_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ORDER_() {
  return getToken(SQLiteParser::ORDER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OUTER_() {
  return getToken(SQLiteParser::OUTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PLAN_() {
  return getToken(SQLiteParser::PLAN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRAGMA_() {
  return getToken(SQLiteParser::PRAGMA_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRIMARY_() {
  return getToken(SQLiteParser::PRIMARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::QUERY_() {
  return getToken(SQLiteParser::QUERY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RAISE_() {
  return getToken(SQLiteParser::RAISE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RECURSIVE_() {
  return getToken(SQLiteParser::RECURSIVE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REFERENCES_() {
  return getToken(SQLiteParser::REFERENCES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REGEXP_() {
  return getToken(SQLiteParser::REGEXP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REINDEX_() {
  return getToken(SQLiteParser::REINDEX_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RELEASE_() {
  return getToken(SQLiteParser::RELEASE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RENAME_() {
  return getToken(SQLiteParser::RENAME_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::REPLACE_() {
  return getToken(SQLiteParser::REPLACE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RESTRICT_() {
  return getToken(SQLiteParser::RESTRICT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RIGHT_() {
  return getToken(SQLiteParser::RIGHT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROLLBACK_() {
  return getToken(SQLiteParser::ROLLBACK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROW_() {
  return getToken(SQLiteParser::ROW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROWS_() {
  return getToken(SQLiteParser::ROWS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SAVEPOINT_() {
  return getToken(SQLiteParser::SAVEPOINT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SELECT_() {
  return getToken(SQLiteParser::SELECT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::SET_() {
  return getToken(SQLiteParser::SET_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TABLE_() {
  return getToken(SQLiteParser::TABLE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMP_() {
  return getToken(SQLiteParser::TEMP_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TEMPORARY_() {
  return getToken(SQLiteParser::TEMPORARY_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::THEN_() {
  return getToken(SQLiteParser::THEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TO_() {
  return getToken(SQLiteParser::TO_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRANSACTION_() {
  return getToken(SQLiteParser::TRANSACTION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRIGGER_() {
  return getToken(SQLiteParser::TRIGGER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNION_() {
  return getToken(SQLiteParser::UNION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNIQUE_() {
  return getToken(SQLiteParser::UNIQUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UPDATE_() {
  return getToken(SQLiteParser::UPDATE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::USING_() {
  return getToken(SQLiteParser::USING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VACUUM_() {
  return getToken(SQLiteParser::VACUUM_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VALUES_() {
  return getToken(SQLiteParser::VALUES_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIEW_() {
  return getToken(SQLiteParser::VIEW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::VIRTUAL_() {
  return getToken(SQLiteParser::VIRTUAL_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHEN_() {
  return getToken(SQLiteParser::WHEN_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WHERE_() {
  return getToken(SQLiteParser::WHERE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITH_() {
  return getToken(SQLiteParser::WITH_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WITHOUT_() {
  return getToken(SQLiteParser::WITHOUT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FIRST_VALUE_() {
  return getToken(SQLiteParser::FIRST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::OVER_() {
  return getToken(SQLiteParser::OVER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PARTITION_() {
  return getToken(SQLiteParser::PARTITION_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANGE_() {
  return getToken(SQLiteParser::RANGE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PRECEDING_() {
  return getToken(SQLiteParser::PRECEDING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::UNBOUNDED_() {
  return getToken(SQLiteParser::UNBOUNDED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CURRENT_() {
  return getToken(SQLiteParser::CURRENT_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FOLLOWING_() {
  return getToken(SQLiteParser::FOLLOWING_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::CUME_DIST_() {
  return getToken(SQLiteParser::CUME_DIST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::DENSE_RANK_() {
  return getToken(SQLiteParser::DENSE_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAG_() {
  return getToken(SQLiteParser::LAG_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAST_VALUE_() {
  return getToken(SQLiteParser::LAST_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LEAD_() {
  return getToken(SQLiteParser::LEAD_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NTH_VALUE_() {
  return getToken(SQLiteParser::NTH_VALUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NTILE_() {
  return getToken(SQLiteParser::NTILE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::PERCENT_RANK_() {
  return getToken(SQLiteParser::PERCENT_RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::RANK_() {
  return getToken(SQLiteParser::RANK_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ROW_NUMBER_() {
  return getToken(SQLiteParser::ROW_NUMBER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GENERATED_() {
  return getToken(SQLiteParser::GENERATED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::ALWAYS_() {
  return getToken(SQLiteParser::ALWAYS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::STORED_() {
  return getToken(SQLiteParser::STORED_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::TRUE_() {
  return getToken(SQLiteParser::TRUE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FALSE_() {
  return getToken(SQLiteParser::FALSE_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::WINDOW_() {
  return getToken(SQLiteParser::WINDOW_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::NULLS_() {
  return getToken(SQLiteParser::NULLS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FIRST_() {
  return getToken(SQLiteParser::FIRST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::LAST_() {
  return getToken(SQLiteParser::LAST_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::FILTER_() {
  return getToken(SQLiteParser::FILTER_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::GROUPS_() {
  return getToken(SQLiteParser::GROUPS_, 0);
}

tree::TerminalNode* SQLiteParser::KeywordContext::EXCLUDE_() {
  return getToken(SQLiteParser::EXCLUDE_, 0);
}


size_t SQLiteParser::KeywordContext::getRuleIndex() const {
  return SQLiteParser::RuleKeyword;
}

void SQLiteParser::KeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyword(this);
}

void SQLiteParser::KeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyword(this);
}


std::any SQLiteParser::KeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitKeyword(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::KeywordContext* SQLiteParser::keyword() {
  KeywordContext *_localctx = _tracker.createInstance<KeywordContext>(_ctx, getState());
  enterRule(_localctx, 176, SQLiteParser::RuleKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1998);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -33554432) != 0) || ((((_la - 64) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 64)) & -1152921504606846977) != 0) || ((((_la - 128) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 128)) & 9007199254740991) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameContext ------------------------------------------------------------------

SQLiteParser::NameContext::NameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::NameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::NameContext::getRuleIndex() const {
  return SQLiteParser::RuleName;
}

void SQLiteParser::NameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterName(this);
}

void SQLiteParser::NameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitName(this);
}


std::any SQLiteParser::NameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitName(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::NameContext* SQLiteParser::name() {
  NameContext *_localctx = _tracker.createInstance<NameContext>(_ctx, getState());
  enterRule(_localctx, 178, SQLiteParser::RuleName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2000);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Function_nameContext ------------------------------------------------------------------

SQLiteParser::Function_nameContext::Function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleFunction_name;
}

void SQLiteParser::Function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunction_name(this);
}

void SQLiteParser::Function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunction_name(this);
}


std::any SQLiteParser::Function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFunction_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Function_nameContext* SQLiteParser::function_name() {
  Function_nameContext *_localctx = _tracker.createInstance<Function_nameContext>(_ctx, getState());
  enterRule(_localctx, 180, SQLiteParser::RuleFunction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2002);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Schema_nameContext ------------------------------------------------------------------

SQLiteParser::Schema_nameContext::Schema_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Schema_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Schema_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSchema_name;
}

void SQLiteParser::Schema_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchema_name(this);
}

void SQLiteParser::Schema_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchema_name(this);
}


std::any SQLiteParser::Schema_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSchema_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Schema_nameContext* SQLiteParser::schema_name() {
  Schema_nameContext *_localctx = _tracker.createInstance<Schema_nameContext>(_ctx, getState());
  enterRule(_localctx, 182, SQLiteParser::RuleSchema_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2004);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_nameContext ------------------------------------------------------------------

SQLiteParser::Table_nameContext::Table_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_name;
}

void SQLiteParser::Table_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_name(this);
}

void SQLiteParser::Table_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_name(this);
}


std::any SQLiteParser::Table_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_nameContext* SQLiteParser::table_name() {
  Table_nameContext *_localctx = _tracker.createInstance<Table_nameContext>(_ctx, getState());
  enterRule(_localctx, 184, SQLiteParser::RuleTable_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2006);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_or_index_nameContext ------------------------------------------------------------------

SQLiteParser::Table_or_index_nameContext::Table_or_index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_or_index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_or_index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_or_index_name;
}

void SQLiteParser::Table_or_index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_or_index_name(this);
}

void SQLiteParser::Table_or_index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_or_index_name(this);
}


std::any SQLiteParser::Table_or_index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_or_index_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_or_index_nameContext* SQLiteParser::table_or_index_name() {
  Table_or_index_nameContext *_localctx = _tracker.createInstance<Table_or_index_nameContext>(_ctx, getState());
  enterRule(_localctx, 186, SQLiteParser::RuleTable_or_index_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2008);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Column_nameContext ------------------------------------------------------------------

SQLiteParser::Column_nameContext::Column_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Column_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Column_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleColumn_name;
}

void SQLiteParser::Column_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumn_name(this);
}

void SQLiteParser::Column_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumn_name(this);
}


std::any SQLiteParser::Column_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitColumn_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Column_nameContext* SQLiteParser::column_name() {
  Column_nameContext *_localctx = _tracker.createInstance<Column_nameContext>(_ctx, getState());
  enterRule(_localctx, 188, SQLiteParser::RuleColumn_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2010);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Collation_nameContext ------------------------------------------------------------------

SQLiteParser::Collation_nameContext::Collation_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Collation_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Collation_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleCollation_name;
}

void SQLiteParser::Collation_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollation_name(this);
}

void SQLiteParser::Collation_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollation_name(this);
}


std::any SQLiteParser::Collation_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitCollation_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Collation_nameContext* SQLiteParser::collation_name() {
  Collation_nameContext *_localctx = _tracker.createInstance<Collation_nameContext>(_ctx, getState());
  enterRule(_localctx, 190, SQLiteParser::RuleCollation_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2012);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Foreign_tableContext ------------------------------------------------------------------

SQLiteParser::Foreign_tableContext::Foreign_tableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Foreign_tableContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Foreign_tableContext::getRuleIndex() const {
  return SQLiteParser::RuleForeign_table;
}

void SQLiteParser::Foreign_tableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterForeign_table(this);
}

void SQLiteParser::Foreign_tableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitForeign_table(this);
}


std::any SQLiteParser::Foreign_tableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitForeign_table(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Foreign_tableContext* SQLiteParser::foreign_table() {
  Foreign_tableContext *_localctx = _tracker.createInstance<Foreign_tableContext>(_ctx, getState());
  enterRule(_localctx, 192, SQLiteParser::RuleForeign_table);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2014);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Index_nameContext ------------------------------------------------------------------

SQLiteParser::Index_nameContext::Index_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Index_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Index_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleIndex_name;
}

void SQLiteParser::Index_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndex_name(this);
}

void SQLiteParser::Index_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndex_name(this);
}


std::any SQLiteParser::Index_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitIndex_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Index_nameContext* SQLiteParser::index_name() {
  Index_nameContext *_localctx = _tracker.createInstance<Index_nameContext>(_ctx, getState());
  enterRule(_localctx, 194, SQLiteParser::RuleIndex_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2016);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Trigger_nameContext ------------------------------------------------------------------

SQLiteParser::Trigger_nameContext::Trigger_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Trigger_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Trigger_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTrigger_name;
}

void SQLiteParser::Trigger_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrigger_name(this);
}

void SQLiteParser::Trigger_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrigger_name(this);
}


std::any SQLiteParser::Trigger_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTrigger_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Trigger_nameContext* SQLiteParser::trigger_name() {
  Trigger_nameContext *_localctx = _tracker.createInstance<Trigger_nameContext>(_ctx, getState());
  enterRule(_localctx, 196, SQLiteParser::RuleTrigger_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2018);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- View_nameContext ------------------------------------------------------------------

SQLiteParser::View_nameContext::View_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::View_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::View_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleView_name;
}

void SQLiteParser::View_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterView_name(this);
}

void SQLiteParser::View_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitView_name(this);
}


std::any SQLiteParser::View_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitView_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::View_nameContext* SQLiteParser::view_name() {
  View_nameContext *_localctx = _tracker.createInstance<View_nameContext>(_ctx, getState());
  enterRule(_localctx, 198, SQLiteParser::RuleView_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2020);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Module_nameContext ------------------------------------------------------------------

SQLiteParser::Module_nameContext::Module_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Module_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Module_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleModule_name;
}

void SQLiteParser::Module_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterModule_name(this);
}

void SQLiteParser::Module_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitModule_name(this);
}


std::any SQLiteParser::Module_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitModule_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Module_nameContext* SQLiteParser::module_name() {
  Module_nameContext *_localctx = _tracker.createInstance<Module_nameContext>(_ctx, getState());
  enterRule(_localctx, 200, SQLiteParser::RuleModule_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Pragma_nameContext ------------------------------------------------------------------

SQLiteParser::Pragma_nameContext::Pragma_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Pragma_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Pragma_nameContext::getRuleIndex() const {
  return SQLiteParser::RulePragma_name;
}

void SQLiteParser::Pragma_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPragma_name(this);
}

void SQLiteParser::Pragma_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPragma_name(this);
}


std::any SQLiteParser::Pragma_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitPragma_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Pragma_nameContext* SQLiteParser::pragma_name() {
  Pragma_nameContext *_localctx = _tracker.createInstance<Pragma_nameContext>(_ctx, getState());
  enterRule(_localctx, 202, SQLiteParser::RulePragma_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2024);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Savepoint_nameContext ------------------------------------------------------------------

SQLiteParser::Savepoint_nameContext::Savepoint_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Savepoint_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Savepoint_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleSavepoint_name;
}

void SQLiteParser::Savepoint_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepoint_name(this);
}

void SQLiteParser::Savepoint_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepoint_name(this);
}


std::any SQLiteParser::Savepoint_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSavepoint_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Savepoint_nameContext* SQLiteParser::savepoint_name() {
  Savepoint_nameContext *_localctx = _tracker.createInstance<Savepoint_nameContext>(_ctx, getState());
  enterRule(_localctx, 204, SQLiteParser::RuleSavepoint_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2026);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_aliasContext ------------------------------------------------------------------

SQLiteParser::Table_aliasContext::Table_aliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_aliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_aliasContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_alias;
}

void SQLiteParser::Table_aliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_alias(this);
}

void SQLiteParser::Table_aliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_alias(this);
}


std::any SQLiteParser::Table_aliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_alias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_aliasContext* SQLiteParser::table_alias() {
  Table_aliasContext *_localctx = _tracker.createInstance<Table_aliasContext>(_ctx, getState());
  enterRule(_localctx, 206, SQLiteParser::RuleTable_alias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2028);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Transaction_nameContext ------------------------------------------------------------------

SQLiteParser::Transaction_nameContext::Transaction_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Transaction_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Transaction_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTransaction_name;
}

void SQLiteParser::Transaction_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransaction_name(this);
}

void SQLiteParser::Transaction_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransaction_name(this);
}


std::any SQLiteParser::Transaction_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTransaction_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Transaction_nameContext* SQLiteParser::transaction_name() {
  Transaction_nameContext *_localctx = _tracker.createInstance<Transaction_nameContext>(_ctx, getState());
  enterRule(_localctx, 208, SQLiteParser::RuleTransaction_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2030);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Window_nameContext ------------------------------------------------------------------

SQLiteParser::Window_nameContext::Window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleWindow_name;
}

void SQLiteParser::Window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindow_name(this);
}

void SQLiteParser::Window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindow_name(this);
}


std::any SQLiteParser::Window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitWindow_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Window_nameContext* SQLiteParser::window_name() {
  Window_nameContext *_localctx = _tracker.createInstance<Window_nameContext>(_ctx, getState());
  enterRule(_localctx, 210, SQLiteParser::RuleWindow_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2032);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AliasContext ------------------------------------------------------------------

SQLiteParser::AliasContext::AliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::AliasContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::AliasContext::getRuleIndex() const {
  return SQLiteParser::RuleAlias;
}

void SQLiteParser::AliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlias(this);
}

void SQLiteParser::AliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlias(this);
}


std::any SQLiteParser::AliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAlias(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::AliasContext* SQLiteParser::alias() {
  AliasContext *_localctx = _tracker.createInstance<AliasContext>(_ctx, getState());
  enterRule(_localctx, 212, SQLiteParser::RuleAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2034);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilenameContext ------------------------------------------------------------------

SQLiteParser::FilenameContext::FilenameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::FilenameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::FilenameContext::getRuleIndex() const {
  return SQLiteParser::RuleFilename;
}

void SQLiteParser::FilenameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilename(this);
}

void SQLiteParser::FilenameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilename(this);
}


std::any SQLiteParser::FilenameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitFilename(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::FilenameContext* SQLiteParser::filename() {
  FilenameContext *_localctx = _tracker.createInstance<FilenameContext>(_ctx, getState());
  enterRule(_localctx, 214, SQLiteParser::RuleFilename);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2036);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Base_window_nameContext ------------------------------------------------------------------

SQLiteParser::Base_window_nameContext::Base_window_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Base_window_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Base_window_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleBase_window_name;
}

void SQLiteParser::Base_window_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBase_window_name(this);
}

void SQLiteParser::Base_window_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBase_window_name(this);
}


std::any SQLiteParser::Base_window_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitBase_window_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Base_window_nameContext* SQLiteParser::base_window_name() {
  Base_window_nameContext *_localctx = _tracker.createInstance<Base_window_nameContext>(_ctx, getState());
  enterRule(_localctx, 216, SQLiteParser::RuleBase_window_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2038);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Simple_funcContext ------------------------------------------------------------------

SQLiteParser::Simple_funcContext::Simple_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Simple_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Simple_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleSimple_func;
}

void SQLiteParser::Simple_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimple_func(this);
}

void SQLiteParser::Simple_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimple_func(this);
}


std::any SQLiteParser::Simple_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitSimple_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Simple_funcContext* SQLiteParser::simple_func() {
  Simple_funcContext *_localctx = _tracker.createInstance<Simple_funcContext>(_ctx, getState());
  enterRule(_localctx, 218, SQLiteParser::RuleSimple_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2040);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aggregate_funcContext ------------------------------------------------------------------

SQLiteParser::Aggregate_funcContext::Aggregate_funcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Aggregate_funcContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Aggregate_funcContext::getRuleIndex() const {
  return SQLiteParser::RuleAggregate_func;
}

void SQLiteParser::Aggregate_funcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAggregate_func(this);
}

void SQLiteParser::Aggregate_funcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAggregate_func(this);
}


std::any SQLiteParser::Aggregate_funcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAggregate_func(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Aggregate_funcContext* SQLiteParser::aggregate_func() {
  Aggregate_funcContext *_localctx = _tracker.createInstance<Aggregate_funcContext>(_ctx, getState());
  enterRule(_localctx, 220, SQLiteParser::RuleAggregate_func);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2042);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Table_function_nameContext ------------------------------------------------------------------

SQLiteParser::Table_function_nameContext::Table_function_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

SQLiteParser::Any_nameContext* SQLiteParser::Table_function_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}


size_t SQLiteParser::Table_function_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleTable_function_name;
}

void SQLiteParser::Table_function_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTable_function_name(this);
}

void SQLiteParser::Table_function_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTable_function_name(this);
}


std::any SQLiteParser::Table_function_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitTable_function_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Table_function_nameContext* SQLiteParser::table_function_name() {
  Table_function_nameContext *_localctx = _tracker.createInstance<Table_function_nameContext>(_ctx, getState());
  enterRule(_localctx, 222, SQLiteParser::RuleTable_function_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2044);
    any_name();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Any_nameContext ------------------------------------------------------------------

SQLiteParser::Any_nameContext::Any_nameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* SQLiteParser::Any_nameContext::IDENTIFIER() {
  return getToken(SQLiteParser::IDENTIFIER, 0);
}

SQLiteParser::KeywordContext* SQLiteParser::Any_nameContext::keyword() {
  return getRuleContext<SQLiteParser::KeywordContext>(0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::STRING_LITERAL() {
  return getToken(SQLiteParser::STRING_LITERAL, 0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::OPEN_PAR() {
  return getToken(SQLiteParser::OPEN_PAR, 0);
}

SQLiteParser::Any_nameContext* SQLiteParser::Any_nameContext::any_name() {
  return getRuleContext<SQLiteParser::Any_nameContext>(0);
}

tree::TerminalNode* SQLiteParser::Any_nameContext::CLOSE_PAR() {
  return getToken(SQLiteParser::CLOSE_PAR, 0);
}


size_t SQLiteParser::Any_nameContext::getRuleIndex() const {
  return SQLiteParser::RuleAny_name;
}

void SQLiteParser::Any_nameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAny_name(this);
}

void SQLiteParser::Any_nameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<SQLiteParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAny_name(this);
}


std::any SQLiteParser::Any_nameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<SQLiteParserVisitor*>(visitor))
    return parserVisitor->visitAny_name(this);
  else
    return visitor->visitChildren(this);
}

SQLiteParser::Any_nameContext* SQLiteParser::any_name() {
  Any_nameContext *_localctx = _tracker.createInstance<Any_nameContext>(_ctx, getState());
  enterRule(_localctx, 224, SQLiteParser::RuleAny_name);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2053);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case SQLiteParser::IDENTIFIER: {
        enterOuterAlt(_localctx, 1);
        setState(2046);
        match(SQLiteParser::IDENTIFIER);
        break;
      }

      case SQLiteParser::ABORT_:
      case SQLiteParser::ACTION_:
      case SQLiteParser::ADD_:
      case SQLiteParser::AFTER_:
      case SQLiteParser::ALL_:
      case SQLiteParser::ALTER_:
      case SQLiteParser::ANALYZE_:
      case SQLiteParser::AND_:
      case SQLiteParser::AS_:
      case SQLiteParser::ASC_:
      case SQLiteParser::ATTACH_:
      case SQLiteParser::AUTOINCREMENT_:
      case SQLiteParser::BEFORE_:
      case SQLiteParser::BEGIN_:
      case SQLiteParser::BETWEEN_:
      case SQLiteParser::BY_:
      case SQLiteParser::CASCADE_:
      case SQLiteParser::CASE_:
      case SQLiteParser::CAST_:
      case SQLiteParser::CHECK_:
      case SQLiteParser::COLLATE_:
      case SQLiteParser::COLUMN_:
      case SQLiteParser::COMMIT_:
      case SQLiteParser::CONFLICT_:
      case SQLiteParser::CONSTRAINT_:
      case SQLiteParser::CREATE_:
      case SQLiteParser::CROSS_:
      case SQLiteParser::CURRENT_DATE_:
      case SQLiteParser::CURRENT_TIME_:
      case SQLiteParser::CURRENT_TIMESTAMP_:
      case SQLiteParser::DATABASE_:
      case SQLiteParser::DEFAULT_:
      case SQLiteParser::DEFERRABLE_:
      case SQLiteParser::DEFERRED_:
      case SQLiteParser::DELETE_:
      case SQLiteParser::DESC_:
      case SQLiteParser::DETACH_:
      case SQLiteParser::DISTINCT_:
      case SQLiteParser::DROP_:
      case SQLiteParser::EACH_:
      case SQLiteParser::ELSE_:
      case SQLiteParser::END_:
      case SQLiteParser::ESCAPE_:
      case SQLiteParser::EXCEPT_:
      case SQLiteParser::EXCLUSIVE_:
      case SQLiteParser::EXISTS_:
      case SQLiteParser::EXPLAIN_:
      case SQLiteParser::FAIL_:
      case SQLiteParser::FOR_:
      case SQLiteParser::FOREIGN_:
      case SQLiteParser::FROM_:
      case SQLiteParser::FULL_:
      case SQLiteParser::GLOB_:
      case SQLiteParser::GROUP_:
      case SQLiteParser::HAVING_:
      case SQLiteParser::IF_:
      case SQLiteParser::IGNORE_:
      case SQLiteParser::IMMEDIATE_:
      case SQLiteParser::IN_:
      case SQLiteParser::INDEX_:
      case SQLiteParser::INDEXED_:
      case SQLiteParser::INITIALLY_:
      case SQLiteParser::INNER_:
      case SQLiteParser::INSERT_:
      case SQLiteParser::INSTEAD_:
      case SQLiteParser::INTERSECT_:
      case SQLiteParser::INTO_:
      case SQLiteParser::IS_:
      case SQLiteParser::ISNULL_:
      case SQLiteParser::JOIN_:
      case SQLiteParser::KEY_:
      case SQLiteParser::LEFT_:
      case SQLiteParser::LIKE_:
      case SQLiteParser::LIMIT_:
      case SQLiteParser::MATCH_:
      case SQLiteParser::NATURAL_:
      case SQLiteParser::NO_:
      case SQLiteParser::NOT_:
      case SQLiteParser::NOTNULL_:
      case SQLiteParser::NULL_:
      case SQLiteParser::OF_:
      case SQLiteParser::OFFSET_:
      case SQLiteParser::ON_:
      case SQLiteParser::OR_:
      case SQLiteParser::ORDER_:
      case SQLiteParser::OUTER_:
      case SQLiteParser::PLAN_:
      case SQLiteParser::PRAGMA_:
      case SQLiteParser::PRIMARY_:
      case SQLiteParser::QUERY_:
      case SQLiteParser::RAISE_:
      case SQLiteParser::RECURSIVE_:
      case SQLiteParser::REFERENCES_:
      case SQLiteParser::REGEXP_:
      case SQLiteParser::REINDEX_:
      case SQLiteParser::RELEASE_:
      case SQLiteParser::RENAME_:
      case SQLiteParser::REPLACE_:
      case SQLiteParser::RESTRICT_:
      case SQLiteParser::RIGHT_:
      case SQLiteParser::ROLLBACK_:
      case SQLiteParser::ROW_:
      case SQLiteParser::ROWS_:
      case SQLiteParser::SAVEPOINT_:
      case SQLiteParser::SELECT_:
      case SQLiteParser::SET_:
      case SQLiteParser::TABLE_:
      case SQLiteParser::TEMP_:
      case SQLiteParser::TEMPORARY_:
      case SQLiteParser::THEN_:
      case SQLiteParser::TO_:
      case SQLiteParser::TRANSACTION_:
      case SQLiteParser::TRIGGER_:
      case SQLiteParser::UNION_:
      case SQLiteParser::UNIQUE_:
      case SQLiteParser::UPDATE_:
      case SQLiteParser::USING_:
      case SQLiteParser::VACUUM_:
      case SQLiteParser::VALUES_:
      case SQLiteParser::VIEW_:
      case SQLiteParser::VIRTUAL_:
      case SQLiteParser::WHEN_:
      case SQLiteParser::WHERE_:
      case SQLiteParser::WITH_:
      case SQLiteParser::WITHOUT_:
      case SQLiteParser::FIRST_VALUE_:
      case SQLiteParser::OVER_:
      case SQLiteParser::PARTITION_:
      case SQLiteParser::RANGE_:
      case SQLiteParser::PRECEDING_:
      case SQLiteParser::UNBOUNDED_:
      case SQLiteParser::CURRENT_:
      case SQLiteParser::FOLLOWING_:
      case SQLiteParser::CUME_DIST_:
      case SQLiteParser::DENSE_RANK_:
      case SQLiteParser::LAG_:
      case SQLiteParser::LAST_VALUE_:
      case SQLiteParser::LEAD_:
      case SQLiteParser::NTH_VALUE_:
      case SQLiteParser::NTILE_:
      case SQLiteParser::PERCENT_RANK_:
      case SQLiteParser::RANK_:
      case SQLiteParser::ROW_NUMBER_:
      case SQLiteParser::GENERATED_:
      case SQLiteParser::ALWAYS_:
      case SQLiteParser::STORED_:
      case SQLiteParser::TRUE_:
      case SQLiteParser::FALSE_:
      case SQLiteParser::WINDOW_:
      case SQLiteParser::NULLS_:
      case SQLiteParser::FIRST_:
      case SQLiteParser::LAST_:
      case SQLiteParser::FILTER_:
      case SQLiteParser::GROUPS_:
      case SQLiteParser::EXCLUDE_: {
        enterOuterAlt(_localctx, 2);
        setState(2047);
        keyword();
        break;
      }

      case SQLiteParser::STRING_LITERAL: {
        enterOuterAlt(_localctx, 3);
        setState(2048);
        match(SQLiteParser::STRING_LITERAL);
        break;
      }

      case SQLiteParser::OPEN_PAR: {
        enterOuterAlt(_localctx, 4);
        setState(2049);
        match(SQLiteParser::OPEN_PAR);
        setState(2050);
        any_name();
        setState(2051);
        match(SQLiteParser::CLOSE_PAR);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool SQLiteParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 32: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool SQLiteParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 20);
    case 1: return precpred(_ctx, 19);
    case 2: return precpred(_ctx, 18);
    case 3: return precpred(_ctx, 17);
    case 4: return precpred(_ctx, 16);
    case 5: return precpred(_ctx, 15);
    case 6: return precpred(_ctx, 14);
    case 7: return precpred(_ctx, 13);
    case 8: return precpred(_ctx, 6);
    case 9: return precpred(_ctx, 5);
    case 10: return precpred(_ctx, 9);
    case 11: return precpred(_ctx, 8);
    case 12: return precpred(_ctx, 7);
    case 13: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

void SQLiteParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  sqliteparserParserInitialize();
#else
  ::antlr4::internal::call_once(sqliteparserParserOnceFlag, sqliteparserParserInitialize);
#endif
}
